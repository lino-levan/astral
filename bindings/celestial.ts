// These bindings are auto-generated by ./_tools/generate/mod.ts
// Last generated at 2024-07-05T16:32:45.946Z
// deno-lint-ignore-file no-explicit-any

import { attachWs, DEBUG } from "../src/debug.ts";
export const PROTOCOL_VERSION = "1.3";

// ----------------- Accessibility Types -----------------

/**
 * Unique accessibility node identifier.
 */
export type Accessibility_AXNodeId = string;

/**
 * Enum of possible property types.
 */
export type Accessibility_AXValueType =
  | "boolean"
  | "tristate"
  | "booleanOrUndefined"
  | "idref"
  | "idrefList"
  | "integer"
  | "node"
  | "nodeList"
  | "number"
  | "string"
  | "computedString"
  | "token"
  | "tokenList"
  | "domRelation"
  | "role"
  | "internalRole"
  | "valueUndefined";

/**
 * Enum of possible property sources.
 */
export type Accessibility_AXValueSourceType =
  | "attribute"
  | "implicit"
  | "style"
  | "contents"
  | "placeholder"
  | "relatedElement";

/**
 * Enum of possible native property sources (as a subtype of a particular AXValueSourceType).
 */
export type Accessibility_AXValueNativeSourceType =
  | "description"
  | "figcaption"
  | "label"
  | "labelfor"
  | "labelwrapped"
  | "legend"
  | "rubyannotation"
  | "tablecaption"
  | "title"
  | "other";

/**
 * A single source for a computed AX property.
 */
export type Accessibility_AXValueSource = {
  /**
   * What type of source this is.
   */
  type: Accessibility_AXValueSourceType;
  /**
   * The value of this property source.
   */
  value?: Accessibility_AXValue;
  /**
   * The name of the relevant attribute, if any.
   */
  attribute?: string;
  /**
   * The value of the relevant attribute, if any.
   */
  attributeValue?: Accessibility_AXValue;
  /**
   * Whether this source is superseded by a higher priority source.
   */
  superseded?: boolean;
  /**
   * The native markup source for this value, e.g. a `<label>` element.
   */
  nativeSource?: Accessibility_AXValueNativeSourceType;
  /**
   * The value, such as a node or node list, of the native source.
   */
  nativeSourceValue?: Accessibility_AXValue;
  /**
   * Whether the value for this property is invalid.
   */
  invalid?: boolean;
  /**
   * Reason for the value being invalid, if it is.
   */
  invalidReason?: string;
};

export type Accessibility_AXRelatedNode = {
  /**
   * The BackendNodeId of the related DOM node.
   */
  backendDOMNodeId: DOM_BackendNodeId;
  /**
   * The IDRef value provided, if any.
   */
  idref?: string;
  /**
   * The text alternative of this node in the current context.
   */
  text?: string;
};

export type Accessibility_AXProperty = {
  /**
   * The name of this property.
   */
  name: Accessibility_AXPropertyName;
  /**
   * The value of this property.
   */
  value: Accessibility_AXValue;
};

/**
 * A single computed AX property.
 */
export type Accessibility_AXValue = {
  /**
   * The type of this value.
   */
  type: Accessibility_AXValueType;
  /**
   * The computed value of this property.
   */
  value?: any;
  /**
   * One or more related nodes, if applicable.
   */
  relatedNodes?: Accessibility_AXRelatedNode[];
  /**
   * The sources which contributed to the computation of this property.
   */
  sources?: Accessibility_AXValueSource[];
};

/**
 * Values of AXProperty name:
 * - from 'busy' to 'roledescription': states which apply to every AX node
 * - from 'live' to 'root': attributes which apply to nodes in live regions
 * - from 'autocomplete' to 'valuetext': attributes which apply to widgets
 * - from 'checked' to 'selected': states which apply to widgets
 * - from 'activedescendant' to 'owns' - relationships between elements other than parent/child/sibling.
 */
export type Accessibility_AXPropertyName =
  | "busy"
  | "disabled"
  | "editable"
  | "focusable"
  | "focused"
  | "hidden"
  | "hiddenRoot"
  | "invalid"
  | "keyshortcuts"
  | "settable"
  | "roledescription"
  | "live"
  | "atomic"
  | "relevant"
  | "root"
  | "autocomplete"
  | "hasPopup"
  | "level"
  | "multiselectable"
  | "orientation"
  | "multiline"
  | "readonly"
  | "required"
  | "valuemin"
  | "valuemax"
  | "valuetext"
  | "checked"
  | "expanded"
  | "modal"
  | "pressed"
  | "selected"
  | "activedescendant"
  | "controls"
  | "describedby"
  | "details"
  | "errormessage"
  | "flowto"
  | "labelledby"
  | "owns";

/**
 * A node in the accessibility tree.
 */
export type Accessibility_AXNode = {
  /**
   * Unique identifier for this node.
   */
  nodeId: Accessibility_AXNodeId;
  /**
   * Whether this node is ignored for accessibility
   */
  ignored: boolean;
  /**
   * Collection of reasons why this node is hidden.
   */
  ignoredReasons?: Accessibility_AXProperty[];
  /**
   * This `Node`'s role, whether explicit or implicit.
   */
  role?: Accessibility_AXValue;
  /**
   * This `Node`'s Chrome raw role.
   */
  chromeRole?: Accessibility_AXValue;
  /**
   * The accessible name for this `Node`.
   */
  name?: Accessibility_AXValue;
  /**
   * The accessible description for this `Node`.
   */
  description?: Accessibility_AXValue;
  /**
   * The value for this `Node`.
   */
  value?: Accessibility_AXValue;
  /**
   * All other properties
   */
  properties?: Accessibility_AXProperty[];
  /**
   * ID for this node's parent.
   */
  parentId?: Accessibility_AXNodeId;
  /**
   * IDs for each of this node's child nodes.
   */
  childIds?: Accessibility_AXNodeId[];
  /**
   * The backend ID for the associated DOM node, if any.
   */
  backendDOMNodeId?: DOM_BackendNodeId;
  /**
   * The frame ID for the frame associated with this nodes document.
   */
  frameId?: Page_FrameId;
};

// ----------------- Animation Types -----------------

/**
 * Animation instance.
 */
export type Animation_Animation = {
  /**
   * `Animation`'s id.
   */
  id: string;
  /**
   * `Animation`'s name.
   */
  name: string;
  /**
   * `Animation`'s internal paused state.
   */
  pausedState: boolean;
  /**
   * `Animation`'s play state.
   */
  playState: string;
  /**
   * `Animation`'s playback rate.
   */
  playbackRate: number;
  /**
   * `Animation`'s start time.
   * Milliseconds for time based animations and
   * percentage [0 - 100] for scroll driven animations
   * (i.e. when viewOrScrollTimeline exists).
   */
  startTime: number;
  /**
   * `Animation`'s current time.
   */
  currentTime: number;
  /**
   * Animation type of `Animation`.
   */
  type: "CSSTransition" | "CSSAnimation" | "WebAnimation";
  /**
   * `Animation`'s source animation node.
   */
  source?: Animation_AnimationEffect;
  /**
   * A unique ID for `Animation` representing the sources that triggered this CSS
   * animation/transition.
   */
  cssId?: string;
  /**
   * View or scroll timeline
   */
  viewOrScrollTimeline?: Animation_ViewOrScrollTimeline;
};

/**
 * Timeline instance
 */
export type Animation_ViewOrScrollTimeline = {
  /**
   * Scroll container node
   */
  sourceNodeId?: DOM_BackendNodeId;
  /**
   * Represents the starting scroll position of the timeline
   * as a length offset in pixels from scroll origin.
   */
  startOffset?: number;
  /**
   * Represents the ending scroll position of the timeline
   * as a length offset in pixels from scroll origin.
   */
  endOffset?: number;
  /**
   * The element whose principal box's visibility in the
   * scrollport defined the progress of the timeline.
   * Does not exist for animations with ScrollTimeline
   */
  subjectNodeId?: DOM_BackendNodeId;
  /**
   * Orientation of the scroll
   */
  axis: DOM_ScrollOrientation;
};

/**
 * AnimationEffect instance
 */
export type Animation_AnimationEffect = {
  /**
   * `AnimationEffect`'s delay.
   */
  delay: number;
  /**
   * `AnimationEffect`'s end delay.
   */
  endDelay: number;
  /**
   * `AnimationEffect`'s iteration start.
   */
  iterationStart: number;
  /**
   * `AnimationEffect`'s iterations.
   */
  iterations: number;
  /**
   * `AnimationEffect`'s iteration duration.
   * Milliseconds for time based animations and
   * percentage [0 - 100] for scroll driven animations
   * (i.e. when viewOrScrollTimeline exists).
   */
  duration: number;
  /**
   * `AnimationEffect`'s playback direction.
   */
  direction: string;
  /**
   * `AnimationEffect`'s fill mode.
   */
  fill: string;
  /**
   * `AnimationEffect`'s target node.
   */
  backendNodeId?: DOM_BackendNodeId;
  /**
   * `AnimationEffect`'s keyframes.
   */
  keyframesRule?: Animation_KeyframesRule;
  /**
   * `AnimationEffect`'s timing function.
   */
  easing: string;
};

/**
 * Keyframes Rule
 */
export type Animation_KeyframesRule = {
  /**
   * CSS keyframed animation's name.
   */
  name?: string;
  /**
   * List of animation keyframes.
   */
  keyframes: Animation_KeyframeStyle[];
};

/**
 * Keyframe Style
 */
export type Animation_KeyframeStyle = {
  /**
   * Keyframe's time offset.
   */
  offset: string;
  /**
   * `AnimationEffect`'s timing function.
   */
  easing: string;
};

// ----------------- Audits Types -----------------

/**
 * Information about a cookie that is affected by an inspector issue.
 */
export type Audits_AffectedCookie = {
  /**
   * The following three properties uniquely identify a cookie
   */
  name: string;
  path: string;
  domain: string;
};

/**
 * Information about a request that is affected by an inspector issue.
 */
export type Audits_AffectedRequest = {
  /**
   * The unique request id.
   */
  requestId: Network_RequestId;
  url?: string;
};

/**
 * Information about the frame affected by an inspector issue.
 */
export type Audits_AffectedFrame = {
  frameId: Page_FrameId;
};

export type Audits_CookieExclusionReason =
  | "ExcludeSameSiteUnspecifiedTreatedAsLax"
  | "ExcludeSameSiteNoneInsecure"
  | "ExcludeSameSiteLax"
  | "ExcludeSameSiteStrict"
  | "ExcludeInvalidSameParty"
  | "ExcludeSamePartyCrossPartyContext"
  | "ExcludeDomainNonASCII"
  | "ExcludeThirdPartyCookieBlockedInFirstPartySet"
  | "ExcludeThirdPartyPhaseout";

export type Audits_CookieWarningReason =
  | "WarnSameSiteUnspecifiedCrossSiteContext"
  | "WarnSameSiteNoneInsecure"
  | "WarnSameSiteUnspecifiedLaxAllowUnsafe"
  | "WarnSameSiteStrictLaxDowngradeStrict"
  | "WarnSameSiteStrictCrossDowngradeStrict"
  | "WarnSameSiteStrictCrossDowngradeLax"
  | "WarnSameSiteLaxCrossDowngradeStrict"
  | "WarnSameSiteLaxCrossDowngradeLax"
  | "WarnAttributeValueExceedsMaxSize"
  | "WarnDomainNonASCII"
  | "WarnThirdPartyPhaseout"
  | "WarnCrossSiteRedirectDowngradeChangesInclusion";

export type Audits_CookieOperation = "SetCookie" | "ReadCookie";

/**
 * This information is currently necessary, as the front-end has a difficult
 * time finding a specific cookie. With this, we can convey specific error
 * information without the cookie.
 */
export type Audits_CookieIssueDetails = {
  /**
   * If AffectedCookie is not set then rawCookieLine contains the raw
   * Set-Cookie header string. This hints at a problem where the
   * cookie line is syntactically or semantically malformed in a way
   * that no valid cookie could be created.
   */
  cookie?: Audits_AffectedCookie;
  rawCookieLine?: string;
  cookieWarningReasons: Audits_CookieWarningReason[];
  cookieExclusionReasons: Audits_CookieExclusionReason[];
  /**
   * Optionally identifies the site-for-cookies and the cookie url, which
   * may be used by the front-end as additional context.
   */
  operation: Audits_CookieOperation;
  siteForCookies?: string;
  cookieUrl?: string;
  request?: Audits_AffectedRequest;
};

export type Audits_MixedContentResolutionStatus =
  | "MixedContentBlocked"
  | "MixedContentAutomaticallyUpgraded"
  | "MixedContentWarning";

export type Audits_MixedContentResourceType =
  | "AttributionSrc"
  | "Audio"
  | "Beacon"
  | "CSPReport"
  | "Download"
  | "EventSource"
  | "Favicon"
  | "Font"
  | "Form"
  | "Frame"
  | "Image"
  | "Import"
  | "JSON"
  | "Manifest"
  | "Ping"
  | "PluginData"
  | "PluginResource"
  | "Prefetch"
  | "Resource"
  | "Script"
  | "ServiceWorker"
  | "SharedWorker"
  | "SpeculationRules"
  | "Stylesheet"
  | "Track"
  | "Video"
  | "Worker"
  | "XMLHttpRequest"
  | "XSLT";

export type Audits_MixedContentIssueDetails = {
  /**
   * The type of resource causing the mixed content issue (css, js, iframe,
   * form,...). Marked as optional because it is mapped to from
   * blink::mojom::RequestContextType, which will be replaced
   * by network::mojom::RequestDestination
   */
  resourceType?: Audits_MixedContentResourceType;
  /**
   * The way the mixed content issue is being resolved.
   */
  resolutionStatus: Audits_MixedContentResolutionStatus;
  /**
   * The unsafe http url causing the mixed content issue.
   */
  insecureURL: string;
  /**
   * The url responsible for the call to an unsafe url.
   */
  mainResourceURL: string;
  /**
   * The mixed content request.
   * Does not always exist (e.g. for unsafe form submission urls).
   */
  request?: Audits_AffectedRequest;
  /**
   * Optional because not every mixed content issue is necessarily linked to a frame.
   */
  frame?: Audits_AffectedFrame;
};

/**
 * Enum indicating the reason a response has been blocked. These reasons are
 * refinements of the net error BLOCKED_BY_RESPONSE.
 */
export type Audits_BlockedByResponseReason =
  | "CoepFrameResourceNeedsCoepHeader"
  | "CoopSandboxedIFrameCannotNavigateToCoopPage"
  | "CorpNotSameOrigin"
  | "CorpNotSameOriginAfterDefaultedToSameOriginByCoep"
  | "CorpNotSameSite";

/**
 * Details for a request that has been blocked with the BLOCKED_BY_RESPONSE
 * code. Currently only used for COEP/COOP, but may be extended to include
 * some CSP errors in the future.
 */
export type Audits_BlockedByResponseIssueDetails = {
  request: Audits_AffectedRequest;
  parentFrame?: Audits_AffectedFrame;
  blockedFrame?: Audits_AffectedFrame;
  reason: Audits_BlockedByResponseReason;
};

export type Audits_HeavyAdResolutionStatus =
  | "HeavyAdBlocked"
  | "HeavyAdWarning";

export type Audits_HeavyAdReason =
  | "NetworkTotalLimit"
  | "CpuTotalLimit"
  | "CpuPeakLimit";

export type Audits_HeavyAdIssueDetails = {
  /**
   * The resolution status, either blocking the content or warning.
   */
  resolution: Audits_HeavyAdResolutionStatus;
  /**
   * The reason the ad was blocked, total network or cpu or peak cpu.
   */
  reason: Audits_HeavyAdReason;
  /**
   * The frame that was blocked.
   */
  frame: Audits_AffectedFrame;
};

export type Audits_ContentSecurityPolicyViolationType =
  | "kInlineViolation"
  | "kEvalViolation"
  | "kURLViolation"
  | "kTrustedTypesSinkViolation"
  | "kTrustedTypesPolicyViolation"
  | "kWasmEvalViolation";

export type Audits_SourceCodeLocation = {
  scriptId?: Runtime_ScriptId;
  url: string;
  lineNumber: number;
  columnNumber: number;
};

export type Audits_ContentSecurityPolicyIssueDetails = {
  /**
   * The url not included in allowed sources.
   */
  blockedURL?: string;
  /**
   * Specific directive that is violated, causing the CSP issue.
   */
  violatedDirective: string;
  isReportOnly: boolean;
  contentSecurityPolicyViolationType: Audits_ContentSecurityPolicyViolationType;
  frameAncestor?: Audits_AffectedFrame;
  sourceCodeLocation?: Audits_SourceCodeLocation;
  violatingNodeId?: DOM_BackendNodeId;
};

export type Audits_SharedArrayBufferIssueType =
  | "TransferIssue"
  | "CreationIssue";

/**
 * Details for a issue arising from an SAB being instantiated in, or
 * transferred to a context that is not cross-origin isolated.
 */
export type Audits_SharedArrayBufferIssueDetails = {
  sourceCodeLocation: Audits_SourceCodeLocation;
  isWarning: boolean;
  type: Audits_SharedArrayBufferIssueType;
};

export type Audits_LowTextContrastIssueDetails = {
  violatingNodeId: DOM_BackendNodeId;
  violatingNodeSelector: string;
  contrastRatio: number;
  thresholdAA: number;
  thresholdAAA: number;
  fontSize: string;
  fontWeight: string;
};

/**
 * Details for a CORS related issue, e.g. a warning or error related to
 * CORS RFC1918 enforcement.
 */
export type Audits_CorsIssueDetails = {
  corsErrorStatus: Network_CorsErrorStatus;
  isWarning: boolean;
  request: Audits_AffectedRequest;
  location?: Audits_SourceCodeLocation;
  initiatorOrigin?: string;
  resourceIPAddressSpace?: Network_IPAddressSpace;
  clientSecurityState?: Network_ClientSecurityState;
};

export type Audits_AttributionReportingIssueType =
  | "PermissionPolicyDisabled"
  | "UntrustworthyReportingOrigin"
  | "InsecureContext"
  | "InvalidHeader"
  | "InvalidRegisterTriggerHeader"
  | "SourceAndTriggerHeaders"
  | "SourceIgnored"
  | "TriggerIgnored"
  | "OsSourceIgnored"
  | "OsTriggerIgnored"
  | "InvalidRegisterOsSourceHeader"
  | "InvalidRegisterOsTriggerHeader"
  | "WebAndOsHeaders"
  | "NoWebOrOsSupport"
  | "NavigationRegistrationWithoutTransientUserActivation"
  | "InvalidInfoHeader"
  | "NoRegisterSourceHeader"
  | "NoRegisterTriggerHeader"
  | "NoRegisterOsSourceHeader"
  | "NoRegisterOsTriggerHeader";

/**
 * Details for issues around "Attribution Reporting API" usage.
 * Explainer: https://github.com/WICG/attribution-reporting-api
 */
export type Audits_AttributionReportingIssueDetails = {
  violationType: Audits_AttributionReportingIssueType;
  request?: Audits_AffectedRequest;
  violatingNodeId?: DOM_BackendNodeId;
  invalidParameter?: string;
};

/**
 * Details for issues about documents in Quirks Mode
 * or Limited Quirks Mode that affects page layouting.
 */
export type Audits_QuirksModeIssueDetails = {
  /**
   * If false, it means the document's mode is "quirks"
   * instead of "limited-quirks".
   */
  isLimitedQuirksMode: boolean;
  documentNodeId: DOM_BackendNodeId;
  url: string;
  frameId: Page_FrameId;
  loaderId: Network_LoaderId;
};

/**
 * @deprecated
 */
export type Audits_NavigatorUserAgentIssueDetails = {
  url: string;
  location?: Audits_SourceCodeLocation;
};

export type Audits_GenericIssueErrorType =
  | "CrossOriginPortalPostMessageError"
  | "FormLabelForNameError"
  | "FormDuplicateIdForInputError"
  | "FormInputWithNoLabelError"
  | "FormAutocompleteAttributeEmptyError"
  | "FormEmptyIdAndNameAttributesForInputError"
  | "FormAriaLabelledByToNonExistingId"
  | "FormInputAssignedAutocompleteValueToIdOrNameAttributeError"
  | "FormLabelHasNeitherForNorNestedInput"
  | "FormLabelForMatchesNonExistingIdError"
  | "FormInputHasWrongButWellIntendedAutocompleteValueError"
  | "ResponseWasBlockedByORB";

/**
 * Depending on the concrete errorType, different properties are set.
 */
export type Audits_GenericIssueDetails = {
  /**
   * Issues with the same errorType are aggregated in the frontend.
   */
  errorType: Audits_GenericIssueErrorType;
  frameId?: Page_FrameId;
  violatingNodeId?: DOM_BackendNodeId;
  violatingNodeAttribute?: string;
  request?: Audits_AffectedRequest;
};

/**
 * This issue tracks information needed to print a deprecation message.
 * https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/frame/third_party/blink/renderer/core/frame/deprecation/README.md
 */
export type Audits_DeprecationIssueDetails = {
  affectedFrame?: Audits_AffectedFrame;
  sourceCodeLocation: Audits_SourceCodeLocation;
  /**
   * One of the deprecation names from third_party/blink/renderer/core/frame/deprecation/deprecation.json5
   */
  type: string;
};

/**
 * This issue warns about sites in the redirect chain of a finished navigation
 * that may be flagged as trackers and have their state cleared if they don't
 * receive a user interaction. Note that in this context 'site' means eTLD+1.
 * For example, if the URL `https://example.test:80/bounce` was in the
 * redirect chain, the site reported would be `example.test`.
 */
export type Audits_BounceTrackingIssueDetails = {
  trackingSites: string[];
};

/**
 * This issue warns about third-party sites that are accessing cookies on the
 * current page, and have been permitted due to having a global metadata grant.
 * Note that in this context 'site' means eTLD+1. For example, if the URL
 * `https://example.test:80/web_page` was accessing cookies, the site reported
 * would be `example.test`.
 */
export type Audits_CookieDeprecationMetadataIssueDetails = {
  allowedSites: string[];
};

export type Audits_ClientHintIssueReason =
  | "MetaTagAllowListInvalidOrigin"
  | "MetaTagModifiedHTML";

export type Audits_FederatedAuthRequestIssueDetails = {
  federatedAuthRequestIssueReason: Audits_FederatedAuthRequestIssueReason;
};

/**
 * Represents the failure reason when a federated authentication reason fails.
 * Should be updated alongside RequestIdTokenStatus in
 * third_party/blink/public/mojom/devtools/inspector_issue.mojom to include
 * all cases except for success.
 */
export type Audits_FederatedAuthRequestIssueReason =
  | "ShouldEmbargo"
  | "TooManyRequests"
  | "WellKnownHttpNotFound"
  | "WellKnownNoResponse"
  | "WellKnownInvalidResponse"
  | "WellKnownListEmpty"
  | "WellKnownInvalidContentType"
  | "ConfigNotInWellKnown"
  | "WellKnownTooBig"
  | "ConfigHttpNotFound"
  | "ConfigNoResponse"
  | "ConfigInvalidResponse"
  | "ConfigInvalidContentType"
  | "ClientMetadataHttpNotFound"
  | "ClientMetadataNoResponse"
  | "ClientMetadataInvalidResponse"
  | "ClientMetadataInvalidContentType"
  | "DisabledInSettings"
  | "ErrorFetchingSignin"
  | "InvalidSigninResponse"
  | "AccountsHttpNotFound"
  | "AccountsNoResponse"
  | "AccountsInvalidResponse"
  | "AccountsListEmpty"
  | "AccountsInvalidContentType"
  | "IdTokenHttpNotFound"
  | "IdTokenNoResponse"
  | "IdTokenInvalidResponse"
  | "IdTokenIdpErrorResponse"
  | "IdTokenCrossSiteIdpErrorResponse"
  | "IdTokenInvalidRequest"
  | "IdTokenInvalidContentType"
  | "ErrorIdToken"
  | "Canceled"
  | "RpPageNotVisible"
  | "SilentMediationFailure"
  | "ThirdPartyCookiesBlocked"
  | "NotSignedInWithIdp";

export type Audits_FederatedAuthUserInfoRequestIssueDetails = {
  federatedAuthUserInfoRequestIssueReason:
    Audits_FederatedAuthUserInfoRequestIssueReason;
};

/**
 * Represents the failure reason when a getUserInfo() call fails.
 * Should be updated alongside FederatedAuthUserInfoRequestResult in
 * third_party/blink/public/mojom/devtools/inspector_issue.mojom.
 */
export type Audits_FederatedAuthUserInfoRequestIssueReason =
  | "NotSameOrigin"
  | "NotIframe"
  | "NotPotentiallyTrustworthy"
  | "NoApiPermission"
  | "NotSignedInWithIdp"
  | "NoAccountSharingPermission"
  | "InvalidConfigOrWellKnown"
  | "InvalidAccountsResponse"
  | "NoReturningUserFromFetchedAccounts";

/**
 * This issue tracks client hints related issues. It's used to deprecate old
 * features, encourage the use of new ones, and provide general guidance.
 */
export type Audits_ClientHintIssueDetails = {
  sourceCodeLocation: Audits_SourceCodeLocation;
  clientHintIssueReason: Audits_ClientHintIssueReason;
};

export type Audits_FailedRequestInfo = {
  /**
   * The URL that failed to load.
   */
  url: string;
  /**
   * The failure message for the failed request.
   */
  failureMessage: string;
  requestId?: Network_RequestId;
};

export type Audits_StyleSheetLoadingIssueReason =
  | "LateImportRule"
  | "RequestFailed";

/**
 * This issue warns when a referenced stylesheet couldn't be loaded.
 */
export type Audits_StylesheetLoadingIssueDetails = {
  /**
   * Source code position that referenced the failing stylesheet.
   */
  sourceCodeLocation: Audits_SourceCodeLocation;
  /**
   * Reason why the stylesheet couldn't be loaded.
   */
  styleSheetLoadingIssueReason: Audits_StyleSheetLoadingIssueReason;
  /**
   * Contains additional info when the failure was due to a request.
   */
  failedRequestInfo?: Audits_FailedRequestInfo;
};

export type Audits_PropertyRuleIssueReason =
  | "InvalidSyntax"
  | "InvalidInitialValue"
  | "InvalidInherits"
  | "InvalidName";

/**
 * This issue warns about errors in property rules that lead to property
 * registrations being ignored.
 */
export type Audits_PropertyRuleIssueDetails = {
  /**
   * Source code position of the property rule.
   */
  sourceCodeLocation: Audits_SourceCodeLocation;
  /**
   * Reason why the property rule was discarded.
   */
  propertyRuleIssueReason: Audits_PropertyRuleIssueReason;
  /**
   * The value of the property rule property that failed to parse
   */
  propertyValue?: string;
};

/**
 * A unique identifier for the type of issue. Each type may use one of the
 * optional fields in InspectorIssueDetails to convey more specific
 * information about the kind of issue.
 */
export type Audits_InspectorIssueCode =
  | "CookieIssue"
  | "MixedContentIssue"
  | "BlockedByResponseIssue"
  | "HeavyAdIssue"
  | "ContentSecurityPolicyIssue"
  | "SharedArrayBufferIssue"
  | "LowTextContrastIssue"
  | "CorsIssue"
  | "AttributionReportingIssue"
  | "QuirksModeIssue"
  | "NavigatorUserAgentIssue"
  | "GenericIssue"
  | "DeprecationIssue"
  | "ClientHintIssue"
  | "FederatedAuthRequestIssue"
  | "BounceTrackingIssue"
  | "CookieDeprecationMetadataIssue"
  | "StylesheetLoadingIssue"
  | "FederatedAuthUserInfoRequestIssue"
  | "PropertyRuleIssue";

/**
 * This struct holds a list of optional fields with additional information
 * specific to the kind of issue. When adding a new issue code, please also
 * add a new optional field to this type.
 */
export type Audits_InspectorIssueDetails = {
  cookieIssueDetails?: Audits_CookieIssueDetails;
  mixedContentIssueDetails?: Audits_MixedContentIssueDetails;
  blockedByResponseIssueDetails?: Audits_BlockedByResponseIssueDetails;
  heavyAdIssueDetails?: Audits_HeavyAdIssueDetails;
  contentSecurityPolicyIssueDetails?: Audits_ContentSecurityPolicyIssueDetails;
  sharedArrayBufferIssueDetails?: Audits_SharedArrayBufferIssueDetails;
  lowTextContrastIssueDetails?: Audits_LowTextContrastIssueDetails;
  corsIssueDetails?: Audits_CorsIssueDetails;
  attributionReportingIssueDetails?: Audits_AttributionReportingIssueDetails;
  quirksModeIssueDetails?: Audits_QuirksModeIssueDetails;
  /**
   * @deprecated
   */
  navigatorUserAgentIssueDetails?: Audits_NavigatorUserAgentIssueDetails;
  genericIssueDetails?: Audits_GenericIssueDetails;
  deprecationIssueDetails?: Audits_DeprecationIssueDetails;
  clientHintIssueDetails?: Audits_ClientHintIssueDetails;
  federatedAuthRequestIssueDetails?: Audits_FederatedAuthRequestIssueDetails;
  bounceTrackingIssueDetails?: Audits_BounceTrackingIssueDetails;
  cookieDeprecationMetadataIssueDetails?:
    Audits_CookieDeprecationMetadataIssueDetails;
  stylesheetLoadingIssueDetails?: Audits_StylesheetLoadingIssueDetails;
  propertyRuleIssueDetails?: Audits_PropertyRuleIssueDetails;
  federatedAuthUserInfoRequestIssueDetails?:
    Audits_FederatedAuthUserInfoRequestIssueDetails;
};

/**
 * A unique id for a DevTools inspector issue. Allows other entities (e.g.
 * exceptions, CDP message, console messages, etc.) to reference an issue.
 */
export type Audits_IssueId = string;

/**
 * An inspector issue reported from the back-end.
 */
export type Audits_InspectorIssue = {
  code: Audits_InspectorIssueCode;
  details: Audits_InspectorIssueDetails;
  /**
   * A unique id for this issue. May be omitted if no other entity (e.g.
   * exception, CDP message, etc.) is referencing this issue.
   */
  issueId?: Audits_IssueId;
};

// ----------------- Autofill Types -----------------

export type Autofill_CreditCard = {
  /**
   * 16-digit credit card number.
   */
  number: string;
  /**
   * Name of the credit card owner.
   */
  name: string;
  /**
   * 2-digit expiry month.
   */
  expiryMonth: string;
  /**
   * 4-digit expiry year.
   */
  expiryYear: string;
  /**
   * 3-digit card verification code.
   */
  cvc: string;
};

export type Autofill_AddressField = {
  /**
   * address field name, for example GIVEN_NAME.
   */
  name: string;
  /**
   * address field value, for example Jon Doe.
   */
  value: string;
};

/**
 * A list of address fields.
 */
export type Autofill_AddressFields = {
  fields: Autofill_AddressField[];
};

export type Autofill_Address = {
  /**
   * fields and values defining an address.
   */
  fields: Autofill_AddressField[];
};

/**
 * Defines how an address can be displayed like in chrome://settings/addresses.
 * Address UI is a two dimensional array, each inner array is an "address information line", and when rendered in a UI surface should be displayed as such.
 * The following address UI for instance:
 * [[{name: "GIVE_NAME", value: "Jon"}, {name: "FAMILY_NAME", value: "Doe"}], [{name: "CITY", value: "Munich"}, {name: "ZIP", value: "81456"}]]
 * should allow the receiver to render:
 * Jon Doe
 * Munich 81456
 */
export type Autofill_AddressUI = {
  /**
   * A two dimension array containing the representation of values from an address profile.
   */
  addressFields: Autofill_AddressFields[];
};

/**
 * Specified whether a filled field was done so by using the html autocomplete attribute or autofill heuristics.
 */
export type Autofill_FillingStrategy =
  | "autocompleteAttribute"
  | "autofillInferred";

export type Autofill_FilledField = {
  /**
   * The type of the field, e.g text, password etc.
   */
  htmlType: string;
  /**
   * the html id
   */
  id: string;
  /**
   * the html name
   */
  name: string;
  /**
   * the field value
   */
  value: string;
  /**
   * The actual field type, e.g FAMILY_NAME
   */
  autofillType: string;
  /**
   * The filling strategy
   */
  fillingStrategy: Autofill_FillingStrategy;
  /**
   * The frame the field belongs to
   */
  frameId: Page_FrameId;
  /**
   * The form field's DOM node
   */
  fieldId: DOM_BackendNodeId;
};

// ----------------- BackgroundService Types -----------------

/**
 * The Background Service that will be associated with the commands/events.
 * Every Background Service operates independently, but they share the same
 * API.
 */
export type BackgroundService_ServiceName =
  | "backgroundFetch"
  | "backgroundSync"
  | "pushMessaging"
  | "notifications"
  | "paymentHandler"
  | "periodicBackgroundSync";

/**
 * A key-value pair for additional event information to pass along.
 */
export type BackgroundService_EventMetadata = {
  key: string;
  value: string;
};

export type BackgroundService_BackgroundServiceEvent = {
  /**
   * Timestamp of the event (in seconds).
   */
  timestamp: Network_TimeSinceEpoch;
  /**
   * The origin this event belongs to.
   */
  origin: string;
  /**
   * The Service Worker ID that initiated the event.
   */
  serviceWorkerRegistrationId: ServiceWorker_RegistrationID;
  /**
   * The Background Service this event belongs to.
   */
  service: BackgroundService_ServiceName;
  /**
   * A description of the event.
   */
  eventName: string;
  /**
   * An identifier that groups related events together.
   */
  instanceId: string;
  /**
   * A list of event-specific information.
   */
  eventMetadata: BackgroundService_EventMetadata[];
  /**
   * Storage key this event belongs to.
   */
  storageKey: string;
};

// ----------------- Browser Types -----------------

/**
 * @experimental
 */
export type Browser_BrowserContextID = string;

/**
 * @experimental
 */
export type Browser_WindowID = number;

/**
 * @experimental
 * The state of the browser window.
 */
export type Browser_WindowState =
  | "normal"
  | "minimized"
  | "maximized"
  | "fullscreen";

/**
 * @experimental
 * Browser window bounds information
 */
export type Browser_Bounds = {
  /**
   * The offset from the left edge of the screen to the window in pixels.
   */
  left?: number;
  /**
   * The offset from the top edge of the screen to the window in pixels.
   */
  top?: number;
  /**
   * The window width in pixels.
   */
  width?: number;
  /**
   * The window height in pixels.
   */
  height?: number;
  /**
   * The window state. Default to normal.
   */
  windowState?: Browser_WindowState;
};

/**
 * @experimental
 */
export type Browser_PermissionType =
  | "accessibilityEvents"
  | "audioCapture"
  | "backgroundSync"
  | "backgroundFetch"
  | "capturedSurfaceControl"
  | "clipboardReadWrite"
  | "clipboardSanitizedWrite"
  | "displayCapture"
  | "durableStorage"
  | "flash"
  | "geolocation"
  | "idleDetection"
  | "localFonts"
  | "midi"
  | "midiSysex"
  | "nfc"
  | "notifications"
  | "paymentHandler"
  | "periodicBackgroundSync"
  | "protectedMediaIdentifier"
  | "sensors"
  | "storageAccess"
  | "speakerSelection"
  | "topLevelStorageAccess"
  | "videoCapture"
  | "videoCapturePanTiltZoom"
  | "wakeLockScreen"
  | "wakeLockSystem"
  | "windowManagement";

/**
 * @experimental
 */
export type Browser_PermissionSetting = "granted" | "denied" | "prompt";

/**
 * @experimental
 * Definition of PermissionDescriptor defined in the Permissions API:
 * https://w3c.github.io/permissions/#dom-permissiondescriptor.
 */
export type Browser_PermissionDescriptor = {
  /**
   * Name of permission.
   * See https://cs.chromium.org/chromium/src/third_party/blink/renderer/modules/permissions/permission_descriptor.idl for valid permission names.
   */
  name: string;
  /**
   * For "midi" permission, may also specify sysex control.
   */
  sysex?: boolean;
  /**
   * For "push" permission, may specify userVisibleOnly.
   * Note that userVisibleOnly = true is the only currently supported type.
   */
  userVisibleOnly?: boolean;
  /**
   * For "clipboard" permission, may specify allowWithoutSanitization.
   */
  allowWithoutSanitization?: boolean;
  /**
   * For "camera" permission, may specify panTiltZoom.
   */
  panTiltZoom?: boolean;
};

/**
 * @experimental
 * Browser command ids used by executeBrowserCommand.
 */
export type Browser_BrowserCommandId = "openTabSearch" | "closeTabSearch";

/**
 * @experimental
 * Chrome histogram bucket.
 */
export type Browser_Bucket = {
  /**
   * Minimum value (inclusive).
   */
  low: number;
  /**
   * Maximum value (exclusive).
   */
  high: number;
  /**
   * Number of samples.
   */
  count: number;
};

/**
 * @experimental
 * Chrome histogram.
 */
export type Browser_Histogram = {
  /**
   * Name.
   */
  name: string;
  /**
   * Sum of sample values.
   */
  sum: number;
  /**
   * Total number of samples.
   */
  count: number;
  /**
   * Buckets.
   */
  buckets: Browser_Bucket[];
};

// ----------------- CSS Types -----------------

export type CSS_StyleSheetId = string;

/**
 * Stylesheet type: "injected" for stylesheets injected via extension, "user-agent" for user-agent
 * stylesheets, "inspector" for stylesheets created by the inspector (i.e. those holding the "via
 * inspector" rules), "regular" for regular stylesheets.
 */
export type CSS_StyleSheetOrigin =
  | "injected"
  | "user-agent"
  | "inspector"
  | "regular";

/**
 * CSS rule collection for a single pseudo style.
 */
export type CSS_PseudoElementMatches = {
  /**
   * Pseudo element type.
   */
  pseudoType: DOM_PseudoType;
  /**
   * Pseudo element custom ident.
   */
  pseudoIdentifier?: string;
  /**
   * Matches of CSS rules applicable to the pseudo style.
   */
  matches: CSS_RuleMatch[];
};

/**
 * Inherited CSS rule collection from ancestor node.
 */
export type CSS_InheritedStyleEntry = {
  /**
   * The ancestor node's inline style, if any, in the style inheritance chain.
   */
  inlineStyle?: CSS_CSSStyle;
  /**
   * Matches of CSS rules matching the ancestor node in the style inheritance chain.
   */
  matchedCSSRules: CSS_RuleMatch[];
};

/**
 * Inherited pseudo element matches from pseudos of an ancestor node.
 */
export type CSS_InheritedPseudoElementMatches = {
  /**
   * Matches of pseudo styles from the pseudos of an ancestor node.
   */
  pseudoElements: CSS_PseudoElementMatches[];
};

/**
 * Match data for a CSS rule.
 */
export type CSS_RuleMatch = {
  /**
   * CSS rule in the match.
   */
  rule: CSS_CSSRule;
  /**
   * Matching selector indices in the rule's selectorList selectors (0-based).
   */
  matchingSelectors: number[];
};

/**
 * Data for a simple selector (these are delimited by commas in a selector list).
 */
export type CSS_Value = {
  /**
   * Value text.
   */
  text: string;
  /**
   * Value range in the underlying resource (if available).
   */
  range?: CSS_SourceRange;
  /**
   * @experimental
   * Specificity of the selector.
   */
  specificity?: CSS_Specificity;
};

/**
 * @experimental
 * Specificity:
 * https://drafts.csswg.org/selectors/#specificity-rules
 */
export type CSS_Specificity = {
  /**
   * The a component, which represents the number of ID selectors.
   */
  a: number;
  /**
   * The b component, which represents the number of class selectors, attributes selectors, and
   * pseudo-classes.
   */
  b: number;
  /**
   * The c component, which represents the number of type selectors and pseudo-elements.
   */
  c: number;
};

/**
 * Selector list data.
 */
export type CSS_SelectorList = {
  /**
   * Selectors in the list.
   */
  selectors: CSS_Value[];
  /**
   * Rule selector text.
   */
  text: string;
};

/**
 * CSS stylesheet metainformation.
 */
export type CSS_CSSStyleSheetHeader = {
  /**
   * The stylesheet identifier.
   */
  styleSheetId: CSS_StyleSheetId;
  /**
   * Owner frame identifier.
   */
  frameId: Page_FrameId;
  /**
   * Stylesheet resource URL. Empty if this is a constructed stylesheet created using
   * new CSSStyleSheet() (but non-empty if this is a constructed stylesheet imported
   * as a CSS module script).
   */
  sourceURL: string;
  /**
   * URL of source map associated with the stylesheet (if any).
   */
  sourceMapURL?: string;
  /**
   * Stylesheet origin.
   */
  origin: CSS_StyleSheetOrigin;
  /**
   * Stylesheet title.
   */
  title: string;
  /**
   * The backend id for the owner node of the stylesheet.
   */
  ownerNode?: DOM_BackendNodeId;
  /**
   * Denotes whether the stylesheet is disabled.
   */
  disabled: boolean;
  /**
   * Whether the sourceURL field value comes from the sourceURL comment.
   */
  hasSourceURL?: boolean;
  /**
   * Whether this stylesheet is created for STYLE tag by parser. This flag is not set for
   * document.written STYLE tags.
   */
  isInline: boolean;
  /**
   * Whether this stylesheet is mutable. Inline stylesheets become mutable
   * after they have been modified via CSSOM API.
   * `<link>` element's stylesheets become mutable only if DevTools modifies them.
   * Constructed stylesheets (new CSSStyleSheet()) are mutable immediately after creation.
   */
  isMutable: boolean;
  /**
   * True if this stylesheet is created through new CSSStyleSheet() or imported as a
   * CSS module script.
   */
  isConstructed: boolean;
  /**
   * Line offset of the stylesheet within the resource (zero based).
   */
  startLine: number;
  /**
   * Column offset of the stylesheet within the resource (zero based).
   */
  startColumn: number;
  /**
   * Size of the content (in characters).
   */
  length: number;
  /**
   * Line offset of the end of the stylesheet within the resource (zero based).
   */
  endLine: number;
  /**
   * Column offset of the end of the stylesheet within the resource (zero based).
   */
  endColumn: number;
  /**
   * @experimental
   * If the style sheet was loaded from a network resource, this indicates when the resource failed to load
   */
  loadingFailed?: boolean;
};

/**
 * CSS rule representation.
 */
export type CSS_CSSRule = {
  /**
   * The css style sheet identifier (absent for user agent stylesheet and user-specified
   * stylesheet rules) this rule came from.
   */
  styleSheetId?: CSS_StyleSheetId;
  /**
   * Rule selector data.
   */
  selectorList: CSS_SelectorList;
  /**
   * @experimental
   * Array of selectors from ancestor style rules, sorted by distance from the current rule.
   */
  nestingSelectors?: string[];
  /**
   * Parent stylesheet's origin.
   */
  origin: CSS_StyleSheetOrigin;
  /**
   * Associated style declaration.
   */
  style: CSS_CSSStyle;
  /**
   * Media list array (for rules involving media queries). The array enumerates media queries
   * starting with the innermost one, going outwards.
   */
  media?: CSS_CSSMedia[];
  /**
   * @experimental
   * Container query list array (for rules involving container queries).
   * The array enumerates container queries starting with the innermost one, going outwards.
   */
  containerQueries?: CSS_CSSContainerQuery[];
  /**
   * @experimental
   * @supports CSS at-rule array.
   * The array enumerates @supports at-rules starting with the innermost one, going outwards.
   */
  supports?: CSS_CSSSupports[];
  /**
   * @experimental
   * Cascade layer array. Contains the layer hierarchy that this rule belongs to starting
   * with the innermost layer and going outwards.
   */
  layers?: CSS_CSSLayer[];
  /**
   * @experimental
   * @scope CSS at-rule array.
   * The array enumerates @scope at-rules starting with the innermost one, going outwards.
   */
  scopes?: CSS_CSSScope[];
  /**
   * @experimental
   * The array keeps the types of ancestor CSSRules from the innermost going outwards.
   */
  ruleTypes?: CSS_CSSRuleType[];
};

/**
 * @experimental
 * Enum indicating the type of a CSS rule, used to represent the order of a style rule's ancestors.
 * This list only contains rule types that are collected during the ancestor rule collection.
 */
export type CSS_CSSRuleType =
  | "MediaRule"
  | "SupportsRule"
  | "ContainerRule"
  | "LayerRule"
  | "ScopeRule"
  | "StyleRule";

/**
 * CSS coverage information.
 */
export type CSS_RuleUsage = {
  /**
   * The css style sheet identifier (absent for user agent stylesheet and user-specified
   * stylesheet rules) this rule came from.
   */
  styleSheetId: CSS_StyleSheetId;
  /**
   * Offset of the start of the rule (including selector) from the beginning of the stylesheet.
   */
  startOffset: number;
  /**
   * Offset of the end of the rule body from the beginning of the stylesheet.
   */
  endOffset: number;
  /**
   * Indicates whether the rule was actually used by some element in the page.
   */
  used: boolean;
};

/**
 * Text range within a resource. All numbers are zero-based.
 */
export type CSS_SourceRange = {
  /**
   * Start line of range.
   */
  startLine: number;
  /**
   * Start column of range (inclusive).
   */
  startColumn: number;
  /**
   * End line of range
   */
  endLine: number;
  /**
   * End column of range (exclusive).
   */
  endColumn: number;
};

export type CSS_ShorthandEntry = {
  /**
   * Shorthand name.
   */
  name: string;
  /**
   * Shorthand value.
   */
  value: string;
  /**
   * Whether the property has "!important" annotation (implies `false` if absent).
   */
  important?: boolean;
};

export type CSS_CSSComputedStyleProperty = {
  /**
   * Computed style property name.
   */
  name: string;
  /**
   * Computed style property value.
   */
  value: string;
};

/**
 * CSS style representation.
 */
export type CSS_CSSStyle = {
  /**
   * The css style sheet identifier (absent for user agent stylesheet and user-specified
   * stylesheet rules) this rule came from.
   */
  styleSheetId?: CSS_StyleSheetId;
  /**
   * CSS properties in the style.
   */
  cssProperties: CSS_CSSProperty[];
  /**
   * Computed values for all shorthands found in the style.
   */
  shorthandEntries: CSS_ShorthandEntry[];
  /**
   * Style declaration text (if available).
   */
  cssText?: string;
  /**
   * Style declaration range in the enclosing stylesheet (if available).
   */
  range?: CSS_SourceRange;
};

/**
 * CSS property declaration data.
 */
export type CSS_CSSProperty = {
  /**
   * The property name.
   */
  name: string;
  /**
   * The property value.
   */
  value: string;
  /**
   * Whether the property has "!important" annotation (implies `false` if absent).
   */
  important?: boolean;
  /**
   * Whether the property is implicit (implies `false` if absent).
   */
  implicit?: boolean;
  /**
   * The full property text as specified in the style.
   */
  text?: string;
  /**
   * Whether the property is understood by the browser (implies `true` if absent).
   */
  parsedOk?: boolean;
  /**
   * Whether the property is disabled by the user (present for source-based properties only).
   */
  disabled?: boolean;
  /**
   * The entire property range in the enclosing style declaration (if available).
   */
  range?: CSS_SourceRange;
  /**
   * @experimental
   * Parsed longhand components of this property if it is a shorthand.
   * This field will be empty if the given property is not a shorthand.
   */
  longhandProperties?: CSS_CSSProperty[];
};

/**
 * CSS media rule descriptor.
 */
export type CSS_CSSMedia = {
  /**
   * Media query text.
   */
  text: string;
  /**
   * Source of the media query: "mediaRule" if specified by a @media rule, "importRule" if
   * specified by an @import rule, "linkedSheet" if specified by a "media" attribute in a linked
   * stylesheet's LINK tag, "inlineSheet" if specified by a "media" attribute in an inline
   * stylesheet's STYLE tag.
   */
  source: "mediaRule" | "importRule" | "linkedSheet" | "inlineSheet";
  /**
   * URL of the document containing the media query description.
   */
  sourceURL?: string;
  /**
   * The associated rule (@media or @import) header range in the enclosing stylesheet (if
   * available).
   */
  range?: CSS_SourceRange;
  /**
   * Identifier of the stylesheet containing this object (if exists).
   */
  styleSheetId?: CSS_StyleSheetId;
  /**
   * Array of media queries.
   */
  mediaList?: CSS_MediaQuery[];
};

/**
 * Media query descriptor.
 */
export type CSS_MediaQuery = {
  /**
   * Array of media query expressions.
   */
  expressions: CSS_MediaQueryExpression[];
  /**
   * Whether the media query condition is satisfied.
   */
  active: boolean;
};

/**
 * Media query expression descriptor.
 */
export type CSS_MediaQueryExpression = {
  /**
   * Media query expression value.
   */
  value: number;
  /**
   * Media query expression units.
   */
  unit: string;
  /**
   * Media query expression feature.
   */
  feature: string;
  /**
   * The associated range of the value text in the enclosing stylesheet (if available).
   */
  valueRange?: CSS_SourceRange;
  /**
   * Computed length of media query expression (if applicable).
   */
  computedLength?: number;
};

/**
 * @experimental
 * CSS container query rule descriptor.
 */
export type CSS_CSSContainerQuery = {
  /**
   * Container query text.
   */
  text: string;
  /**
   * The associated rule header range in the enclosing stylesheet (if
   * available).
   */
  range?: CSS_SourceRange;
  /**
   * Identifier of the stylesheet containing this object (if exists).
   */
  styleSheetId?: CSS_StyleSheetId;
  /**
   * Optional name for the container.
   */
  name?: string;
  /**
   * Optional physical axes queried for the container.
   */
  physicalAxes?: DOM_PhysicalAxes;
  /**
   * Optional logical axes queried for the container.
   */
  logicalAxes?: DOM_LogicalAxes;
};

/**
 * @experimental
 * CSS Supports at-rule descriptor.
 */
export type CSS_CSSSupports = {
  /**
   * Supports rule text.
   */
  text: string;
  /**
   * Whether the supports condition is satisfied.
   */
  active: boolean;
  /**
   * The associated rule header range in the enclosing stylesheet (if
   * available).
   */
  range?: CSS_SourceRange;
  /**
   * Identifier of the stylesheet containing this object (if exists).
   */
  styleSheetId?: CSS_StyleSheetId;
};

/**
 * @experimental
 * CSS Scope at-rule descriptor.
 */
export type CSS_CSSScope = {
  /**
   * Scope rule text.
   */
  text: string;
  /**
   * The associated rule header range in the enclosing stylesheet (if
   * available).
   */
  range?: CSS_SourceRange;
  /**
   * Identifier of the stylesheet containing this object (if exists).
   */
  styleSheetId?: CSS_StyleSheetId;
};

/**
 * @experimental
 * CSS Layer at-rule descriptor.
 */
export type CSS_CSSLayer = {
  /**
   * Layer name.
   */
  text: string;
  /**
   * The associated rule header range in the enclosing stylesheet (if
   * available).
   */
  range?: CSS_SourceRange;
  /**
   * Identifier of the stylesheet containing this object (if exists).
   */
  styleSheetId?: CSS_StyleSheetId;
};

/**
 * @experimental
 * CSS Layer data.
 */
export type CSS_CSSLayerData = {
  /**
   * Layer name.
   */
  name: string;
  /**
   * Direct sub-layers
   */
  subLayers?: CSS_CSSLayerData[];
  /**
   * Layer order. The order determines the order of the layer in the cascade order.
   * A higher number has higher priority in the cascade order.
   */
  order: number;
};

/**
 * Information about amount of glyphs that were rendered with given font.
 */
export type CSS_PlatformFontUsage = {
  /**
   * Font's family name reported by platform.
   */
  familyName: string;
  /**
   * Font's PostScript name reported by platform.
   */
  postScriptName: string;
  /**
   * Indicates if the font was downloaded or resolved locally.
   */
  isCustomFont: boolean;
  /**
   * Amount of glyphs that were rendered with this font.
   */
  glyphCount: number;
};

/**
 * Information about font variation axes for variable fonts
 */
export type CSS_FontVariationAxis = {
  /**
   * The font-variation-setting tag (a.k.a. "axis tag").
   */
  tag: string;
  /**
   * Human-readable variation name in the default language (normally, "en").
   */
  name: string;
  /**
   * The minimum value (inclusive) the font supports for this tag.
   */
  minValue: number;
  /**
   * The maximum value (inclusive) the font supports for this tag.
   */
  maxValue: number;
  /**
   * The default value.
   */
  defaultValue: number;
};

/**
 * Properties of a web font: https://www.w3.org/TR/2008/REC-CSS2-20080411/fonts.html#font-descriptions
 * and additional information such as platformFontFamily and fontVariationAxes.
 */
export type CSS_FontFace = {
  /**
   * The font-family.
   */
  fontFamily: string;
  /**
   * The font-style.
   */
  fontStyle: string;
  /**
   * The font-variant.
   */
  fontVariant: string;
  /**
   * The font-weight.
   */
  fontWeight: string;
  /**
   * The font-stretch.
   */
  fontStretch: string;
  /**
   * The font-display.
   */
  fontDisplay: string;
  /**
   * The unicode-range.
   */
  unicodeRange: string;
  /**
   * The src.
   */
  src: string;
  /**
   * The resolved platform font family
   */
  platformFontFamily: string;
  /**
   * Available variation settings (a.k.a. "axes").
   */
  fontVariationAxes?: CSS_FontVariationAxis[];
};

/**
 * CSS try rule representation.
 */
export type CSS_CSSTryRule = {
  /**
   * The css style sheet identifier (absent for user agent stylesheet and user-specified
   * stylesheet rules) this rule came from.
   */
  styleSheetId?: CSS_StyleSheetId;
  /**
   * Parent stylesheet's origin.
   */
  origin: CSS_StyleSheetOrigin;
  /**
   * Associated style declaration.
   */
  style: CSS_CSSStyle;
};

/**
 * @deprecated
 * CSS position-fallback rule representation.
 */
export type CSS_CSSPositionFallbackRule = {
  name: CSS_Value;
  /**
   * List of keyframes.
   */
  tryRules: CSS_CSSTryRule[];
};

/**
 * CSS @position-try rule representation.
 */
export type CSS_CSSPositionTryRule = {
  /**
   * The prelude dashed-ident name
   */
  name: CSS_Value;
  /**
   * The css style sheet identifier (absent for user agent stylesheet and user-specified
   * stylesheet rules) this rule came from.
   */
  styleSheetId?: CSS_StyleSheetId;
  /**
   * Parent stylesheet's origin.
   */
  origin: CSS_StyleSheetOrigin;
  /**
   * Associated style declaration.
   */
  style: CSS_CSSStyle;
};

/**
 * CSS keyframes rule representation.
 */
export type CSS_CSSKeyframesRule = {
  /**
   * Animation name.
   */
  animationName: CSS_Value;
  /**
   * List of keyframes.
   */
  keyframes: CSS_CSSKeyframeRule[];
};

/**
 * Representation of a custom property registration through CSS.registerProperty
 */
export type CSS_CSSPropertyRegistration = {
  propertyName: string;
  initialValue?: CSS_Value;
  inherits: boolean;
  syntax: string;
};

/**
 * CSS font-palette-values rule representation.
 */
export type CSS_CSSFontPaletteValuesRule = {
  /**
   * The css style sheet identifier (absent for user agent stylesheet and user-specified
   * stylesheet rules) this rule came from.
   */
  styleSheetId?: CSS_StyleSheetId;
  /**
   * Parent stylesheet's origin.
   */
  origin: CSS_StyleSheetOrigin;
  /**
   * Associated font palette name.
   */
  fontPaletteName: CSS_Value;
  /**
   * Associated style declaration.
   */
  style: CSS_CSSStyle;
};

/**
 * CSS property at-rule representation.
 */
export type CSS_CSSPropertyRule = {
  /**
   * The css style sheet identifier (absent for user agent stylesheet and user-specified
   * stylesheet rules) this rule came from.
   */
  styleSheetId?: CSS_StyleSheetId;
  /**
   * Parent stylesheet's origin.
   */
  origin: CSS_StyleSheetOrigin;
  /**
   * Associated property name.
   */
  propertyName: CSS_Value;
  /**
   * Associated style declaration.
   */
  style: CSS_CSSStyle;
};

/**
 * CSS keyframe rule representation.
 */
export type CSS_CSSKeyframeRule = {
  /**
   * The css style sheet identifier (absent for user agent stylesheet and user-specified
   * stylesheet rules) this rule came from.
   */
  styleSheetId?: CSS_StyleSheetId;
  /**
   * Parent stylesheet's origin.
   */
  origin: CSS_StyleSheetOrigin;
  /**
   * Associated key text.
   */
  keyText: CSS_Value;
  /**
   * Associated style declaration.
   */
  style: CSS_CSSStyle;
};

/**
 * A descriptor of operation to mutate style declaration text.
 */
export type CSS_StyleDeclarationEdit = {
  /**
   * The css style sheet identifier.
   */
  styleSheetId: CSS_StyleSheetId;
  /**
   * The range of the style text in the enclosing stylesheet.
   */
  range: CSS_SourceRange;
  /**
   * New style text.
   */
  text: string;
};

// ----------------- CacheStorage Types -----------------

/**
 * Unique identifier of the Cache object.
 */
export type CacheStorage_CacheId = string;

/**
 * type of HTTP response cached
 */
export type CacheStorage_CachedResponseType =
  | "basic"
  | "cors"
  | "default"
  | "error"
  | "opaqueResponse"
  | "opaqueRedirect";

/**
 * Data entry.
 */
export type CacheStorage_DataEntry = {
  /**
   * Request URL.
   */
  requestURL: string;
  /**
   * Request method.
   */
  requestMethod: string;
  /**
   * Request headers
   */
  requestHeaders: CacheStorage_Header[];
  /**
   * Number of seconds since epoch.
   */
  responseTime: number;
  /**
   * HTTP response status code.
   */
  responseStatus: number;
  /**
   * HTTP response status text.
   */
  responseStatusText: string;
  /**
   * HTTP response type
   */
  responseType: CacheStorage_CachedResponseType;
  /**
   * Response headers
   */
  responseHeaders: CacheStorage_Header[];
};

/**
 * Cache identifier.
 */
export type CacheStorage_Cache = {
  /**
   * An opaque unique id of the cache.
   */
  cacheId: CacheStorage_CacheId;
  /**
   * Security origin of the cache.
   */
  securityOrigin: string;
  /**
   * Storage key of the cache.
   */
  storageKey: string;
  /**
   * Storage bucket of the cache.
   */
  storageBucket?: Storage_StorageBucket;
  /**
   * The name of the cache.
   */
  cacheName: string;
};

export type CacheStorage_Header = {
  name: string;
  value: string;
};

/**
 * Cached response
 */
export type CacheStorage_CachedResponse = {
  /**
   * Entry content, base64-encoded.
   */
  body: string;
};

// ----------------- Cast Types -----------------

export type Cast_Sink = {
  name: string;
  id: string;
  /**
   * Text describing the current session. Present only if there is an active
   * session on the sink.
   */
  session?: string;
};

// ----------------- DOM Types -----------------

/**
 * Unique DOM node identifier.
 */
export type DOM_NodeId = number;

/**
 * Unique DOM node identifier used to reference a node that may not have been pushed to the
 * front-end.
 */
export type DOM_BackendNodeId = number;

/**
 * Backend node with a friendly name.
 */
export type DOM_BackendNode = {
  /**
   * `Node`'s nodeType.
   */
  nodeType: number;
  /**
   * `Node`'s nodeName.
   */
  nodeName: string;
  backendNodeId: DOM_BackendNodeId;
};

/**
 * Pseudo element type.
 */
export type DOM_PseudoType =
  | "first-line"
  | "first-letter"
  | "before"
  | "after"
  | "marker"
  | "backdrop"
  | "selection"
  | "target-text"
  | "spelling-error"
  | "grammar-error"
  | "highlight"
  | "first-line-inherited"
  | "scrollbar"
  | "scrollbar-thumb"
  | "scrollbar-button"
  | "scrollbar-track"
  | "scrollbar-track-piece"
  | "scrollbar-corner"
  | "resizer"
  | "input-list-button"
  | "view-transition"
  | "view-transition-group"
  | "view-transition-image-pair"
  | "view-transition-old"
  | "view-transition-new";

/**
 * Shadow root type.
 */
export type DOM_ShadowRootType = "user-agent" | "open" | "closed";

/**
 * Document compatibility mode.
 */
export type DOM_CompatibilityMode =
  | "QuirksMode"
  | "LimitedQuirksMode"
  | "NoQuirksMode";

/**
 * ContainerSelector physical axes
 */
export type DOM_PhysicalAxes = "Horizontal" | "Vertical" | "Both";

/**
 * ContainerSelector logical axes
 */
export type DOM_LogicalAxes = "Inline" | "Block" | "Both";

/**
 * Physical scroll orientation
 */
export type DOM_ScrollOrientation = "horizontal" | "vertical";

/**
 * DOM interaction is implemented in terms of mirror objects that represent the actual DOM nodes.
 * DOMNode is a base node mirror type.
 */
export type DOM_Node = {
  /**
   * Node identifier that is passed into the rest of the DOM messages as the `nodeId`. Backend
   * will only push node with given `id` once. It is aware of all requested nodes and will only
   * fire DOM events for nodes known to the client.
   */
  nodeId: DOM_NodeId;
  /**
   * The id of the parent node if any.
   */
  parentId?: DOM_NodeId;
  /**
   * The BackendNodeId for this node.
   */
  backendNodeId: DOM_BackendNodeId;
  /**
   * `Node`'s nodeType.
   */
  nodeType: number;
  /**
   * `Node`'s nodeName.
   */
  nodeName: string;
  /**
   * `Node`'s localName.
   */
  localName: string;
  /**
   * `Node`'s nodeValue.
   */
  nodeValue: string;
  /**
   * Child count for `Container` nodes.
   */
  childNodeCount?: number;
  /**
   * Child nodes of this node when requested with children.
   */
  children?: DOM_Node[];
  /**
   * Attributes of the `Element` node in the form of flat array `[name1, value1, name2, value2]`.
   */
  attributes?: string[];
  /**
   * Document URL that `Document` or `FrameOwner` node points to.
   */
  documentURL?: string;
  /**
   * Base URL that `Document` or `FrameOwner` node uses for URL completion.
   */
  baseURL?: string;
  /**
   * `DocumentType`'s publicId.
   */
  publicId?: string;
  /**
   * `DocumentType`'s systemId.
   */
  systemId?: string;
  /**
   * `DocumentType`'s internalSubset.
   */
  internalSubset?: string;
  /**
   * `Document`'s XML version in case of XML documents.
   */
  xmlVersion?: string;
  /**
   * `Attr`'s name.
   */
  name?: string;
  /**
   * `Attr`'s value.
   */
  value?: string;
  /**
   * Pseudo element type for this node.
   */
  pseudoType?: DOM_PseudoType;
  /**
   * Pseudo element identifier for this node. Only present if there is a
   * valid pseudoType.
   */
  pseudoIdentifier?: string;
  /**
   * Shadow root type.
   */
  shadowRootType?: DOM_ShadowRootType;
  /**
   * Frame ID for frame owner elements.
   */
  frameId?: Page_FrameId;
  /**
   * Content document for frame owner elements.
   */
  contentDocument?: DOM_Node;
  /**
   * Shadow root list for given element host.
   */
  shadowRoots?: DOM_Node[];
  /**
   * Content document fragment for template elements.
   */
  templateContent?: DOM_Node;
  /**
   * Pseudo elements associated with this node.
   */
  pseudoElements?: DOM_Node[];
  /**
   * @deprecated
   * Deprecated, as the HTML Imports API has been removed (crbug.com/937746).
   * This property used to return the imported document for the HTMLImport links.
   * The property is always undefined now.
   */
  importedDocument?: DOM_Node;
  /**
   * Distributed nodes for given insertion point.
   */
  distributedNodes?: DOM_BackendNode[];
  /**
   * Whether the node is SVG.
   */
  isSVG?: boolean;
  compatibilityMode?: DOM_CompatibilityMode;
  assignedSlot?: DOM_BackendNode;
};

/**
 * A structure holding an RGBA color.
 */
export type DOM_RGBA = {
  /**
   * The red component, in the [0-255] range.
   */
  r: number;
  /**
   * The green component, in the [0-255] range.
   */
  g: number;
  /**
   * The blue component, in the [0-255] range.
   */
  b: number;
  /**
   * The alpha component, in the [0-1] range (default: 1).
   */
  a?: number;
};

/**
 * An array of quad vertices, x immediately followed by y for each point, points clock-wise.
 */
export type DOM_Quad = number[];

/**
 * Box model.
 */
export type DOM_BoxModel = {
  /**
   * Content box
   */
  content: DOM_Quad;
  /**
   * Padding box
   */
  padding: DOM_Quad;
  /**
   * Border box
   */
  border: DOM_Quad;
  /**
   * Margin box
   */
  margin: DOM_Quad;
  /**
   * Node width
   */
  width: number;
  /**
   * Node height
   */
  height: number;
  /**
   * Shape outside coordinates
   */
  shapeOutside?: DOM_ShapeOutsideInfo;
};

/**
 * CSS Shape Outside details.
 */
export type DOM_ShapeOutsideInfo = {
  /**
   * Shape bounds
   */
  bounds: DOM_Quad;
  /**
   * Shape coordinate details
   */
  shape: any[];
  /**
   * Margin shape bounds
   */
  marginShape: any[];
};

/**
 * Rectangle.
 */
export type DOM_Rect = {
  /**
   * X coordinate
   */
  x: number;
  /**
   * Y coordinate
   */
  y: number;
  /**
   * Rectangle width
   */
  width: number;
  /**
   * Rectangle height
   */
  height: number;
};

export type DOM_CSSComputedStyleProperty = {
  /**
   * Computed style property name.
   */
  name: string;
  /**
   * Computed style property value.
   */
  value: string;
};

// ----------------- DOMDebugger Types -----------------

/**
 * DOM breakpoint type.
 */
export type DOMDebugger_DOMBreakpointType =
  | "subtree-modified"
  | "attribute-modified"
  | "node-removed";

/**
 * @experimental
 * CSP Violation type.
 */
export type DOMDebugger_CSPViolationType =
  | "trustedtype-sink-violation"
  | "trustedtype-policy-violation";

/**
 * Object event listener.
 */
export type DOMDebugger_EventListener = {
  /**
   * `EventListener`'s type.
   */
  type: string;
  /**
   * `EventListener`'s useCapture.
   */
  useCapture: boolean;
  /**
   * `EventListener`'s passive flag.
   */
  passive: boolean;
  /**
   * `EventListener`'s once flag.
   */
  once: boolean;
  /**
   * Script id of the handler code.
   */
  scriptId: Runtime_ScriptId;
  /**
   * Line number in the script (0-based).
   */
  lineNumber: number;
  /**
   * Column number in the script (0-based).
   */
  columnNumber: number;
  /**
   * Event handler function value.
   */
  handler?: Runtime_RemoteObject;
  /**
   * Event original handler function value.
   */
  originalHandler?: Runtime_RemoteObject;
  /**
   * Node the listener is added to (if any).
   */
  backendNodeId?: DOM_BackendNodeId;
};

// ----------------- EventBreakpoints Types -----------------

// ----------------- DOMSnapshot Types -----------------

/**
 * A Node in the DOM tree.
 */
export type DOMSnapshot_DOMNode = {
  /**
   * `Node`'s nodeType.
   */
  nodeType: number;
  /**
   * `Node`'s nodeName.
   */
  nodeName: string;
  /**
   * `Node`'s nodeValue.
   */
  nodeValue: string;
  /**
   * Only set for textarea elements, contains the text value.
   */
  textValue?: string;
  /**
   * Only set for input elements, contains the input's associated text value.
   */
  inputValue?: string;
  /**
   * Only set for radio and checkbox input elements, indicates if the element has been checked
   */
  inputChecked?: boolean;
  /**
   * Only set for option elements, indicates if the element has been selected
   */
  optionSelected?: boolean;
  /**
   * `Node`'s id, corresponds to DOM.Node.backendNodeId.
   */
  backendNodeId: DOM_BackendNodeId;
  /**
   * The indexes of the node's child nodes in the `domNodes` array returned by `getSnapshot`, if
   * any.
   */
  childNodeIndexes?: number[];
  /**
   * Attributes of an `Element` node.
   */
  attributes?: DOMSnapshot_NameValue[];
  /**
   * Indexes of pseudo elements associated with this node in the `domNodes` array returned by
   * `getSnapshot`, if any.
   */
  pseudoElementIndexes?: number[];
  /**
   * The index of the node's related layout tree node in the `layoutTreeNodes` array returned by
   * `getSnapshot`, if any.
   */
  layoutNodeIndex?: number;
  /**
   * Document URL that `Document` or `FrameOwner` node points to.
   */
  documentURL?: string;
  /**
   * Base URL that `Document` or `FrameOwner` node uses for URL completion.
   */
  baseURL?: string;
  /**
   * Only set for documents, contains the document's content language.
   */
  contentLanguage?: string;
  /**
   * Only set for documents, contains the document's character set encoding.
   */
  documentEncoding?: string;
  /**
   * `DocumentType` node's publicId.
   */
  publicId?: string;
  /**
   * `DocumentType` node's systemId.
   */
  systemId?: string;
  /**
   * Frame ID for frame owner elements and also for the document node.
   */
  frameId?: Page_FrameId;
  /**
   * The index of a frame owner element's content document in the `domNodes` array returned by
   * `getSnapshot`, if any.
   */
  contentDocumentIndex?: number;
  /**
   * Type of a pseudo element node.
   */
  pseudoType?: DOM_PseudoType;
  /**
   * Shadow root type.
   */
  shadowRootType?: DOM_ShadowRootType;
  /**
   * Whether this DOM node responds to mouse clicks. This includes nodes that have had click
   * event listeners attached via JavaScript as well as anchor tags that naturally navigate when
   * clicked.
   */
  isClickable?: boolean;
  /**
   * Details of the node's event listeners, if any.
   */
  eventListeners?: DOMDebugger_EventListener[];
  /**
   * The selected url for nodes with a srcset attribute.
   */
  currentSourceURL?: string;
  /**
   * The url of the script (if any) that generates this node.
   */
  originURL?: string;
  /**
   * Scroll offsets, set when this node is a Document.
   */
  scrollOffsetX?: number;
  scrollOffsetY?: number;
};

/**
 * Details of post layout rendered text positions. The exact layout should not be regarded as
 * stable and may change between versions.
 */
export type DOMSnapshot_InlineTextBox = {
  /**
   * The bounding box in document coordinates. Note that scroll offset of the document is ignored.
   */
  boundingBox: DOM_Rect;
  /**
   * The starting index in characters, for this post layout textbox substring. Characters that
   * would be represented as a surrogate pair in UTF-16 have length 2.
   */
  startCharacterIndex: number;
  /**
   * The number of characters in this post layout textbox substring. Characters that would be
   * represented as a surrogate pair in UTF-16 have length 2.
   */
  numCharacters: number;
};

/**
 * Details of an element in the DOM tree with a LayoutObject.
 */
export type DOMSnapshot_LayoutTreeNode = {
  /**
   * The index of the related DOM node in the `domNodes` array returned by `getSnapshot`.
   */
  domNodeIndex: number;
  /**
   * The bounding box in document coordinates. Note that scroll offset of the document is ignored.
   */
  boundingBox: DOM_Rect;
  /**
   * Contents of the LayoutText, if any.
   */
  layoutText?: string;
  /**
   * The post-layout inline text nodes, if any.
   */
  inlineTextNodes?: DOMSnapshot_InlineTextBox[];
  /**
   * Index into the `computedStyles` array returned by `getSnapshot`.
   */
  styleIndex?: number;
  /**
   * Global paint order index, which is determined by the stacking order of the nodes. Nodes
   * that are painted together will have the same index. Only provided if includePaintOrder in
   * getSnapshot was true.
   */
  paintOrder?: number;
  /**
   * Set to true to indicate the element begins a new stacking context.
   */
  isStackingContext?: boolean;
};

/**
 * A subset of the full ComputedStyle as defined by the request whitelist.
 */
export type DOMSnapshot_ComputedStyle = {
  /**
   * Name/value pairs of computed style properties.
   */
  properties: DOMSnapshot_NameValue[];
};

/**
 * A name/value pair.
 */
export type DOMSnapshot_NameValue = {
  /**
   * Attribute/property name.
   */
  name: string;
  /**
   * Attribute/property value.
   */
  value: string;
};

/**
 * Index of the string in the strings table.
 */
export type DOMSnapshot_StringIndex = number;

/**
 * Index of the string in the strings table.
 */
export type DOMSnapshot_ArrayOfStrings = DOMSnapshot_StringIndex[];

/**
 * Data that is only present on rare nodes.
 */
export type DOMSnapshot_RareStringData = {
  index: number[];
  value: DOMSnapshot_StringIndex[];
};

export type DOMSnapshot_RareBooleanData = {
  index: number[];
};

export type DOMSnapshot_RareIntegerData = {
  index: number[];
  value: number[];
};

export type DOMSnapshot_Rectangle = number[];

/**
 * Document snapshot.
 */
export type DOMSnapshot_DocumentSnapshot = {
  /**
   * Document URL that `Document` or `FrameOwner` node points to.
   */
  documentURL: DOMSnapshot_StringIndex;
  /**
   * Document title.
   */
  title: DOMSnapshot_StringIndex;
  /**
   * Base URL that `Document` or `FrameOwner` node uses for URL completion.
   */
  baseURL: DOMSnapshot_StringIndex;
  /**
   * Contains the document's content language.
   */
  contentLanguage: DOMSnapshot_StringIndex;
  /**
   * Contains the document's character set encoding.
   */
  encodingName: DOMSnapshot_StringIndex;
  /**
   * `DocumentType` node's publicId.
   */
  publicId: DOMSnapshot_StringIndex;
  /**
   * `DocumentType` node's systemId.
   */
  systemId: DOMSnapshot_StringIndex;
  /**
   * Frame ID for frame owner elements and also for the document node.
   */
  frameId: DOMSnapshot_StringIndex;
  /**
   * A table with dom nodes.
   */
  nodes: DOMSnapshot_NodeTreeSnapshot;
  /**
   * The nodes in the layout tree.
   */
  layout: DOMSnapshot_LayoutTreeSnapshot;
  /**
   * The post-layout inline text nodes.
   */
  textBoxes: DOMSnapshot_TextBoxSnapshot;
  /**
   * Horizontal scroll offset.
   */
  scrollOffsetX?: number;
  /**
   * Vertical scroll offset.
   */
  scrollOffsetY?: number;
  /**
   * Document content width.
   */
  contentWidth?: number;
  /**
   * Document content height.
   */
  contentHeight?: number;
};

/**
 * Table containing nodes.
 */
export type DOMSnapshot_NodeTreeSnapshot = {
  /**
   * Parent node index.
   */
  parentIndex?: number[];
  /**
   * `Node`'s nodeType.
   */
  nodeType?: number[];
  /**
   * Type of the shadow root the `Node` is in. String values are equal to the `ShadowRootType` enum.
   */
  shadowRootType?: DOMSnapshot_RareStringData;
  /**
   * `Node`'s nodeName.
   */
  nodeName?: DOMSnapshot_StringIndex[];
  /**
   * `Node`'s nodeValue.
   */
  nodeValue?: DOMSnapshot_StringIndex[];
  /**
   * `Node`'s id, corresponds to DOM.Node.backendNodeId.
   */
  backendNodeId?: DOM_BackendNodeId[];
  /**
   * Attributes of an `Element` node. Flatten name, value pairs.
   */
  attributes?: DOMSnapshot_ArrayOfStrings[];
  /**
   * Only set for textarea elements, contains the text value.
   */
  textValue?: DOMSnapshot_RareStringData;
  /**
   * Only set for input elements, contains the input's associated text value.
   */
  inputValue?: DOMSnapshot_RareStringData;
  /**
   * Only set for radio and checkbox input elements, indicates if the element has been checked
   */
  inputChecked?: DOMSnapshot_RareBooleanData;
  /**
   * Only set for option elements, indicates if the element has been selected
   */
  optionSelected?: DOMSnapshot_RareBooleanData;
  /**
   * The index of the document in the list of the snapshot documents.
   */
  contentDocumentIndex?: DOMSnapshot_RareIntegerData;
  /**
   * Type of a pseudo element node.
   */
  pseudoType?: DOMSnapshot_RareStringData;
  /**
   * Pseudo element identifier for this node. Only present if there is a
   * valid pseudoType.
   */
  pseudoIdentifier?: DOMSnapshot_RareStringData;
  /**
   * Whether this DOM node responds to mouse clicks. This includes nodes that have had click
   * event listeners attached via JavaScript as well as anchor tags that naturally navigate when
   * clicked.
   */
  isClickable?: DOMSnapshot_RareBooleanData;
  /**
   * The selected url for nodes with a srcset attribute.
   */
  currentSourceURL?: DOMSnapshot_RareStringData;
  /**
   * The url of the script (if any) that generates this node.
   */
  originURL?: DOMSnapshot_RareStringData;
};

/**
 * Table of details of an element in the DOM tree with a LayoutObject.
 */
export type DOMSnapshot_LayoutTreeSnapshot = {
  /**
   * Index of the corresponding node in the `NodeTreeSnapshot` array returned by `captureSnapshot`.
   */
  nodeIndex: number[];
  /**
   * Array of indexes specifying computed style strings, filtered according to the `computedStyles` parameter passed to `captureSnapshot`.
   */
  styles: DOMSnapshot_ArrayOfStrings[];
  /**
   * The absolute position bounding box.
   */
  bounds: DOMSnapshot_Rectangle[];
  /**
   * Contents of the LayoutText, if any.
   */
  text: DOMSnapshot_StringIndex[];
  /**
   * Stacking context information.
   */
  stackingContexts: DOMSnapshot_RareBooleanData;
  /**
   * Global paint order index, which is determined by the stacking order of the nodes. Nodes
   * that are painted together will have the same index. Only provided if includePaintOrder in
   * captureSnapshot was true.
   */
  paintOrders?: number[];
  /**
   * The offset rect of nodes. Only available when includeDOMRects is set to true
   */
  offsetRects?: DOMSnapshot_Rectangle[];
  /**
   * The scroll rect of nodes. Only available when includeDOMRects is set to true
   */
  scrollRects?: DOMSnapshot_Rectangle[];
  /**
   * The client rect of nodes. Only available when includeDOMRects is set to true
   */
  clientRects?: DOMSnapshot_Rectangle[];
  /**
   * @experimental
   * The list of background colors that are blended with colors of overlapping elements.
   */
  blendedBackgroundColors?: DOMSnapshot_StringIndex[];
  /**
   * @experimental
   * The list of computed text opacities.
   */
  textColorOpacities?: number[];
};

/**
 * Table of details of the post layout rendered text positions. The exact layout should not be regarded as
 * stable and may change between versions.
 */
export type DOMSnapshot_TextBoxSnapshot = {
  /**
   * Index of the layout tree node that owns this box collection.
   */
  layoutIndex: number[];
  /**
   * The absolute position bounding box.
   */
  bounds: DOMSnapshot_Rectangle[];
  /**
   * The starting index in characters, for this post layout textbox substring. Characters that
   * would be represented as a surrogate pair in UTF-16 have length 2.
   */
  start: number[];
  /**
   * The number of characters in this post layout textbox substring. Characters that would be
   * represented as a surrogate pair in UTF-16 have length 2.
   */
  length: number[];
};

// ----------------- DOMStorage Types -----------------

export type DOMStorage_SerializedStorageKey = string;

/**
 * DOM Storage identifier.
 */
export type DOMStorage_StorageId = {
  /**
   * Security origin for the storage.
   */
  securityOrigin?: string;
  /**
   * Represents a key by which DOM Storage keys its CachedStorageAreas
   */
  storageKey?: DOMStorage_SerializedStorageKey;
  /**
   * Whether the storage is local storage (not session storage).
   */
  isLocalStorage: boolean;
};

/**
 * DOM Storage item.
 */
export type DOMStorage_Item = string[];

// ----------------- Database Types -----------------

/**
 * Unique identifier of Database object.
 */
export type Database_DatabaseId = string;

/**
 * Database object.
 */
export type Database_Database = {
  /**
   * Database ID.
   */
  id: Database_DatabaseId;
  /**
   * Database domain.
   */
  domain: string;
  /**
   * Database name.
   */
  name: string;
  /**
   * Database version.
   */
  version: string;
};

/**
 * Database error.
 */
export type Database_Error = {
  /**
   * Error message.
   */
  message: string;
  /**
   * Error code.
   */
  code: number;
};

// ----------------- DeviceOrientation Types -----------------

// ----------------- Emulation Types -----------------

/**
 * Screen orientation.
 */
export type Emulation_ScreenOrientation = {
  /**
   * Orientation type.
   */
  type:
    | "portraitPrimary"
    | "portraitSecondary"
    | "landscapePrimary"
    | "landscapeSecondary";
  /**
   * Orientation angle.
   */
  angle: number;
};

export type Emulation_DisplayFeature = {
  /**
   * Orientation of a display feature in relation to screen
   */
  orientation: "vertical" | "horizontal";
  /**
   * The offset from the screen origin in either the x (for vertical
   * orientation) or y (for horizontal orientation) direction.
   */
  offset: number;
  /**
   * A display feature may mask content such that it is not physically
   * displayed - this length along with the offset describes this area.
   * A display feature that only splits content will have a 0 mask_length.
   */
  maskLength: number;
};

export type Emulation_DevicePosture = {
  /**
   * Current posture of the device
   */
  type: "continuous" | "folded";
};

export type Emulation_MediaFeature = {
  name: string;
  value: string;
};

/**
 * @experimental
 * advance: If the scheduler runs out of immediate work, the virtual time base may fast forward to
 * allow the next delayed task (if any) to run; pause: The virtual time base may not advance;
 * pauseIfNetworkFetchesPending: The virtual time base may not advance if there are any pending
 * resource fetches.
 */
export type Emulation_VirtualTimePolicy =
  | "advance"
  | "pause"
  | "pauseIfNetworkFetchesPending";

/**
 * @experimental
 * Used to specify User Agent Client Hints to emulate. See https://wicg.github.io/ua-client-hints
 */
export type Emulation_UserAgentBrandVersion = {
  brand: string;
  version: string;
};

/**
 * @experimental
 * Used to specify User Agent Client Hints to emulate. See https://wicg.github.io/ua-client-hints
 * Missing optional values will be filled in by the target with what it would normally use.
 */
export type Emulation_UserAgentMetadata = {
  /**
   * Brands appearing in Sec-CH-UA.
   */
  brands?: Emulation_UserAgentBrandVersion[];
  /**
   * Brands appearing in Sec-CH-UA-Full-Version-List.
   */
  fullVersionList?: Emulation_UserAgentBrandVersion[];
  /**
   * @deprecated
   */
  fullVersion?: string;
  platform: string;
  platformVersion: string;
  architecture: string;
  model: string;
  mobile: boolean;
  bitness?: string;
  wow64?: boolean;
};

/**
 * @experimental
 * Used to specify sensor types to emulate.
 * See https://w3c.github.io/sensors/#automation for more information.
 */
export type Emulation_SensorType =
  | "absolute-orientation"
  | "accelerometer"
  | "ambient-light"
  | "gravity"
  | "gyroscope"
  | "linear-acceleration"
  | "magnetometer"
  | "proximity"
  | "relative-orientation";

/**
 * @experimental
 */
export type Emulation_SensorMetadata = {
  available?: boolean;
  minimumFrequency?: number;
  maximumFrequency?: number;
};

/**
 * @experimental
 */
export type Emulation_SensorReadingSingle = {
  value: number;
};

/**
 * @experimental
 */
export type Emulation_SensorReadingXYZ = {
  x: number;
  y: number;
  z: number;
};

/**
 * @experimental
 */
export type Emulation_SensorReadingQuaternion = {
  x: number;
  y: number;
  z: number;
  w: number;
};

/**
 * @experimental
 */
export type Emulation_SensorReading = {
  single?: Emulation_SensorReadingSingle;
  xyz?: Emulation_SensorReadingXYZ;
  quaternion?: Emulation_SensorReadingQuaternion;
};

/**
 * @experimental
 * Enum of image types that can be disabled.
 */
export type Emulation_DisabledImageType = "avif" | "webp";

// ----------------- HeadlessExperimental Types -----------------

/**
 * Encoding options for a screenshot.
 */
export type HeadlessExperimental_ScreenshotParams = {
  /**
   * Image compression format (defaults to png).
   */
  format?: "jpeg" | "png" | "webp";
  /**
   * Compression quality from range [0..100] (jpeg and webp only).
   */
  quality?: number;
  /**
   * Optimize image encoding for speed, not for resulting size (defaults to false)
   */
  optimizeForSpeed?: boolean;
};

// ----------------- IO Types -----------------

/**
 * This is either obtained from another method or specified as `blob:<uuid>` where
 * `<uuid>` is an UUID of a Blob.
 */
export type IO_StreamHandle = string;

// ----------------- IndexedDB Types -----------------

/**
 * Database with an array of object stores.
 */
export type IndexedDB_DatabaseWithObjectStores = {
  /**
   * Database name.
   */
  name: string;
  /**
   * Database version (type is not 'integer', as the standard
   * requires the version number to be 'unsigned long long')
   */
  version: number;
  /**
   * Object stores in this database.
   */
  objectStores: IndexedDB_ObjectStore[];
};

/**
 * Object store.
 */
export type IndexedDB_ObjectStore = {
  /**
   * Object store name.
   */
  name: string;
  /**
   * Object store key path.
   */
  keyPath: IndexedDB_KeyPath;
  /**
   * If true, object store has auto increment flag set.
   */
  autoIncrement: boolean;
  /**
   * Indexes in this object store.
   */
  indexes: IndexedDB_ObjectStoreIndex[];
};

/**
 * Object store index.
 */
export type IndexedDB_ObjectStoreIndex = {
  /**
   * Index name.
   */
  name: string;
  /**
   * Index key path.
   */
  keyPath: IndexedDB_KeyPath;
  /**
   * If true, index is unique.
   */
  unique: boolean;
  /**
   * If true, index allows multiple entries for a key.
   */
  multiEntry: boolean;
};

/**
 * Key.
 */
export type IndexedDB_Key = {
  /**
   * Key type.
   */
  type: "number" | "string" | "date" | "array";
  /**
   * Number value.
   */
  number?: number;
  /**
   * String value.
   */
  string?: string;
  /**
   * Date value.
   */
  date?: number;
  /**
   * Array value.
   */
  array?: IndexedDB_Key[];
};

/**
 * Key range.
 */
export type IndexedDB_KeyRange = {
  /**
   * Lower bound.
   */
  lower?: IndexedDB_Key;
  /**
   * Upper bound.
   */
  upper?: IndexedDB_Key;
  /**
   * If true lower bound is open.
   */
  lowerOpen: boolean;
  /**
   * If true upper bound is open.
   */
  upperOpen: boolean;
};

/**
 * Data entry.
 */
export type IndexedDB_DataEntry = {
  /**
   * Key object.
   */
  key: Runtime_RemoteObject;
  /**
   * Primary key object.
   */
  primaryKey: Runtime_RemoteObject;
  /**
   * Value object.
   */
  value: Runtime_RemoteObject;
};

/**
 * Key path.
 */
export type IndexedDB_KeyPath = {
  /**
   * Key path type.
   */
  type: "null" | "string" | "array";
  /**
   * String value.
   */
  string?: string;
  /**
   * Array value.
   */
  array?: string[];
};

// ----------------- Input Types -----------------

export type Input_TouchPoint = {
  /**
   * X coordinate of the event relative to the main frame's viewport in CSS pixels.
   */
  x: number;
  /**
   * Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to
   * the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
   */
  y: number;
  /**
   * X radius of the touch area (default: 1.0).
   */
  radiusX?: number;
  /**
   * Y radius of the touch area (default: 1.0).
   */
  radiusY?: number;
  /**
   * Rotation angle (default: 0.0).
   */
  rotationAngle?: number;
  /**
   * Force (default: 1.0).
   */
  force?: number;
  /**
   * @experimental
   * The normalized tangential pressure, which has a range of [-1,1] (default: 0).
   */
  tangentialPressure?: number;
  /**
   * The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0)
   */
  tiltX?: number;
  /**
   * The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
   */
  tiltY?: number;
  /**
   * @experimental
   * The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
   */
  twist?: number;
  /**
   * Identifier used to track touch sources between events, must be unique within an event.
   */
  id?: number;
};

/**
 * @experimental
 */
export type Input_GestureSourceType = "default" | "touch" | "mouse";

export type Input_MouseButton =
  | "none"
  | "left"
  | "middle"
  | "right"
  | "back"
  | "forward";

/**
 * UTC time in seconds, counted from January 1, 1970.
 */
export type Input_TimeSinceEpoch = number;

/**
 * @experimental
 */
export type Input_DragDataItem = {
  /**
   * Mime type of the dragged data.
   */
  mimeType: string;
  /**
   * Depending of the value of `mimeType`, it contains the dragged link,
   * text, HTML markup or any other data.
   */
  data: string;
  /**
   * Title associated with a link. Only valid when `mimeType` == "text/uri-list".
   */
  title?: string;
  /**
   * Stores the base URL for the contained markup. Only valid when `mimeType`
   * == "text/html".
   */
  baseURL?: string;
};

/**
 * @experimental
 */
export type Input_DragData = {
  items: Input_DragDataItem[];
  /**
   * List of filenames that should be included when dropping
   */
  files?: string[];
  /**
   * Bit field representing allowed drag operations. Copy = 1, Link = 2, Move = 16
   */
  dragOperationsMask: number;
};

// ----------------- Inspector Types -----------------

// ----------------- LayerTree Types -----------------

/**
 * Unique Layer identifier.
 */
export type LayerTree_LayerId = string;

/**
 * Unique snapshot identifier.
 */
export type LayerTree_SnapshotId = string;

/**
 * Rectangle where scrolling happens on the main thread.
 */
export type LayerTree_ScrollRect = {
  /**
   * Rectangle itself.
   */
  rect: DOM_Rect;
  /**
   * Reason for rectangle to force scrolling on the main thread
   */
  type: "RepaintsOnScroll" | "TouchEventHandler" | "WheelEventHandler";
};

/**
 * Sticky position constraints.
 */
export type LayerTree_StickyPositionConstraint = {
  /**
   * Layout rectangle of the sticky element before being shifted
   */
  stickyBoxRect: DOM_Rect;
  /**
   * Layout rectangle of the containing block of the sticky element
   */
  containingBlockRect: DOM_Rect;
  /**
   * The nearest sticky layer that shifts the sticky box
   */
  nearestLayerShiftingStickyBox?: LayerTree_LayerId;
  /**
   * The nearest sticky layer that shifts the containing block
   */
  nearestLayerShiftingContainingBlock?: LayerTree_LayerId;
};

/**
 * Serialized fragment of layer picture along with its offset within the layer.
 */
export type LayerTree_PictureTile = {
  /**
   * Offset from owning layer left boundary
   */
  x: number;
  /**
   * Offset from owning layer top boundary
   */
  y: number;
  /**
   * Base64-encoded snapshot data.
   */
  picture: string;
};

/**
 * Information about a compositing layer.
 */
export type LayerTree_Layer = {
  /**
   * The unique id for this layer.
   */
  layerId: LayerTree_LayerId;
  /**
   * The id of parent (not present for root).
   */
  parentLayerId?: LayerTree_LayerId;
  /**
   * The backend id for the node associated with this layer.
   */
  backendNodeId?: DOM_BackendNodeId;
  /**
   * Offset from parent layer, X coordinate.
   */
  offsetX: number;
  /**
   * Offset from parent layer, Y coordinate.
   */
  offsetY: number;
  /**
   * Layer width.
   */
  width: number;
  /**
   * Layer height.
   */
  height: number;
  /**
   * Transformation matrix for layer, default is identity matrix
   */
  transform?: number[];
  /**
   * Transform anchor point X, absent if no transform specified
   */
  anchorX?: number;
  /**
   * Transform anchor point Y, absent if no transform specified
   */
  anchorY?: number;
  /**
   * Transform anchor point Z, absent if no transform specified
   */
  anchorZ?: number;
  /**
   * Indicates how many time this layer has painted.
   */
  paintCount: number;
  /**
   * Indicates whether this layer hosts any content, rather than being used for
   * transform/scrolling purposes only.
   */
  drawsContent: boolean;
  /**
   * Set if layer is not visible.
   */
  invisible?: boolean;
  /**
   * Rectangles scrolling on main thread only.
   */
  scrollRects?: LayerTree_ScrollRect[];
  /**
   * Sticky position constraint information
   */
  stickyPositionConstraint?: LayerTree_StickyPositionConstraint;
};

/**
 * Array of timings, one per paint step.
 */
export type LayerTree_PaintProfile = number[];

// ----------------- Log Types -----------------

/**
 * Log entry.
 */
export type Log_LogEntry = {
  /**
   * Log entry source.
   */
  source:
    | "xml"
    | "javascript"
    | "network"
    | "storage"
    | "appcache"
    | "rendering"
    | "security"
    | "deprecation"
    | "worker"
    | "violation"
    | "intervention"
    | "recommendation"
    | "other";
  /**
   * Log entry severity.
   */
  level: "verbose" | "info" | "warning" | "error";
  /**
   * Logged text.
   */
  text: string;
  category?: "cors";
  /**
   * Timestamp when this entry was added.
   */
  timestamp: Runtime_Timestamp;
  /**
   * URL of the resource if known.
   */
  url?: string;
  /**
   * Line number in the resource.
   */
  lineNumber?: number;
  /**
   * JavaScript stack trace.
   */
  stackTrace?: Runtime_StackTrace;
  /**
   * Identifier of the network request associated with this entry.
   */
  networkRequestId?: Network_RequestId;
  /**
   * Identifier of the worker associated with this entry.
   */
  workerId?: string;
  /**
   * Call arguments.
   */
  args?: Runtime_RemoteObject[];
};

/**
 * Violation configuration setting.
 */
export type Log_ViolationSetting = {
  /**
   * Violation type.
   */
  name:
    | "longTask"
    | "longLayout"
    | "blockedEvent"
    | "blockedParser"
    | "discouragedAPIUse"
    | "handler"
    | "recurringHandler";
  /**
   * Time threshold to trigger upon.
   */
  threshold: number;
};

// ----------------- Memory Types -----------------

/**
 * Memory pressure level.
 */
export type Memory_PressureLevel = "moderate" | "critical";

/**
 * Heap profile sample.
 */
export type Memory_SamplingProfileNode = {
  /**
   * Size of the sampled allocation.
   */
  size: number;
  /**
   * Total bytes attributed to this sample.
   */
  total: number;
  /**
   * Execution stack at the point of allocation.
   */
  stack: string[];
};

/**
 * Array of heap profile samples.
 */
export type Memory_SamplingProfile = {
  samples: Memory_SamplingProfileNode[];
  modules: Memory_Module[];
};

/**
 * Executable module information
 */
export type Memory_Module = {
  /**
   * Name of the module.
   */
  name: string;
  /**
   * UUID of the module.
   */
  uuid: string;
  /**
   * Base address where the module is loaded into memory. Encoded as a decimal
   * or hexadecimal (0x prefixed) string.
   */
  baseAddress: string;
  /**
   * Size of the module in bytes.
   */
  size: number;
};

// ----------------- Network Types -----------------

/**
 * Resource type as it was perceived by the rendering engine.
 */
export type Network_ResourceType =
  | "Document"
  | "Stylesheet"
  | "Image"
  | "Media"
  | "Font"
  | "Script"
  | "TextTrack"
  | "XHR"
  | "Fetch"
  | "Prefetch"
  | "EventSource"
  | "WebSocket"
  | "Manifest"
  | "SignedExchange"
  | "Ping"
  | "CSPViolationReport"
  | "Preflight"
  | "Other";

/**
 * Unique loader identifier.
 */
export type Network_LoaderId = string;

/**
 * Unique request identifier.
 */
export type Network_RequestId = string;

/**
 * Unique intercepted request identifier.
 */
export type Network_InterceptionId = string;

/**
 * Network level fetch failure reason.
 */
export type Network_ErrorReason =
  | "Failed"
  | "Aborted"
  | "TimedOut"
  | "AccessDenied"
  | "ConnectionClosed"
  | "ConnectionReset"
  | "ConnectionRefused"
  | "ConnectionAborted"
  | "ConnectionFailed"
  | "NameNotResolved"
  | "InternetDisconnected"
  | "AddressUnreachable"
  | "BlockedByClient"
  | "BlockedByResponse";

/**
 * UTC time in seconds, counted from January 1, 1970.
 */
export type Network_TimeSinceEpoch = number;

/**
 * Monotonically increasing time in seconds since an arbitrary point in the past.
 */
export type Network_MonotonicTime = number;

/**
 * Request / response headers as keys / values of JSON object.
 */
export type Network_Headers = object;

/**
 * The underlying connection technology that the browser is supposedly using.
 */
export type Network_ConnectionType =
  | "none"
  | "cellular2g"
  | "cellular3g"
  | "cellular4g"
  | "bluetooth"
  | "ethernet"
  | "wifi"
  | "wimax"
  | "other";

/**
 * Represents the cookie's 'SameSite' status:
 * https://tools.ietf.org/html/draft-west-first-party-cookies
 */
export type Network_CookieSameSite = "Strict" | "Lax" | "None";

/**
 * @experimental
 * Represents the cookie's 'Priority' status:
 * https://tools.ietf.org/html/draft-west-cookie-priority-00
 */
export type Network_CookiePriority = "Low" | "Medium" | "High";

/**
 * @experimental
 * Represents the source scheme of the origin that originally set the cookie.
 * A value of "Unset" allows protocol clients to emulate legacy cookie scope for the scheme.
 * This is a temporary ability and it will be removed in the future.
 */
export type Network_CookieSourceScheme = "Unset" | "NonSecure" | "Secure";

/**
 * Timing information for the request.
 */
export type Network_ResourceTiming = {
  /**
   * Timing's requestTime is a baseline in seconds, while the other numbers are ticks in
   * milliseconds relatively to this requestTime.
   */
  requestTime: number;
  /**
   * Started resolving proxy.
   */
  proxyStart: number;
  /**
   * Finished resolving proxy.
   */
  proxyEnd: number;
  /**
   * Started DNS address resolve.
   */
  dnsStart: number;
  /**
   * Finished DNS address resolve.
   */
  dnsEnd: number;
  /**
   * Started connecting to the remote host.
   */
  connectStart: number;
  /**
   * Connected to the remote host.
   */
  connectEnd: number;
  /**
   * Started SSL handshake.
   */
  sslStart: number;
  /**
   * Finished SSL handshake.
   */
  sslEnd: number;
  /**
   * @experimental
   * Started running ServiceWorker.
   */
  workerStart: number;
  /**
   * @experimental
   * Finished Starting ServiceWorker.
   */
  workerReady: number;
  /**
   * @experimental
   * Started fetch event.
   */
  workerFetchStart: number;
  /**
   * @experimental
   * Settled fetch event respondWith promise.
   */
  workerRespondWithSettled: number;
  /**
   * Started sending request.
   */
  sendStart: number;
  /**
   * Finished sending request.
   */
  sendEnd: number;
  /**
   * @experimental
   * Time the server started pushing request.
   */
  pushStart: number;
  /**
   * @experimental
   * Time the server finished pushing request.
   */
  pushEnd: number;
  /**
   * @experimental
   * Started receiving response headers.
   */
  receiveHeadersStart: number;
  /**
   * Finished receiving response headers.
   */
  receiveHeadersEnd: number;
};

/**
 * Loading priority of a resource request.
 */
export type Network_ResourcePriority =
  | "VeryLow"
  | "Low"
  | "Medium"
  | "High"
  | "VeryHigh";

/**
 * Post data entry for HTTP request
 */
export type Network_PostDataEntry = {
  bytes?: string;
};

/**
 * HTTP request data.
 */
export type Network_Request = {
  /**
   * Request URL (without fragment).
   */
  url: string;
  /**
   * Fragment of the requested URL starting with hash, if present.
   */
  urlFragment?: string;
  /**
   * HTTP request method.
   */
  method: string;
  /**
   * HTTP request headers.
   */
  headers: Network_Headers;
  /**
   * @deprecated
   * HTTP POST request data.
   * Use postDataEntries instead.
   */
  postData?: string;
  /**
   * True when the request has POST data. Note that postData might still be omitted when this flag is true when the data is too long.
   */
  hasPostData?: boolean;
  /**
   * @experimental
   * Request body elements (post data broken into individual entries).
   */
  postDataEntries?: Network_PostDataEntry[];
  /**
   * The mixed content type of the request.
   */
  mixedContentType?: Security_MixedContentType;
  /**
   * Priority of the resource request at the time request is sent.
   */
  initialPriority: Network_ResourcePriority;
  /**
   * The referrer policy of the request, as defined in https://www.w3.org/TR/referrer-policy/
   */
  referrerPolicy:
    | "unsafe-url"
    | "no-referrer-when-downgrade"
    | "no-referrer"
    | "origin"
    | "origin-when-cross-origin"
    | "same-origin"
    | "strict-origin"
    | "strict-origin-when-cross-origin";
  /**
   * Whether is loaded via link preload.
   */
  isLinkPreload?: boolean;
  /**
   * @experimental
   * Set for requests when the TrustToken API is used. Contains the parameters
   * passed by the developer (e.g. via "fetch") as understood by the backend.
   */
  trustTokenParams?: Network_TrustTokenParams;
  /**
   * @experimental
   * True if this resource request is considered to be the 'same site' as the
   * request corresponding to the main frame.
   */
  isSameSite?: boolean;
};

/**
 * Details of a signed certificate timestamp (SCT).
 */
export type Network_SignedCertificateTimestamp = {
  /**
   * Validation status.
   */
  status: string;
  /**
   * Origin.
   */
  origin: string;
  /**
   * Log name / description.
   */
  logDescription: string;
  /**
   * Log ID.
   */
  logId: string;
  /**
   * Issuance date. Unlike TimeSinceEpoch, this contains the number of
   * milliseconds since January 1, 1970, UTC, not the number of seconds.
   */
  timestamp: number;
  /**
   * Hash algorithm.
   */
  hashAlgorithm: string;
  /**
   * Signature algorithm.
   */
  signatureAlgorithm: string;
  /**
   * Signature data.
   */
  signatureData: string;
};

/**
 * Security details about a request.
 */
export type Network_SecurityDetails = {
  /**
   * Protocol name (e.g. "TLS 1.2" or "QUIC").
   */
  protocol: string;
  /**
   * Key Exchange used by the connection, or the empty string if not applicable.
   */
  keyExchange: string;
  /**
   * (EC)DH group used by the connection, if applicable.
   */
  keyExchangeGroup?: string;
  /**
   * Cipher name.
   */
  cipher: string;
  /**
   * TLS MAC. Note that AEAD ciphers do not have separate MACs.
   */
  mac?: string;
  /**
   * Certificate ID value.
   */
  certificateId: Security_CertificateId;
  /**
   * Certificate subject name.
   */
  subjectName: string;
  /**
   * Subject Alternative Name (SAN) DNS names and IP addresses.
   */
  sanList: string[];
  /**
   * Name of the issuing CA.
   */
  issuer: string;
  /**
   * Certificate valid from date.
   */
  validFrom: Network_TimeSinceEpoch;
  /**
   * Certificate valid to (expiration) date
   */
  validTo: Network_TimeSinceEpoch;
  /**
   * List of signed certificate timestamps (SCTs).
   */
  signedCertificateTimestampList: Network_SignedCertificateTimestamp[];
  /**
   * Whether the request complied with Certificate Transparency policy
   */
  certificateTransparencyCompliance: Network_CertificateTransparencyCompliance;
  /**
   * The signature algorithm used by the server in the TLS server signature,
   * represented as a TLS SignatureScheme code point. Omitted if not
   * applicable or not known.
   */
  serverSignatureAlgorithm?: number;
  /**
   * Whether the connection used Encrypted ClientHello
   */
  encryptedClientHello: boolean;
};

/**
 * Whether the request complied with Certificate Transparency policy.
 */
export type Network_CertificateTransparencyCompliance =
  | "unknown"
  | "not-compliant"
  | "compliant";

/**
 * The reason why request was blocked.
 */
export type Network_BlockedReason =
  | "other"
  | "csp"
  | "mixed-content"
  | "origin"
  | "inspector"
  | "subresource-filter"
  | "content-type"
  | "coep-frame-resource-needs-coep-header"
  | "coop-sandboxed-iframe-cannot-navigate-to-coop-page"
  | "corp-not-same-origin"
  | "corp-not-same-origin-after-defaulted-to-same-origin-by-coep"
  | "corp-not-same-site";

/**
 * The reason why request was blocked.
 */
export type Network_CorsError =
  | "DisallowedByMode"
  | "InvalidResponse"
  | "WildcardOriginNotAllowed"
  | "MissingAllowOriginHeader"
  | "MultipleAllowOriginValues"
  | "InvalidAllowOriginValue"
  | "AllowOriginMismatch"
  | "InvalidAllowCredentials"
  | "CorsDisabledScheme"
  | "PreflightInvalidStatus"
  | "PreflightDisallowedRedirect"
  | "PreflightWildcardOriginNotAllowed"
  | "PreflightMissingAllowOriginHeader"
  | "PreflightMultipleAllowOriginValues"
  | "PreflightInvalidAllowOriginValue"
  | "PreflightAllowOriginMismatch"
  | "PreflightInvalidAllowCredentials"
  | "PreflightMissingAllowExternal"
  | "PreflightInvalidAllowExternal"
  | "PreflightMissingAllowPrivateNetwork"
  | "PreflightInvalidAllowPrivateNetwork"
  | "InvalidAllowMethodsPreflightResponse"
  | "InvalidAllowHeadersPreflightResponse"
  | "MethodDisallowedByPreflightResponse"
  | "HeaderDisallowedByPreflightResponse"
  | "RedirectContainsCredentials"
  | "InsecurePrivateNetwork"
  | "InvalidPrivateNetworkAccess"
  | "UnexpectedPrivateNetworkAccess"
  | "NoCorsRedirectModeNotFollow"
  | "PreflightMissingPrivateNetworkAccessId"
  | "PreflightMissingPrivateNetworkAccessName"
  | "PrivateNetworkAccessPermissionUnavailable"
  | "PrivateNetworkAccessPermissionDenied";

export type Network_CorsErrorStatus = {
  corsError: Network_CorsError;
  failedParameter: string;
};

/**
 * Source of serviceworker response.
 */
export type Network_ServiceWorkerResponseSource =
  | "cache-storage"
  | "http-cache"
  | "fallback-code"
  | "network";

/**
 * @experimental
 * Determines what type of Trust Token operation is executed and
 * depending on the type, some additional parameters. The values
 * are specified in third_party/blink/renderer/core/fetch/trust_token.idl.
 */
export type Network_TrustTokenParams = {
  operation: Network_TrustTokenOperationType;
  /**
   * Only set for "token-redemption" operation and determine whether
   * to request a fresh SRR or use a still valid cached SRR.
   */
  refreshPolicy: "UseCached" | "Refresh";
  /**
   * Origins of issuers from whom to request tokens or redemption
   * records.
   */
  issuers?: string[];
};

/**
 * @experimental
 */
export type Network_TrustTokenOperationType =
  | "Issuance"
  | "Redemption"
  | "Signing";

/**
 * @experimental
 * The reason why Chrome uses a specific transport protocol for HTTP semantics.
 */
export type Network_AlternateProtocolUsage =
  | "alternativeJobWonWithoutRace"
  | "alternativeJobWonRace"
  | "mainJobWonRace"
  | "mappingMissing"
  | "broken"
  | "dnsAlpnH3JobWonWithoutRace"
  | "dnsAlpnH3JobWonRace"
  | "unspecifiedReason";

/**
 * Source of service worker router.
 */
export type Network_ServiceWorkerRouterSource =
  | "network"
  | "cache"
  | "fetch-event"
  | "race-network-and-fetch-handler";

/**
 * @experimental
 */
export type Network_ServiceWorkerRouterInfo = {
  ruleIdMatched: number;
  matchedSourceType: Network_ServiceWorkerRouterSource;
};

/**
 * HTTP response data.
 */
export type Network_Response = {
  /**
   * Response URL. This URL can be different from CachedResource.url in case of redirect.
   */
  url: string;
  /**
   * HTTP response status code.
   */
  status: number;
  /**
   * HTTP response status text.
   */
  statusText: string;
  /**
   * HTTP response headers.
   */
  headers: Network_Headers;
  /**
   * @deprecated
   * HTTP response headers text. This has been replaced by the headers in Network.responseReceivedExtraInfo.
   */
  headersText?: string;
  /**
   * Resource mimeType as determined by the browser.
   */
  mimeType: string;
  /**
   * Resource charset as determined by the browser (if applicable).
   */
  charset: string;
  /**
   * Refined HTTP request headers that were actually transmitted over the network.
   */
  requestHeaders?: Network_Headers;
  /**
   * @deprecated
   * HTTP request headers text. This has been replaced by the headers in Network.requestWillBeSentExtraInfo.
   */
  requestHeadersText?: string;
  /**
   * Specifies whether physical connection was actually reused for this request.
   */
  connectionReused: boolean;
  /**
   * Physical connection id that was actually used for this request.
   */
  connectionId: number;
  /**
   * Remote IP address.
   */
  remoteIPAddress?: string;
  /**
   * Remote port.
   */
  remotePort?: number;
  /**
   * Specifies that the request was served from the disk cache.
   */
  fromDiskCache?: boolean;
  /**
   * Specifies that the request was served from the ServiceWorker.
   */
  fromServiceWorker?: boolean;
  /**
   * Specifies that the request was served from the prefetch cache.
   */
  fromPrefetchCache?: boolean;
  /**
   * Specifies that the request was served from the prefetch cache.
   */
  fromEarlyHints?: boolean;
  /**
   * @experimental
   * Information about how Service Worker Static Router was used.
   */
  serviceWorkerRouterInfo?: Network_ServiceWorkerRouterInfo;
  /**
   * Total number of bytes received for this request so far.
   */
  encodedDataLength: number;
  /**
   * Timing information for the given request.
   */
  timing?: Network_ResourceTiming;
  /**
   * Response source of response from ServiceWorker.
   */
  serviceWorkerResponseSource?: Network_ServiceWorkerResponseSource;
  /**
   * The time at which the returned response was generated.
   */
  responseTime?: Network_TimeSinceEpoch;
  /**
   * Cache Storage Cache Name.
   */
  cacheStorageCacheName?: string;
  /**
   * Protocol used to fetch this request.
   */
  protocol?: string;
  /**
   * @experimental
   * The reason why Chrome uses a specific transport protocol for HTTP semantics.
   */
  alternateProtocolUsage?: Network_AlternateProtocolUsage;
  /**
   * Security state of the request resource.
   */
  securityState: Security_SecurityState;
  /**
   * Security details for the request.
   */
  securityDetails?: Network_SecurityDetails;
};

/**
 * WebSocket request data.
 */
export type Network_WebSocketRequest = {
  /**
   * HTTP request headers.
   */
  headers: Network_Headers;
};

/**
 * WebSocket response data.
 */
export type Network_WebSocketResponse = {
  /**
   * HTTP response status code.
   */
  status: number;
  /**
   * HTTP response status text.
   */
  statusText: string;
  /**
   * HTTP response headers.
   */
  headers: Network_Headers;
  /**
   * HTTP response headers text.
   */
  headersText?: string;
  /**
   * HTTP request headers.
   */
  requestHeaders?: Network_Headers;
  /**
   * HTTP request headers text.
   */
  requestHeadersText?: string;
};

/**
 * WebSocket message data. This represents an entire WebSocket message, not just a fragmented frame as the name suggests.
 */
export type Network_WebSocketFrame = {
  /**
   * WebSocket message opcode.
   */
  opcode: number;
  /**
   * WebSocket message mask.
   */
  mask: boolean;
  /**
   * WebSocket message payload data.
   * If the opcode is 1, this is a text message and payloadData is a UTF-8 string.
   * If the opcode isn't 1, then payloadData is a base64 encoded string representing binary data.
   */
  payloadData: string;
};

/**
 * Information about the cached resource.
 */
export type Network_CachedResource = {
  /**
   * Resource URL. This is the url of the original network request.
   */
  url: string;
  /**
   * Type of this resource.
   */
  type: Network_ResourceType;
  /**
   * Cached response data.
   */
  response?: Network_Response;
  /**
   * Cached response body size.
   */
  bodySize: number;
};

/**
 * Information about the request initiator.
 */
export type Network_Initiator = {
  /**
   * Type of this initiator.
   */
  type:
    | "parser"
    | "script"
    | "preload"
    | "SignedExchange"
    | "preflight"
    | "other";
  /**
   * Initiator JavaScript stack trace, set for Script only.
   */
  stack?: Runtime_StackTrace;
  /**
   * Initiator URL, set for Parser type or for Script type (when script is importing module) or for SignedExchange type.
   */
  url?: string;
  /**
   * Initiator line number, set for Parser type or for Script type (when script is importing
   * module) (0-based).
   */
  lineNumber?: number;
  /**
   * Initiator column number, set for Parser type or for Script type (when script is importing
   * module) (0-based).
   */
  columnNumber?: number;
  /**
   * Set if another request triggered this request (e.g. preflight).
   */
  requestId?: Network_RequestId;
};

/**
 * Cookie object
 */
export type Network_Cookie = {
  /**
   * Cookie name.
   */
  name: string;
  /**
   * Cookie value.
   */
  value: string;
  /**
   * Cookie domain.
   */
  domain: string;
  /**
   * Cookie path.
   */
  path: string;
  /**
   * Cookie expiration date as the number of seconds since the UNIX epoch.
   */
  expires: number;
  /**
   * Cookie size.
   */
  size: number;
  /**
   * True if cookie is http-only.
   */
  httpOnly: boolean;
  /**
   * True if cookie is secure.
   */
  secure: boolean;
  /**
   * True in case of session cookie.
   */
  session: boolean;
  /**
   * Cookie SameSite type.
   */
  sameSite?: Network_CookieSameSite;
  /**
   * @experimental
   * Cookie Priority
   */
  priority: Network_CookiePriority;
  /**
   * @experimental
   * @deprecated
   * True if cookie is SameParty.
   */
  sameParty: boolean;
  /**
   * @experimental
   * Cookie source scheme type.
   */
  sourceScheme: Network_CookieSourceScheme;
  /**
   * @experimental
   * Cookie source port. Valid values are {-1, [1, 65535]}, -1 indicates an unspecified port.
   * An unspecified port value allows protocol clients to emulate legacy cookie scope for the port.
   * This is a temporary ability and it will be removed in the future.
   */
  sourcePort: number;
  /**
   * @experimental
   * Cookie partition key. The site of the top-level URL the browser was visiting at the start
   * of the request to the endpoint that set the cookie.
   */
  partitionKey?: string;
  /**
   * @experimental
   * True if cookie partition key is opaque.
   */
  partitionKeyOpaque?: boolean;
};

/**
 * @experimental
 * Types of reasons why a cookie may not be stored from a response.
 */
export type Network_SetCookieBlockedReason =
  | "SecureOnly"
  | "SameSiteStrict"
  | "SameSiteLax"
  | "SameSiteUnspecifiedTreatedAsLax"
  | "SameSiteNoneInsecure"
  | "UserPreferences"
  | "ThirdPartyPhaseout"
  | "ThirdPartyBlockedInFirstPartySet"
  | "SyntaxError"
  | "SchemeNotSupported"
  | "OverwriteSecure"
  | "InvalidDomain"
  | "InvalidPrefix"
  | "UnknownError"
  | "SchemefulSameSiteStrict"
  | "SchemefulSameSiteLax"
  | "SchemefulSameSiteUnspecifiedTreatedAsLax"
  | "SamePartyFromCrossPartyContext"
  | "SamePartyConflictsWithOtherAttributes"
  | "NameValuePairExceedsMaxSize"
  | "DisallowedCharacter"
  | "NoCookieContent";

/**
 * @experimental
 * Types of reasons why a cookie may not be sent with a request.
 */
export type Network_CookieBlockedReason =
  | "SecureOnly"
  | "NotOnPath"
  | "DomainMismatch"
  | "SameSiteStrict"
  | "SameSiteLax"
  | "SameSiteUnspecifiedTreatedAsLax"
  | "SameSiteNoneInsecure"
  | "UserPreferences"
  | "ThirdPartyPhaseout"
  | "ThirdPartyBlockedInFirstPartySet"
  | "UnknownError"
  | "SchemefulSameSiteStrict"
  | "SchemefulSameSiteLax"
  | "SchemefulSameSiteUnspecifiedTreatedAsLax"
  | "SamePartyFromCrossPartyContext"
  | "NameValuePairExceedsMaxSize";

/**
 * @experimental
 * Types of reasons why a cookie should have been blocked by 3PCD but is exempted for the request.
 */
export type Network_CookieExemptionReason =
  | "None"
  | "UserSetting"
  | "TPCDMetadata"
  | "TPCDDeprecationTrial"
  | "TPCDHeuristics"
  | "EnterprisePolicy"
  | "StorageAccess"
  | "TopLevelStorageAccess"
  | "CorsOptIn";

/**
 * @experimental
 * A cookie which was not stored from a response with the corresponding reason.
 */
export type Network_BlockedSetCookieWithReason = {
  /**
   * The reason(s) this cookie was blocked.
   */
  blockedReasons: Network_SetCookieBlockedReason[];
  /**
   * The string representing this individual cookie as it would appear in the header.
   * This is not the entire "cookie" or "set-cookie" header which could have multiple cookies.
   */
  cookieLine: string;
  /**
   * The cookie object which represents the cookie which was not stored. It is optional because
   * sometimes complete cookie information is not available, such as in the case of parsing
   * errors.
   */
  cookie?: Network_Cookie;
};

/**
 * @experimental
 * A cookie should have been blocked by 3PCD but is exempted and stored from a response with the
 * corresponding reason. A cookie could only have at most one exemption reason.
 */
export type Network_ExemptedSetCookieWithReason = {
  /**
   * The reason the cookie was exempted.
   */
  exemptionReason: Network_CookieExemptionReason;
  /**
   * The string representing this individual cookie as it would appear in the header.
   */
  cookieLine: string;
  /**
   * The cookie object representing the cookie.
   */
  cookie: Network_Cookie;
};

/**
 * @experimental
 * A cookie associated with the request which may or may not be sent with it.
 * Includes the cookies itself and reasons for blocking or exemption.
 */
export type Network_AssociatedCookie = {
  /**
   * The cookie object representing the cookie which was not sent.
   */
  cookie: Network_Cookie;
  /**
   * The reason(s) the cookie was blocked. If empty means the cookie is included.
   */
  blockedReasons: Network_CookieBlockedReason[];
  /**
   * The reason the cookie should have been blocked by 3PCD but is exempted. A cookie could
   * only have at most one exemption reason.
   */
  exemptionReason?: Network_CookieExemptionReason;
};

/**
 * Cookie parameter object
 */
export type Network_CookieParam = {
  /**
   * Cookie name.
   */
  name: string;
  /**
   * Cookie value.
   */
  value: string;
  /**
   * The request-URI to associate with the setting of the cookie. This value can affect the
   * default domain, path, source port, and source scheme values of the created cookie.
   */
  url?: string;
  /**
   * Cookie domain.
   */
  domain?: string;
  /**
   * Cookie path.
   */
  path?: string;
  /**
   * True if cookie is secure.
   */
  secure?: boolean;
  /**
   * True if cookie is http-only.
   */
  httpOnly?: boolean;
  /**
   * Cookie SameSite type.
   */
  sameSite?: Network_CookieSameSite;
  /**
   * Cookie expiration date, session cookie if not set
   */
  expires?: Network_TimeSinceEpoch;
  /**
   * @experimental
   * Cookie Priority.
   */
  priority?: Network_CookiePriority;
  /**
   * @experimental
   * True if cookie is SameParty.
   */
  sameParty?: boolean;
  /**
   * @experimental
   * Cookie source scheme type.
   */
  sourceScheme?: Network_CookieSourceScheme;
  /**
   * @experimental
   * Cookie source port. Valid values are {-1, [1, 65535]}, -1 indicates an unspecified port.
   * An unspecified port value allows protocol clients to emulate legacy cookie scope for the port.
   * This is a temporary ability and it will be removed in the future.
   */
  sourcePort?: number;
  /**
   * @experimental
   * Cookie partition key. The site of the top-level URL the browser was visiting at the start
   * of the request to the endpoint that set the cookie.
   * If not set, the cookie will be set as not partitioned.
   */
  partitionKey?: string;
};

/**
 * @experimental
 * Authorization challenge for HTTP status code 401 or 407.
 */
export type Network_AuthChallenge = {
  /**
   * Source of the authentication challenge.
   */
  source?: "Server" | "Proxy";
  /**
   * Origin of the challenger.
   */
  origin: string;
  /**
   * The authentication scheme used, such as basic or digest
   */
  scheme: string;
  /**
   * The realm of the challenge. May be empty.
   */
  realm: string;
};

/**
 * @experimental
 * Response to an AuthChallenge.
 */
export type Network_AuthChallengeResponse = {
  /**
   * The decision on what to do in response to the authorization challenge.  Default means
   * deferring to the default behavior of the net stack, which will likely either the Cancel
   * authentication or display a popup dialog box.
   */
  response: "Default" | "CancelAuth" | "ProvideCredentials";
  /**
   * The username to provide, possibly empty. Should only be set if response is
   * ProvideCredentials.
   */
  username?: string;
  /**
   * The password to provide, possibly empty. Should only be set if response is
   * ProvideCredentials.
   */
  password?: string;
};

/**
 * @experimental
 * Stages of the interception to begin intercepting. Request will intercept before the request is
 * sent. Response will intercept after the response is received.
 */
export type Network_InterceptionStage = "Request" | "HeadersReceived";

/**
 * @experimental
 * Request pattern for interception.
 */
export type Network_RequestPattern = {
  /**
   * Wildcards (`'*'` -> zero or more, `'?'` -> exactly one) are allowed. Escape character is
   * backslash. Omitting is equivalent to `"*"`.
   */
  urlPattern?: string;
  /**
   * If set, only requests for matching resource types will be intercepted.
   */
  resourceType?: Network_ResourceType;
  /**
   * Stage at which to begin intercepting requests. Default is Request.
   */
  interceptionStage?: Network_InterceptionStage;
};

/**
 * @experimental
 * Information about a signed exchange signature.
 * https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#rfc.section.3.1
 */
export type Network_SignedExchangeSignature = {
  /**
   * Signed exchange signature label.
   */
  label: string;
  /**
   * The hex string of signed exchange signature.
   */
  signature: string;
  /**
   * Signed exchange signature integrity.
   */
  integrity: string;
  /**
   * Signed exchange signature cert Url.
   */
  certUrl?: string;
  /**
   * The hex string of signed exchange signature cert sha256.
   */
  certSha256?: string;
  /**
   * Signed exchange signature validity Url.
   */
  validityUrl: string;
  /**
   * Signed exchange signature date.
   */
  date: number;
  /**
   * Signed exchange signature expires.
   */
  expires: number;
  /**
   * The encoded certificates.
   */
  certificates?: string[];
};

/**
 * @experimental
 * Information about a signed exchange header.
 * https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#cbor-representation
 */
export type Network_SignedExchangeHeader = {
  /**
   * Signed exchange request URL.
   */
  requestUrl: string;
  /**
   * Signed exchange response code.
   */
  responseCode: number;
  /**
   * Signed exchange response headers.
   */
  responseHeaders: Network_Headers;
  /**
   * Signed exchange response signature.
   */
  signatures: Network_SignedExchangeSignature[];
  /**
   * Signed exchange header integrity hash in the form of `sha256-<base64-hash-value>`.
   */
  headerIntegrity: string;
};

/**
 * @experimental
 * Field type for a signed exchange related error.
 */
export type Network_SignedExchangeErrorField =
  | "signatureSig"
  | "signatureIntegrity"
  | "signatureCertUrl"
  | "signatureCertSha256"
  | "signatureValidityUrl"
  | "signatureTimestamps";

/**
 * @experimental
 * Information about a signed exchange response.
 */
export type Network_SignedExchangeError = {
  /**
   * Error message.
   */
  message: string;
  /**
   * The index of the signature which caused the error.
   */
  signatureIndex?: number;
  /**
   * The field which caused the error.
   */
  errorField?: Network_SignedExchangeErrorField;
};

/**
 * @experimental
 * Information about a signed exchange response.
 */
export type Network_SignedExchangeInfo = {
  /**
   * The outer response of signed HTTP exchange which was received from network.
   */
  outerResponse: Network_Response;
  /**
   * Information about the signed exchange header.
   */
  header?: Network_SignedExchangeHeader;
  /**
   * Security details for the signed exchange header.
   */
  securityDetails?: Network_SecurityDetails;
  /**
   * Errors occurred while handling the signed exchange.
   */
  errors?: Network_SignedExchangeError[];
};

/**
 * @experimental
 * List of content encodings supported by the backend.
 */
export type Network_ContentEncoding = "deflate" | "gzip" | "br" | "zstd";

/**
 * @experimental
 */
export type Network_PrivateNetworkRequestPolicy =
  | "Allow"
  | "BlockFromInsecureToMorePrivate"
  | "WarnFromInsecureToMorePrivate"
  | "PreflightBlock"
  | "PreflightWarn";

/**
 * @experimental
 */
export type Network_IPAddressSpace = "Local" | "Private" | "Public" | "Unknown";

/**
 * @experimental
 */
export type Network_ConnectTiming = {
  /**
   * Timing's requestTime is a baseline in seconds, while the other numbers are ticks in
   * milliseconds relatively to this requestTime. Matches ResourceTiming's requestTime for
   * the same request (but not for redirected requests).
   */
  requestTime: number;
};

/**
 * @experimental
 */
export type Network_ClientSecurityState = {
  initiatorIsSecureContext: boolean;
  initiatorIPAddressSpace: Network_IPAddressSpace;
  privateNetworkRequestPolicy: Network_PrivateNetworkRequestPolicy;
};

/**
 * @experimental
 */
export type Network_CrossOriginOpenerPolicyValue =
  | "SameOrigin"
  | "SameOriginAllowPopups"
  | "RestrictProperties"
  | "UnsafeNone"
  | "SameOriginPlusCoep"
  | "RestrictPropertiesPlusCoep";

/**
 * @experimental
 */
export type Network_CrossOriginOpenerPolicyStatus = {
  value: Network_CrossOriginOpenerPolicyValue;
  reportOnlyValue: Network_CrossOriginOpenerPolicyValue;
  reportingEndpoint?: string;
  reportOnlyReportingEndpoint?: string;
};

/**
 * @experimental
 */
export type Network_CrossOriginEmbedderPolicyValue =
  | "None"
  | "Credentialless"
  | "RequireCorp";

/**
 * @experimental
 */
export type Network_CrossOriginEmbedderPolicyStatus = {
  value: Network_CrossOriginEmbedderPolicyValue;
  reportOnlyValue: Network_CrossOriginEmbedderPolicyValue;
  reportingEndpoint?: string;
  reportOnlyReportingEndpoint?: string;
};

/**
 * @experimental
 */
export type Network_ContentSecurityPolicySource = "HTTP" | "Meta";

/**
 * @experimental
 */
export type Network_ContentSecurityPolicyStatus = {
  effectiveDirectives: string;
  isEnforced: boolean;
  source: Network_ContentSecurityPolicySource;
};

/**
 * @experimental
 */
export type Network_SecurityIsolationStatus = {
  coop?: Network_CrossOriginOpenerPolicyStatus;
  coep?: Network_CrossOriginEmbedderPolicyStatus;
  csp?: Network_ContentSecurityPolicyStatus[];
};

/**
 * @experimental
 * The status of a Reporting API report.
 */
export type Network_ReportStatus =
  | "Queued"
  | "Pending"
  | "MarkedForRemoval"
  | "Success";

/**
 * @experimental
 */
export type Network_ReportId = string;

/**
 * @experimental
 * An object representing a report generated by the Reporting API.
 */
export type Network_ReportingApiReport = {
  id: Network_ReportId;
  /**
   * The URL of the document that triggered the report.
   */
  initiatorUrl: string;
  /**
   * The name of the endpoint group that should be used to deliver the report.
   */
  destination: string;
  /**
   * The type of the report (specifies the set of data that is contained in the report body).
   */
  type: string;
  /**
   * When the report was generated.
   */
  timestamp: Network_TimeSinceEpoch;
  /**
   * How many uploads deep the related request was.
   */
  depth: number;
  /**
   * The number of delivery attempts made so far, not including an active attempt.
   */
  completedAttempts: number;
  body: object;
  status: Network_ReportStatus;
};

/**
 * @experimental
 */
export type Network_ReportingApiEndpoint = {
  /**
   * The URL of the endpoint to which reports may be delivered.
   */
  url: string;
  /**
   * Name of the endpoint group.
   */
  groupName: string;
};

/**
 * @experimental
 * An object providing the result of a network resource load.
 */
export type Network_LoadNetworkResourcePageResult = {
  success: boolean;
  /**
   * Optional values used for error reporting.
   */
  netError?: number;
  netErrorName?: string;
  httpStatusCode?: number;
  /**
   * If successful, one of the following two fields holds the result.
   */
  stream?: IO_StreamHandle;
  /**
   * Response headers.
   */
  headers?: Network_Headers;
};

/**
 * @experimental
 * An options object that may be extended later to better support CORS,
 * CORB and streaming.
 */
export type Network_LoadNetworkResourceOptions = {
  disableCache: boolean;
  includeCredentials: boolean;
};

// ----------------- Overlay Types -----------------

/**
 * Configuration data for drawing the source order of an elements children.
 */
export type Overlay_SourceOrderConfig = {
  /**
   * the color to outline the given element in.
   */
  parentOutlineColor: DOM_RGBA;
  /**
   * the color to outline the child elements in.
   */
  childOutlineColor: DOM_RGBA;
};

/**
 * Configuration data for the highlighting of Grid elements.
 */
export type Overlay_GridHighlightConfig = {
  /**
   * Whether the extension lines from grid cells to the rulers should be shown (default: false).
   */
  showGridExtensionLines?: boolean;
  /**
   * Show Positive line number labels (default: false).
   */
  showPositiveLineNumbers?: boolean;
  /**
   * Show Negative line number labels (default: false).
   */
  showNegativeLineNumbers?: boolean;
  /**
   * Show area name labels (default: false).
   */
  showAreaNames?: boolean;
  /**
   * Show line name labels (default: false).
   */
  showLineNames?: boolean;
  /**
   * Show track size labels (default: false).
   */
  showTrackSizes?: boolean;
  /**
   * The grid container border highlight color (default: transparent).
   */
  gridBorderColor?: DOM_RGBA;
  /**
   * @deprecated
   * The cell border color (default: transparent). Deprecated, please use rowLineColor and columnLineColor instead.
   */
  cellBorderColor?: DOM_RGBA;
  /**
   * The row line color (default: transparent).
   */
  rowLineColor?: DOM_RGBA;
  /**
   * The column line color (default: transparent).
   */
  columnLineColor?: DOM_RGBA;
  /**
   * Whether the grid border is dashed (default: false).
   */
  gridBorderDash?: boolean;
  /**
   * @deprecated
   * Whether the cell border is dashed (default: false). Deprecated, please us rowLineDash and columnLineDash instead.
   */
  cellBorderDash?: boolean;
  /**
   * Whether row lines are dashed (default: false).
   */
  rowLineDash?: boolean;
  /**
   * Whether column lines are dashed (default: false).
   */
  columnLineDash?: boolean;
  /**
   * The row gap highlight fill color (default: transparent).
   */
  rowGapColor?: DOM_RGBA;
  /**
   * The row gap hatching fill color (default: transparent).
   */
  rowHatchColor?: DOM_RGBA;
  /**
   * The column gap highlight fill color (default: transparent).
   */
  columnGapColor?: DOM_RGBA;
  /**
   * The column gap hatching fill color (default: transparent).
   */
  columnHatchColor?: DOM_RGBA;
  /**
   * The named grid areas border color (Default: transparent).
   */
  areaBorderColor?: DOM_RGBA;
  /**
   * The grid container background color (Default: transparent).
   */
  gridBackgroundColor?: DOM_RGBA;
};

/**
 * Configuration data for the highlighting of Flex container elements.
 */
export type Overlay_FlexContainerHighlightConfig = {
  /**
   * The style of the container border
   */
  containerBorder?: Overlay_LineStyle;
  /**
   * The style of the separator between lines
   */
  lineSeparator?: Overlay_LineStyle;
  /**
   * The style of the separator between items
   */
  itemSeparator?: Overlay_LineStyle;
  /**
   * Style of content-distribution space on the main axis (justify-content).
   */
  mainDistributedSpace?: Overlay_BoxStyle;
  /**
   * Style of content-distribution space on the cross axis (align-content).
   */
  crossDistributedSpace?: Overlay_BoxStyle;
  /**
   * Style of empty space caused by row gaps (gap/row-gap).
   */
  rowGapSpace?: Overlay_BoxStyle;
  /**
   * Style of empty space caused by columns gaps (gap/column-gap).
   */
  columnGapSpace?: Overlay_BoxStyle;
  /**
   * Style of the self-alignment line (align-items).
   */
  crossAlignment?: Overlay_LineStyle;
};

/**
 * Configuration data for the highlighting of Flex item elements.
 */
export type Overlay_FlexItemHighlightConfig = {
  /**
   * Style of the box representing the item's base size
   */
  baseSizeBox?: Overlay_BoxStyle;
  /**
   * Style of the border around the box representing the item's base size
   */
  baseSizeBorder?: Overlay_LineStyle;
  /**
   * Style of the arrow representing if the item grew or shrank
   */
  flexibilityArrow?: Overlay_LineStyle;
};

/**
 * Style information for drawing a line.
 */
export type Overlay_LineStyle = {
  /**
   * The color of the line (default: transparent)
   */
  color?: DOM_RGBA;
  /**
   * The line pattern (default: solid)
   */
  pattern?: "dashed" | "dotted";
};

/**
 * Style information for drawing a box.
 */
export type Overlay_BoxStyle = {
  /**
   * The background color for the box (default: transparent)
   */
  fillColor?: DOM_RGBA;
  /**
   * The hatching color for the box (default: transparent)
   */
  hatchColor?: DOM_RGBA;
};

export type Overlay_ContrastAlgorithm = "aa" | "aaa" | "apca";

/**
 * Configuration data for the highlighting of page elements.
 */
export type Overlay_HighlightConfig = {
  /**
   * Whether the node info tooltip should be shown (default: false).
   */
  showInfo?: boolean;
  /**
   * Whether the node styles in the tooltip (default: false).
   */
  showStyles?: boolean;
  /**
   * Whether the rulers should be shown (default: false).
   */
  showRulers?: boolean;
  /**
   * Whether the a11y info should be shown (default: true).
   */
  showAccessibilityInfo?: boolean;
  /**
   * Whether the extension lines from node to the rulers should be shown (default: false).
   */
  showExtensionLines?: boolean;
  /**
   * The content box highlight fill color (default: transparent).
   */
  contentColor?: DOM_RGBA;
  /**
   * The padding highlight fill color (default: transparent).
   */
  paddingColor?: DOM_RGBA;
  /**
   * The border highlight fill color (default: transparent).
   */
  borderColor?: DOM_RGBA;
  /**
   * The margin highlight fill color (default: transparent).
   */
  marginColor?: DOM_RGBA;
  /**
   * The event target element highlight fill color (default: transparent).
   */
  eventTargetColor?: DOM_RGBA;
  /**
   * The shape outside fill color (default: transparent).
   */
  shapeColor?: DOM_RGBA;
  /**
   * The shape margin fill color (default: transparent).
   */
  shapeMarginColor?: DOM_RGBA;
  /**
   * The grid layout color (default: transparent).
   */
  cssGridColor?: DOM_RGBA;
  /**
   * The color format used to format color styles (default: hex).
   */
  colorFormat?: Overlay_ColorFormat;
  /**
   * The grid layout highlight configuration (default: all transparent).
   */
  gridHighlightConfig?: Overlay_GridHighlightConfig;
  /**
   * The flex container highlight configuration (default: all transparent).
   */
  flexContainerHighlightConfig?: Overlay_FlexContainerHighlightConfig;
  /**
   * The flex item highlight configuration (default: all transparent).
   */
  flexItemHighlightConfig?: Overlay_FlexItemHighlightConfig;
  /**
   * The contrast algorithm to use for the contrast ratio (default: aa).
   */
  contrastAlgorithm?: Overlay_ContrastAlgorithm;
  /**
   * The container query container highlight configuration (default: all transparent).
   */
  containerQueryContainerHighlightConfig?:
    Overlay_ContainerQueryContainerHighlightConfig;
};

export type Overlay_ColorFormat = "rgb" | "hsl" | "hwb" | "hex";

/**
 * Configurations for Persistent Grid Highlight
 */
export type Overlay_GridNodeHighlightConfig = {
  /**
   * A descriptor for the highlight appearance.
   */
  gridHighlightConfig: Overlay_GridHighlightConfig;
  /**
   * Identifier of the node to highlight.
   */
  nodeId: DOM_NodeId;
};

export type Overlay_FlexNodeHighlightConfig = {
  /**
   * A descriptor for the highlight appearance of flex containers.
   */
  flexContainerHighlightConfig: Overlay_FlexContainerHighlightConfig;
  /**
   * Identifier of the node to highlight.
   */
  nodeId: DOM_NodeId;
};

export type Overlay_ScrollSnapContainerHighlightConfig = {
  /**
   * The style of the snapport border (default: transparent)
   */
  snapportBorder?: Overlay_LineStyle;
  /**
   * The style of the snap area border (default: transparent)
   */
  snapAreaBorder?: Overlay_LineStyle;
  /**
   * The margin highlight fill color (default: transparent).
   */
  scrollMarginColor?: DOM_RGBA;
  /**
   * The padding highlight fill color (default: transparent).
   */
  scrollPaddingColor?: DOM_RGBA;
};

export type Overlay_ScrollSnapHighlightConfig = {
  /**
   * A descriptor for the highlight appearance of scroll snap containers.
   */
  scrollSnapContainerHighlightConfig:
    Overlay_ScrollSnapContainerHighlightConfig;
  /**
   * Identifier of the node to highlight.
   */
  nodeId: DOM_NodeId;
};

/**
 * Configuration for dual screen hinge
 */
export type Overlay_HingeConfig = {
  /**
   * A rectangle represent hinge
   */
  rect: DOM_Rect;
  /**
   * The content box highlight fill color (default: a dark color).
   */
  contentColor?: DOM_RGBA;
  /**
   * The content box highlight outline color (default: transparent).
   */
  outlineColor?: DOM_RGBA;
};

/**
 * Configuration for Window Controls Overlay
 */
export type Overlay_WindowControlsOverlayConfig = {
  /**
   * Whether the title bar CSS should be shown when emulating the Window Controls Overlay.
   */
  showCSS: boolean;
  /**
   * Selected platforms to show the overlay.
   */
  selectedPlatform: string;
  /**
   * The theme color defined in app manifest.
   */
  themeColor: string;
};

export type Overlay_ContainerQueryHighlightConfig = {
  /**
   * A descriptor for the highlight appearance of container query containers.
   */
  containerQueryContainerHighlightConfig:
    Overlay_ContainerQueryContainerHighlightConfig;
  /**
   * Identifier of the container node to highlight.
   */
  nodeId: DOM_NodeId;
};

export type Overlay_ContainerQueryContainerHighlightConfig = {
  /**
   * The style of the container border.
   */
  containerBorder?: Overlay_LineStyle;
  /**
   * The style of the descendants' borders.
   */
  descendantBorder?: Overlay_LineStyle;
};

export type Overlay_IsolatedElementHighlightConfig = {
  /**
   * A descriptor for the highlight appearance of an element in isolation mode.
   */
  isolationModeHighlightConfig: Overlay_IsolationModeHighlightConfig;
  /**
   * Identifier of the isolated element to highlight.
   */
  nodeId: DOM_NodeId;
};

export type Overlay_IsolationModeHighlightConfig = {
  /**
   * The fill color of the resizers (default: transparent).
   */
  resizerColor?: DOM_RGBA;
  /**
   * The fill color for resizer handles (default: transparent).
   */
  resizerHandleColor?: DOM_RGBA;
  /**
   * The fill color for the mask covering non-isolated elements (default: transparent).
   */
  maskColor?: DOM_RGBA;
};

export type Overlay_InspectMode =
  | "searchForNode"
  | "searchForUAShadowDOM"
  | "captureAreaScreenshot"
  | "showDistances"
  | "none";

// ----------------- Page Types -----------------

/**
 * Unique frame identifier.
 */
export type Page_FrameId = string;

/**
 * @experimental
 * Indicates whether a frame has been identified as an ad.
 */
export type Page_AdFrameType = "none" | "child" | "root";

/**
 * @experimental
 */
export type Page_AdFrameExplanation =
  | "ParentIsAd"
  | "CreatedByAdScript"
  | "MatchedBlockingRule";

/**
 * @experimental
 * Indicates whether a frame has been identified as an ad and why.
 */
export type Page_AdFrameStatus = {
  adFrameType: Page_AdFrameType;
  explanations?: Page_AdFrameExplanation[];
};

/**
 * @experimental
 * Identifies the bottom-most script which caused the frame to be labelled
 * as an ad.
 */
export type Page_AdScriptId = {
  /**
   * Script Id of the bottom-most script which caused the frame to be labelled
   * as an ad.
   */
  scriptId: Runtime_ScriptId;
  /**
   * Id of adScriptId's debugger.
   */
  debuggerId: Runtime_UniqueDebuggerId;
};

/**
 * @experimental
 * Indicates whether the frame is a secure context and why it is the case.
 */
export type Page_SecureContextType =
  | "Secure"
  | "SecureLocalhost"
  | "InsecureScheme"
  | "InsecureAncestor";

/**
 * @experimental
 * Indicates whether the frame is cross-origin isolated and why it is the case.
 */
export type Page_CrossOriginIsolatedContextType =
  | "Isolated"
  | "NotIsolated"
  | "NotIsolatedFeatureDisabled";

/**
 * @experimental
 */
export type Page_GatedAPIFeatures =
  | "SharedArrayBuffers"
  | "SharedArrayBuffersTransferAllowed"
  | "PerformanceMeasureMemory"
  | "PerformanceProfile";

/**
 * @experimental
 * All Permissions Policy features. This enum should match the one defined
 * in third_party/blink/renderer/core/permissions_policy/permissions_policy_features.json5.
 */
export type Page_PermissionsPolicyFeature =
  | "accelerometer"
  | "ambient-light-sensor"
  | "attribution-reporting"
  | "autoplay"
  | "bluetooth"
  | "browsing-topics"
  | "camera"
  | "captured-surface-control"
  | "ch-dpr"
  | "ch-device-memory"
  | "ch-downlink"
  | "ch-ect"
  | "ch-prefers-color-scheme"
  | "ch-prefers-reduced-motion"
  | "ch-prefers-reduced-transparency"
  | "ch-rtt"
  | "ch-save-data"
  | "ch-ua"
  | "ch-ua-arch"
  | "ch-ua-bitness"
  | "ch-ua-platform"
  | "ch-ua-model"
  | "ch-ua-mobile"
  | "ch-ua-form-factors"
  | "ch-ua-full-version"
  | "ch-ua-full-version-list"
  | "ch-ua-platform-version"
  | "ch-ua-wow64"
  | "ch-viewport-height"
  | "ch-viewport-width"
  | "ch-width"
  | "clipboard-read"
  | "clipboard-write"
  | "compute-pressure"
  | "cross-origin-isolated"
  | "direct-sockets"
  | "display-capture"
  | "document-domain"
  | "encrypted-media"
  | "execution-while-out-of-viewport"
  | "execution-while-not-rendered"
  | "focus-without-user-activation"
  | "fullscreen"
  | "frobulate"
  | "gamepad"
  | "geolocation"
  | "gyroscope"
  | "hid"
  | "identity-credentials-get"
  | "idle-detection"
  | "interest-cohort"
  | "join-ad-interest-group"
  | "keyboard-map"
  | "local-fonts"
  | "magnetometer"
  | "microphone"
  | "midi"
  | "otp-credentials"
  | "payment"
  | "picture-in-picture"
  | "private-aggregation"
  | "private-state-token-issuance"
  | "private-state-token-redemption"
  | "publickey-credentials-create"
  | "publickey-credentials-get"
  | "run-ad-auction"
  | "screen-wake-lock"
  | "serial"
  | "shared-autofill"
  | "shared-storage"
  | "shared-storage-select-url"
  | "smart-card"
  | "speaker-selection"
  | "storage-access"
  | "sub-apps"
  | "sync-xhr"
  | "unload"
  | "usb"
  | "usb-unrestricted"
  | "vertical-scroll"
  | "web-printing"
  | "web-share"
  | "window-management"
  | "window-placement"
  | "xr-spatial-tracking";

/**
 * @experimental
 * Reason for a permissions policy feature to be disabled.
 */
export type Page_PermissionsPolicyBlockReason =
  | "Header"
  | "IframeAttribute"
  | "InFencedFrameTree"
  | "InIsolatedApp";

/**
 * @experimental
 */
export type Page_PermissionsPolicyBlockLocator = {
  frameId: Page_FrameId;
  blockReason: Page_PermissionsPolicyBlockReason;
};

/**
 * @experimental
 */
export type Page_PermissionsPolicyFeatureState = {
  feature: Page_PermissionsPolicyFeature;
  allowed: boolean;
  locator?: Page_PermissionsPolicyBlockLocator;
};

/**
 * @experimental
 * Origin Trial(https://www.chromium.org/blink/origin-trials) support.
 * Status for an Origin Trial token.
 */
export type Page_OriginTrialTokenStatus =
  | "Success"
  | "NotSupported"
  | "Insecure"
  | "Expired"
  | "WrongOrigin"
  | "InvalidSignature"
  | "Malformed"
  | "WrongVersion"
  | "FeatureDisabled"
  | "TokenDisabled"
  | "FeatureDisabledForUser"
  | "UnknownTrial";

/**
 * @experimental
 * Status for an Origin Trial.
 */
export type Page_OriginTrialStatus =
  | "Enabled"
  | "ValidTokenNotProvided"
  | "OSNotSupported"
  | "TrialNotAllowed";

/**
 * @experimental
 */
export type Page_OriginTrialUsageRestriction = "None" | "Subset";

/**
 * @experimental
 */
export type Page_OriginTrialToken = {
  origin: string;
  matchSubDomains: boolean;
  trialName: string;
  expiryTime: Network_TimeSinceEpoch;
  isThirdParty: boolean;
  usageRestriction: Page_OriginTrialUsageRestriction;
};

/**
 * @experimental
 */
export type Page_OriginTrialTokenWithStatus = {
  rawTokenText: string;
  /**
   * `parsedToken` is present only when the token is extractable and
   * parsable.
   */
  parsedToken?: Page_OriginTrialToken;
  status: Page_OriginTrialTokenStatus;
};

/**
 * @experimental
 */
export type Page_OriginTrial = {
  trialName: string;
  status: Page_OriginTrialStatus;
  tokensWithStatus: Page_OriginTrialTokenWithStatus[];
};

/**
 * Information about the Frame on the page.
 */
export type Page_Frame = {
  /**
   * Frame unique identifier.
   */
  id: Page_FrameId;
  /**
   * Parent frame identifier.
   */
  parentId?: Page_FrameId;
  /**
   * Identifier of the loader associated with this frame.
   */
  loaderId: Network_LoaderId;
  /**
   * Frame's name as specified in the tag.
   */
  name?: string;
  /**
   * Frame document's URL without fragment.
   */
  url: string;
  /**
   * @experimental
   * Frame document's URL fragment including the '#'.
   */
  urlFragment?: string;
  /**
   * @experimental
   * Frame document's registered domain, taking the public suffixes list into account.
   * Extracted from the Frame's url.
   * Example URLs: http://www.google.com/file.html -> "google.com"
   *               http://a.b.co.uk/file.html      -> "b.co.uk"
   */
  domainAndRegistry: string;
  /**
   * Frame document's security origin.
   */
  securityOrigin: string;
  /**
   * Frame document's mimeType as determined by the browser.
   */
  mimeType: string;
  /**
   * @experimental
   * If the frame failed to load, this contains the URL that could not be loaded. Note that unlike url above, this URL may contain a fragment.
   */
  unreachableUrl?: string;
  /**
   * @experimental
   * Indicates whether this frame was tagged as an ad and why.
   */
  adFrameStatus?: Page_AdFrameStatus;
  /**
   * @experimental
   * Indicates whether the main document is a secure context and explains why that is the case.
   */
  secureContextType: Page_SecureContextType;
  /**
   * @experimental
   * Indicates whether this is a cross origin isolated context.
   */
  crossOriginIsolatedContextType: Page_CrossOriginIsolatedContextType;
  /**
   * @experimental
   * Indicated which gated APIs / features are available.
   */
  gatedAPIFeatures: Page_GatedAPIFeatures[];
};

/**
 * @experimental
 * Information about the Resource on the page.
 */
export type Page_FrameResource = {
  /**
   * Resource URL.
   */
  url: string;
  /**
   * Type of this resource.
   */
  type: Network_ResourceType;
  /**
   * Resource mimeType as determined by the browser.
   */
  mimeType: string;
  /**
   * last-modified timestamp as reported by server.
   */
  lastModified?: Network_TimeSinceEpoch;
  /**
   * Resource content size.
   */
  contentSize?: number;
  /**
   * True if the resource failed to load.
   */
  failed?: boolean;
  /**
   * True if the resource was canceled during loading.
   */
  canceled?: boolean;
};

/**
 * @experimental
 * Information about the Frame hierarchy along with their cached resources.
 */
export type Page_FrameResourceTree = {
  /**
   * Frame information for this tree item.
   */
  frame: Page_Frame;
  /**
   * Child frames.
   */
  childFrames?: Page_FrameResourceTree[];
  /**
   * Information about frame resources.
   */
  resources: Page_FrameResource[];
};

/**
 * Information about the Frame hierarchy.
 */
export type Page_FrameTree = {
  /**
   * Frame information for this tree item.
   */
  frame: Page_Frame;
  /**
   * Child frames.
   */
  childFrames?: Page_FrameTree[];
};

/**
 * Unique script identifier.
 */
export type Page_ScriptIdentifier = string;

/**
 * Transition type.
 */
export type Page_TransitionType =
  | "link"
  | "typed"
  | "address_bar"
  | "auto_bookmark"
  | "auto_subframe"
  | "manual_subframe"
  | "generated"
  | "auto_toplevel"
  | "form_submit"
  | "reload"
  | "keyword"
  | "keyword_generated"
  | "other";

/**
 * Navigation history entry.
 */
export type Page_NavigationEntry = {
  /**
   * Unique id of the navigation history entry.
   */
  id: number;
  /**
   * URL of the navigation history entry.
   */
  url: string;
  /**
   * URL that the user typed in the url bar.
   */
  userTypedURL: string;
  /**
   * Title of the navigation history entry.
   */
  title: string;
  /**
   * Transition type.
   */
  transitionType: Page_TransitionType;
};

/**
 * @experimental
 * Screencast frame metadata.
 */
export type Page_ScreencastFrameMetadata = {
  /**
   * Top offset in DIP.
   */
  offsetTop: number;
  /**
   * Page scale factor.
   */
  pageScaleFactor: number;
  /**
   * Device screen width in DIP.
   */
  deviceWidth: number;
  /**
   * Device screen height in DIP.
   */
  deviceHeight: number;
  /**
   * Position of horizontal scroll in CSS pixels.
   */
  scrollOffsetX: number;
  /**
   * Position of vertical scroll in CSS pixels.
   */
  scrollOffsetY: number;
  /**
   * Frame swap timestamp.
   */
  timestamp?: Network_TimeSinceEpoch;
};

/**
 * Javascript dialog type.
 */
export type Page_DialogType = "alert" | "confirm" | "prompt" | "beforeunload";

/**
 * Error while paring app manifest.
 */
export type Page_AppManifestError = {
  /**
   * Error message.
   */
  message: string;
  /**
   * If critical, this is a non-recoverable parse error.
   */
  critical: number;
  /**
   * Error line.
   */
  line: number;
  /**
   * Error column.
   */
  column: number;
};

/**
 * @experimental
 * Parsed app manifest properties.
 */
export type Page_AppManifestParsedProperties = {
  /**
   * Computed scope value
   */
  scope: string;
};

/**
 * Layout viewport position and dimensions.
 */
export type Page_LayoutViewport = {
  /**
   * Horizontal offset relative to the document (CSS pixels).
   */
  pageX: number;
  /**
   * Vertical offset relative to the document (CSS pixels).
   */
  pageY: number;
  /**
   * Width (CSS pixels), excludes scrollbar if present.
   */
  clientWidth: number;
  /**
   * Height (CSS pixels), excludes scrollbar if present.
   */
  clientHeight: number;
};

/**
 * Visual viewport position, dimensions, and scale.
 */
export type Page_VisualViewport = {
  /**
   * Horizontal offset relative to the layout viewport (CSS pixels).
   */
  offsetX: number;
  /**
   * Vertical offset relative to the layout viewport (CSS pixels).
   */
  offsetY: number;
  /**
   * Horizontal offset relative to the document (CSS pixels).
   */
  pageX: number;
  /**
   * Vertical offset relative to the document (CSS pixels).
   */
  pageY: number;
  /**
   * Width (CSS pixels), excludes scrollbar if present.
   */
  clientWidth: number;
  /**
   * Height (CSS pixels), excludes scrollbar if present.
   */
  clientHeight: number;
  /**
   * Scale relative to the ideal viewport (size at width=device-width).
   */
  scale: number;
  /**
   * Page zoom factor (CSS to device independent pixels ratio).
   */
  zoom?: number;
};

/**
 * Viewport for capturing screenshot.
 */
export type Page_Viewport = {
  /**
   * X offset in device independent pixels (dip).
   */
  x: number;
  /**
   * Y offset in device independent pixels (dip).
   */
  y: number;
  /**
   * Rectangle width in device independent pixels (dip).
   */
  width: number;
  /**
   * Rectangle height in device independent pixels (dip).
   */
  height: number;
  /**
   * Page scale factor.
   */
  scale: number;
};

/**
 * @experimental
 * Generic font families collection.
 */
export type Page_FontFamilies = {
  /**
   * The standard font-family.
   */
  standard?: string;
  /**
   * The fixed font-family.
   */
  fixed?: string;
  /**
   * The serif font-family.
   */
  serif?: string;
  /**
   * The sansSerif font-family.
   */
  sansSerif?: string;
  /**
   * The cursive font-family.
   */
  cursive?: string;
  /**
   * The fantasy font-family.
   */
  fantasy?: string;
  /**
   * The math font-family.
   */
  math?: string;
};

/**
 * @experimental
 * Font families collection for a script.
 */
export type Page_ScriptFontFamilies = {
  /**
   * Name of the script which these font families are defined for.
   */
  script: string;
  /**
   * Generic font families collection for the script.
   */
  fontFamilies: Page_FontFamilies;
};

/**
 * @experimental
 * Default font sizes.
 */
export type Page_FontSizes = {
  /**
   * Default standard font size.
   */
  standard?: number;
  /**
   * Default fixed font size.
   */
  fixed?: number;
};

/**
 * @experimental
 */
export type Page_ClientNavigationReason =
  | "formSubmissionGet"
  | "formSubmissionPost"
  | "httpHeaderRefresh"
  | "scriptInitiated"
  | "metaTagRefresh"
  | "pageBlockInterstitial"
  | "reload"
  | "anchorClick";

/**
 * @experimental
 */
export type Page_ClientNavigationDisposition =
  | "currentTab"
  | "newTab"
  | "newWindow"
  | "download";

/**
 * @experimental
 */
export type Page_InstallabilityErrorArgument = {
  /**
   * Argument name (e.g. name:'minimum-icon-size-in-pixels').
   */
  name: string;
  /**
   * Argument value (e.g. value:'64').
   */
  value: string;
};

/**
 * @experimental
 * The installability error
 */
export type Page_InstallabilityError = {
  /**
   * The error id (e.g. 'manifest-missing-suitable-icon').
   */
  errorId: string;
  /**
   * The list of error arguments (e.g. {name:'minimum-icon-size-in-pixels', value:'64'}).
   */
  errorArguments: Page_InstallabilityErrorArgument[];
};

/**
 * @experimental
 * The referring-policy used for the navigation.
 */
export type Page_ReferrerPolicy =
  | "noReferrer"
  | "noReferrerWhenDowngrade"
  | "origin"
  | "originWhenCrossOrigin"
  | "sameOrigin"
  | "strictOrigin"
  | "strictOriginWhenCrossOrigin"
  | "unsafeUrl";

/**
 * @experimental
 * Per-script compilation cache parameters for `Page.produceCompilationCache`
 */
export type Page_CompilationCacheParams = {
  /**
   * The URL of the script to produce a compilation cache entry for.
   */
  url: string;
  /**
   * A hint to the backend whether eager compilation is recommended.
   * (the actual compilation mode used is upon backend discretion).
   */
  eager?: boolean;
};

/**
 * @experimental
 * Enum of possible auto-response for permission / prompt dialogs.
 */
export type Page_AutoResponseMode =
  | "none"
  | "autoAccept"
  | "autoReject"
  | "autoOptOut";

/**
 * @experimental
 * The type of a frameNavigated event.
 */
export type Page_NavigationType = "Navigation" | "BackForwardCacheRestore";

/**
 * @experimental
 * List of not restored reasons for back-forward cache.
 */
export type Page_BackForwardCacheNotRestoredReason =
  | "NotPrimaryMainFrame"
  | "BackForwardCacheDisabled"
  | "RelatedActiveContentsExist"
  | "HTTPStatusNotOK"
  | "SchemeNotHTTPOrHTTPS"
  | "Loading"
  | "WasGrantedMediaAccess"
  | "DisableForRenderFrameHostCalled"
  | "DomainNotAllowed"
  | "HTTPMethodNotGET"
  | "SubframeIsNavigating"
  | "Timeout"
  | "CacheLimit"
  | "JavaScriptExecution"
  | "RendererProcessKilled"
  | "RendererProcessCrashed"
  | "SchedulerTrackedFeatureUsed"
  | "ConflictingBrowsingInstance"
  | "CacheFlushed"
  | "ServiceWorkerVersionActivation"
  | "SessionRestored"
  | "ServiceWorkerPostMessage"
  | "EnteredBackForwardCacheBeforeServiceWorkerHostAdded"
  | "RenderFrameHostReused_SameSite"
  | "RenderFrameHostReused_CrossSite"
  | "ServiceWorkerClaim"
  | "IgnoreEventAndEvict"
  | "HaveInnerContents"
  | "TimeoutPuttingInCache"
  | "BackForwardCacheDisabledByLowMemory"
  | "BackForwardCacheDisabledByCommandLine"
  | "NetworkRequestDatapipeDrainedAsBytesConsumer"
  | "NetworkRequestRedirected"
  | "NetworkRequestTimeout"
  | "NetworkExceedsBufferLimit"
  | "NavigationCancelledWhileRestoring"
  | "NotMostRecentNavigationEntry"
  | "BackForwardCacheDisabledForPrerender"
  | "UserAgentOverrideDiffers"
  | "ForegroundCacheLimit"
  | "BrowsingInstanceNotSwapped"
  | "BackForwardCacheDisabledForDelegate"
  | "UnloadHandlerExistsInMainFrame"
  | "UnloadHandlerExistsInSubFrame"
  | "ServiceWorkerUnregistration"
  | "CacheControlNoStore"
  | "CacheControlNoStoreCookieModified"
  | "CacheControlNoStoreHTTPOnlyCookieModified"
  | "NoResponseHead"
  | "Unknown"
  | "ActivationNavigationsDisallowedForBug1234857"
  | "ErrorDocument"
  | "FencedFramesEmbedder"
  | "CookieDisabled"
  | "HTTPAuthRequired"
  | "CookieFlushed"
  | "BroadcastChannelOnMessage"
  | "WebSocket"
  | "WebTransport"
  | "WebRTC"
  | "MainResourceHasCacheControlNoStore"
  | "MainResourceHasCacheControlNoCache"
  | "SubresourceHasCacheControlNoStore"
  | "SubresourceHasCacheControlNoCache"
  | "ContainsPlugins"
  | "DocumentLoaded"
  | "OutstandingNetworkRequestOthers"
  | "RequestedMIDIPermission"
  | "RequestedAudioCapturePermission"
  | "RequestedVideoCapturePermission"
  | "RequestedBackForwardCacheBlockedSensors"
  | "RequestedBackgroundWorkPermission"
  | "BroadcastChannel"
  | "WebXR"
  | "SharedWorker"
  | "WebLocks"
  | "WebHID"
  | "WebShare"
  | "RequestedStorageAccessGrant"
  | "WebNfc"
  | "OutstandingNetworkRequestFetch"
  | "OutstandingNetworkRequestXHR"
  | "AppBanner"
  | "Printing"
  | "WebDatabase"
  | "PictureInPicture"
  | "Portal"
  | "SpeechRecognizer"
  | "IdleManager"
  | "PaymentManager"
  | "SpeechSynthesis"
  | "KeyboardLock"
  | "WebOTPService"
  | "OutstandingNetworkRequestDirectSocket"
  | "InjectedJavascript"
  | "InjectedStyleSheet"
  | "KeepaliveRequest"
  | "IndexedDBEvent"
  | "Dummy"
  | "JsNetworkRequestReceivedCacheControlNoStoreResource"
  | "WebRTCSticky"
  | "WebTransportSticky"
  | "WebSocketSticky"
  | "SmartCard"
  | "LiveMediaStreamTrack"
  | "UnloadHandler"
  | "ParserAborted"
  | "ContentSecurityHandler"
  | "ContentWebAuthenticationAPI"
  | "ContentFileChooser"
  | "ContentSerial"
  | "ContentFileSystemAccess"
  | "ContentMediaDevicesDispatcherHost"
  | "ContentWebBluetooth"
  | "ContentWebUSB"
  | "ContentMediaSessionService"
  | "ContentScreenReader"
  | "EmbedderPopupBlockerTabHelper"
  | "EmbedderSafeBrowsingTriggeredPopupBlocker"
  | "EmbedderSafeBrowsingThreatDetails"
  | "EmbedderAppBannerManager"
  | "EmbedderDomDistillerViewerSource"
  | "EmbedderDomDistillerSelfDeletingRequestDelegate"
  | "EmbedderOomInterventionTabHelper"
  | "EmbedderOfflinePage"
  | "EmbedderChromePasswordManagerClientBindCredentialManager"
  | "EmbedderPermissionRequestManager"
  | "EmbedderModalDialog"
  | "EmbedderExtensions"
  | "EmbedderExtensionMessaging"
  | "EmbedderExtensionMessagingForOpenPort"
  | "EmbedderExtensionSentMessageToCachedFrame";

/**
 * @experimental
 * Types of not restored reasons for back-forward cache.
 */
export type Page_BackForwardCacheNotRestoredReasonType =
  | "SupportPending"
  | "PageSupportNeeded"
  | "Circumstantial";

/**
 * @experimental
 */
export type Page_BackForwardCacheBlockingDetails = {
  /**
   * Url of the file where blockage happened. Optional because of tests.
   */
  url?: string;
  /**
   * Function name where blockage happened. Optional because of anonymous functions and tests.
   */
  function?: string;
  /**
   * Line number in the script (0-based).
   */
  lineNumber: number;
  /**
   * Column number in the script (0-based).
   */
  columnNumber: number;
};

/**
 * @experimental
 */
export type Page_BackForwardCacheNotRestoredExplanation = {
  /**
   * Type of the reason
   */
  type: Page_BackForwardCacheNotRestoredReasonType;
  /**
   * Not restored reason
   */
  reason: Page_BackForwardCacheNotRestoredReason;
  /**
   * Context associated with the reason. The meaning of this context is
   * dependent on the reason:
   * - EmbedderExtensionSentMessageToCachedFrame: the extension ID.
   */
  context?: string;
  details?: Page_BackForwardCacheBlockingDetails[];
};

/**
 * @experimental
 */
export type Page_BackForwardCacheNotRestoredExplanationTree = {
  /**
   * URL of each frame
   */
  url: string;
  /**
   * Not restored reasons of each frame
   */
  explanations: Page_BackForwardCacheNotRestoredExplanation[];
  /**
   * Array of children frame
   */
  children: Page_BackForwardCacheNotRestoredExplanationTree[];
};

// ----------------- Performance Types -----------------

/**
 * Run-time execution metric.
 */
export type Performance_Metric = {
  /**
   * Metric name.
   */
  name: string;
  /**
   * Metric value.
   */
  value: number;
};

// ----------------- PerformanceTimeline Types -----------------

/**
 * See https://github.com/WICG/LargestContentfulPaint and largest_contentful_paint.idl
 */
export type PerformanceTimeline_LargestContentfulPaint = {
  renderTime: Network_TimeSinceEpoch;
  loadTime: Network_TimeSinceEpoch;
  /**
   * The number of pixels being painted.
   */
  size: number;
  /**
   * The id attribute of the element, if available.
   */
  elementId?: string;
  /**
   * The URL of the image (may be trimmed).
   */
  url?: string;
  nodeId?: DOM_BackendNodeId;
};

export type PerformanceTimeline_LayoutShiftAttribution = {
  previousRect: DOM_Rect;
  currentRect: DOM_Rect;
  nodeId?: DOM_BackendNodeId;
};

/**
 * See https://wicg.github.io/layout-instability/#sec-layout-shift and layout_shift.idl
 */
export type PerformanceTimeline_LayoutShift = {
  /**
   * Score increment produced by this event.
   */
  value: number;
  hadRecentInput: boolean;
  lastInputTime: Network_TimeSinceEpoch;
  sources: PerformanceTimeline_LayoutShiftAttribution[];
};

export type PerformanceTimeline_TimelineEvent = {
  /**
   * Identifies the frame that this event is related to. Empty for non-frame targets.
   */
  frameId: Page_FrameId;
  /**
   * The event type, as specified in https://w3c.github.io/performance-timeline/#dom-performanceentry-entrytype
   * This determines which of the optional "details" fields is present.
   */
  type: string;
  /**
   * Name may be empty depending on the type.
   */
  name: string;
  /**
   * Time in seconds since Epoch, monotonically increasing within document lifetime.
   */
  time: Network_TimeSinceEpoch;
  /**
   * Event duration, if applicable.
   */
  duration?: number;
  lcpDetails?: PerformanceTimeline_LargestContentfulPaint;
  layoutShiftDetails?: PerformanceTimeline_LayoutShift;
};

// ----------------- Security Types -----------------

/**
 * An internal certificate ID value.
 */
export type Security_CertificateId = number;

/**
 * A description of mixed content (HTTP resources on HTTPS pages), as defined by
 * https://www.w3.org/TR/mixed-content/#categories
 */
export type Security_MixedContentType =
  | "blockable"
  | "optionally-blockable"
  | "none";

/**
 * The security level of a page or resource.
 */
export type Security_SecurityState =
  | "unknown"
  | "neutral"
  | "insecure"
  | "secure"
  | "info"
  | "insecure-broken";

/**
 * @experimental
 * Details about the security state of the page certificate.
 */
export type Security_CertificateSecurityState = {
  /**
   * Protocol name (e.g. "TLS 1.2" or "QUIC").
   */
  protocol: string;
  /**
   * Key Exchange used by the connection, or the empty string if not applicable.
   */
  keyExchange: string;
  /**
   * (EC)DH group used by the connection, if applicable.
   */
  keyExchangeGroup?: string;
  /**
   * Cipher name.
   */
  cipher: string;
  /**
   * TLS MAC. Note that AEAD ciphers do not have separate MACs.
   */
  mac?: string;
  /**
   * Page certificate.
   */
  certificate: string[];
  /**
   * Certificate subject name.
   */
  subjectName: string;
  /**
   * Name of the issuing CA.
   */
  issuer: string;
  /**
   * Certificate valid from date.
   */
  validFrom: Network_TimeSinceEpoch;
  /**
   * Certificate valid to (expiration) date
   */
  validTo: Network_TimeSinceEpoch;
  /**
   * The highest priority network error code, if the certificate has an error.
   */
  certificateNetworkError?: string;
  /**
   * True if the certificate uses a weak signature algorithm.
   */
  certificateHasWeakSignature: boolean;
  /**
   * True if the certificate has a SHA1 signature in the chain.
   */
  certificateHasSha1Signature: boolean;
  /**
   * True if modern SSL
   */
  modernSSL: boolean;
  /**
   * True if the connection is using an obsolete SSL protocol.
   */
  obsoleteSslProtocol: boolean;
  /**
   * True if the connection is using an obsolete SSL key exchange.
   */
  obsoleteSslKeyExchange: boolean;
  /**
   * True if the connection is using an obsolete SSL cipher.
   */
  obsoleteSslCipher: boolean;
  /**
   * True if the connection is using an obsolete SSL signature.
   */
  obsoleteSslSignature: boolean;
};

/**
 * @experimental
 */
export type Security_SafetyTipStatus = "badReputation" | "lookalike";

/**
 * @experimental
 */
export type Security_SafetyTipInfo = {
  /**
   * Describes whether the page triggers any safety tips or reputation warnings. Default is unknown.
   */
  safetyTipStatus: Security_SafetyTipStatus;
  /**
   * The URL the safety tip suggested ("Did you mean?"). Only filled in for lookalike matches.
   */
  safeUrl?: string;
};

/**
 * @experimental
 * Security state information about the page.
 */
export type Security_VisibleSecurityState = {
  /**
   * The security level of the page.
   */
  securityState: Security_SecurityState;
  /**
   * Security state details about the page certificate.
   */
  certificateSecurityState?: Security_CertificateSecurityState;
  /**
   * The type of Safety Tip triggered on the page. Note that this field will be set even if the Safety Tip UI was not actually shown.
   */
  safetyTipInfo?: Security_SafetyTipInfo;
  /**
   * Array of security state issues ids.
   */
  securityStateIssueIds: string[];
};

/**
 * An explanation of an factor contributing to the security state.
 */
export type Security_SecurityStateExplanation = {
  /**
   * Security state representing the severity of the factor being explained.
   */
  securityState: Security_SecurityState;
  /**
   * Title describing the type of factor.
   */
  title: string;
  /**
   * Short phrase describing the type of factor.
   */
  summary: string;
  /**
   * Full text explanation of the factor.
   */
  description: string;
  /**
   * The type of mixed content described by the explanation.
   */
  mixedContentType: Security_MixedContentType;
  /**
   * Page certificate.
   */
  certificate: string[];
  /**
   * Recommendations to fix any issues.
   */
  recommendations?: string[];
};

/**
 * @deprecated
 * Information about insecure content on the page.
 */
export type Security_InsecureContentStatus = {
  /**
   * Always false.
   */
  ranMixedContent: boolean;
  /**
   * Always false.
   */
  displayedMixedContent: boolean;
  /**
   * Always false.
   */
  containedMixedForm: boolean;
  /**
   * Always false.
   */
  ranContentWithCertErrors: boolean;
  /**
   * Always false.
   */
  displayedContentWithCertErrors: boolean;
  /**
   * Always set to unknown.
   */
  ranInsecureContentStyle: Security_SecurityState;
  /**
   * Always set to unknown.
   */
  displayedInsecureContentStyle: Security_SecurityState;
};

/**
 * The action to take when a certificate error occurs. continue will continue processing the
 * request and cancel will cancel the request.
 */
export type Security_CertificateErrorAction = "continue" | "cancel";

// ----------------- ServiceWorker Types -----------------

export type ServiceWorker_RegistrationID = string;

/**
 * ServiceWorker registration.
 */
export type ServiceWorker_ServiceWorkerRegistration = {
  registrationId: ServiceWorker_RegistrationID;
  scopeURL: string;
  isDeleted: boolean;
};

export type ServiceWorker_ServiceWorkerVersionRunningStatus =
  | "stopped"
  | "starting"
  | "running"
  | "stopping";

export type ServiceWorker_ServiceWorkerVersionStatus =
  | "new"
  | "installing"
  | "installed"
  | "activating"
  | "activated"
  | "redundant";

/**
 * ServiceWorker version.
 */
export type ServiceWorker_ServiceWorkerVersion = {
  versionId: string;
  registrationId: ServiceWorker_RegistrationID;
  scriptURL: string;
  runningStatus: ServiceWorker_ServiceWorkerVersionRunningStatus;
  status: ServiceWorker_ServiceWorkerVersionStatus;
  /**
   * The Last-Modified header value of the main script.
   */
  scriptLastModified?: number;
  /**
   * The time at which the response headers of the main script were received from the server.
   * For cached script it is the last time the cache entry was validated.
   */
  scriptResponseTime?: number;
  controlledClients?: Target_TargetID[];
  targetId?: Target_TargetID;
  routerRules?: string;
};

/**
 * ServiceWorker error message.
 */
export type ServiceWorker_ServiceWorkerErrorMessage = {
  errorMessage: string;
  registrationId: ServiceWorker_RegistrationID;
  versionId: string;
  sourceURL: string;
  lineNumber: number;
  columnNumber: number;
};

// ----------------- Storage Types -----------------

export type Storage_SerializedStorageKey = string;

/**
 * Enum of possible storage types.
 */
export type Storage_StorageType =
  | "appcache"
  | "cookies"
  | "file_systems"
  | "indexeddb"
  | "local_storage"
  | "shader_cache"
  | "websql"
  | "service_workers"
  | "cache_storage"
  | "interest_groups"
  | "shared_storage"
  | "storage_buckets"
  | "all"
  | "other";

/**
 * Usage for a storage type.
 */
export type Storage_UsageForType = {
  /**
   * Name of storage type.
   */
  storageType: Storage_StorageType;
  /**
   * Storage usage (bytes).
   */
  usage: number;
};

/**
 * @experimental
 * Pair of issuer origin and number of available (signed, but not used) Trust
 * Tokens from that issuer.
 */
export type Storage_TrustTokens = {
  issuerOrigin: string;
  count: number;
};

/**
 * Protected audience interest group auction identifier.
 */
export type Storage_InterestGroupAuctionId = string;

/**
 * Enum of interest group access types.
 */
export type Storage_InterestGroupAccessType =
  | "join"
  | "leave"
  | "update"
  | "loaded"
  | "bid"
  | "win"
  | "additionalBid"
  | "additionalBidWin"
  | "topLevelBid"
  | "topLevelAdditionalBid"
  | "clear";

/**
 * Enum of auction events.
 */
export type Storage_InterestGroupAuctionEventType =
  | "started"
  | "configResolved";

/**
 * Enum of network fetches auctions can do.
 */
export type Storage_InterestGroupAuctionFetchType =
  | "bidderJs"
  | "bidderWasm"
  | "sellerJs"
  | "bidderTrustedSignals"
  | "sellerTrustedSignals";

/**
 * Enum of shared storage access types.
 */
export type Storage_SharedStorageAccessType =
  | "documentAddModule"
  | "documentSelectURL"
  | "documentRun"
  | "documentSet"
  | "documentAppend"
  | "documentDelete"
  | "documentClear"
  | "documentGet"
  | "workletSet"
  | "workletAppend"
  | "workletDelete"
  | "workletClear"
  | "workletGet"
  | "workletKeys"
  | "workletEntries"
  | "workletLength"
  | "workletRemainingBudget"
  | "headerSet"
  | "headerAppend"
  | "headerDelete"
  | "headerClear";

/**
 * Struct for a single key-value pair in an origin's shared storage.
 */
export type Storage_SharedStorageEntry = {
  key: string;
  value: string;
};

/**
 * Details for an origin's shared storage.
 */
export type Storage_SharedStorageMetadata = {
  /**
   * Time when the origin's shared storage was last created.
   */
  creationTime: Network_TimeSinceEpoch;
  /**
   * Number of key-value pairs stored in origin's shared storage.
   */
  length: number;
  /**
   * Current amount of bits of entropy remaining in the navigation budget.
   */
  remainingBudget: number;
  /**
   * Total number of bytes stored as key-value pairs in origin's shared
   * storage.
   */
  bytesUsed: number;
};

/**
 * Pair of reporting metadata details for a candidate URL for `selectURL()`.
 */
export type Storage_SharedStorageReportingMetadata = {
  eventType: string;
  reportingUrl: string;
};

/**
 * Bundles a candidate URL with its reporting metadata.
 */
export type Storage_SharedStorageUrlWithMetadata = {
  /**
   * Spec of candidate URL.
   */
  url: string;
  /**
   * Any associated reporting metadata.
   */
  reportingMetadata: Storage_SharedStorageReportingMetadata[];
};

/**
 * Bundles the parameters for shared storage access events whose
 * presence/absence can vary according to SharedStorageAccessType.
 */
export type Storage_SharedStorageAccessParams = {
  /**
   * Spec of the module script URL.
   * Present only for SharedStorageAccessType.documentAddModule.
   */
  scriptSourceUrl?: string;
  /**
   * Name of the registered operation to be run.
   * Present only for SharedStorageAccessType.documentRun and
   * SharedStorageAccessType.documentSelectURL.
   */
  operationName?: string;
  /**
   * The operation's serialized data in bytes (converted to a string).
   * Present only for SharedStorageAccessType.documentRun and
   * SharedStorageAccessType.documentSelectURL.
   */
  serializedData?: string;
  /**
   * Array of candidate URLs' specs, along with any associated metadata.
   * Present only for SharedStorageAccessType.documentSelectURL.
   */
  urlsWithMetadata?: Storage_SharedStorageUrlWithMetadata[];
  /**
   * Key for a specific entry in an origin's shared storage.
   * Present only for SharedStorageAccessType.documentSet,
   * SharedStorageAccessType.documentAppend,
   * SharedStorageAccessType.documentDelete,
   * SharedStorageAccessType.workletSet,
   * SharedStorageAccessType.workletAppend,
   * SharedStorageAccessType.workletDelete,
   * SharedStorageAccessType.workletGet,
   * SharedStorageAccessType.headerSet,
   * SharedStorageAccessType.headerAppend, and
   * SharedStorageAccessType.headerDelete.
   */
  key?: string;
  /**
   * Value for a specific entry in an origin's shared storage.
   * Present only for SharedStorageAccessType.documentSet,
   * SharedStorageAccessType.documentAppend,
   * SharedStorageAccessType.workletSet,
   * SharedStorageAccessType.workletAppend,
   * SharedStorageAccessType.headerSet, and
   * SharedStorageAccessType.headerAppend.
   */
  value?: string;
  /**
   * Whether or not to set an entry for a key if that key is already present.
   * Present only for SharedStorageAccessType.documentSet,
   * SharedStorageAccessType.workletSet, and
   * SharedStorageAccessType.headerSet.
   */
  ignoreIfPresent?: boolean;
};

export type Storage_StorageBucketsDurability = "relaxed" | "strict";

export type Storage_StorageBucket = {
  storageKey: Storage_SerializedStorageKey;
  /**
   * If not specified, it is the default bucket of the storageKey.
   */
  name?: string;
};

export type Storage_StorageBucketInfo = {
  bucket: Storage_StorageBucket;
  id: string;
  expiration: Network_TimeSinceEpoch;
  /**
   * Storage quota (bytes).
   */
  quota: number;
  persistent: boolean;
  durability: Storage_StorageBucketsDurability;
};

/**
 * @experimental
 */
export type Storage_AttributionReportingSourceType = "navigation" | "event";

/**
 * @experimental
 */
export type Storage_UnsignedInt64AsBase10 = string;

/**
 * @experimental
 */
export type Storage_UnsignedInt128AsBase16 = string;

/**
 * @experimental
 */
export type Storage_SignedInt64AsBase10 = string;

/**
 * @experimental
 */
export type Storage_AttributionReportingFilterDataEntry = {
  key: string;
  values: string[];
};

/**
 * @experimental
 */
export type Storage_AttributionReportingFilterConfig = {
  filterValues: Storage_AttributionReportingFilterDataEntry[];
  /**
   * duration in seconds
   */
  lookbackWindow?: number;
};

/**
 * @experimental
 */
export type Storage_AttributionReportingFilterPair = {
  filters: Storage_AttributionReportingFilterConfig[];
  notFilters: Storage_AttributionReportingFilterConfig[];
};

/**
 * @experimental
 */
export type Storage_AttributionReportingAggregationKeysEntry = {
  key: string;
  value: Storage_UnsignedInt128AsBase16;
};

/**
 * @experimental
 */
export type Storage_AttributionReportingEventReportWindows = {
  /**
   * duration in seconds
   */
  start: number;
  /**
   * duration in seconds
   */
  ends: number[];
};

/**
 * @experimental
 */
export type Storage_AttributionReportingTriggerSpec = {
  /**
   * number instead of integer because not all uint32 can be represented by
   * int
   */
  triggerData: number[];
  eventReportWindows: Storage_AttributionReportingEventReportWindows;
};

/**
 * @experimental
 */
export type Storage_AttributionReportingTriggerDataMatching =
  | "exact"
  | "modulus";

/**
 * @experimental
 */
export type Storage_AttributionReportingSourceRegistration = {
  time: Network_TimeSinceEpoch;
  /**
   * duration in seconds
   */
  expiry: number;
  triggerSpecs: Storage_AttributionReportingTriggerSpec[];
  /**
   * duration in seconds
   */
  aggregatableReportWindow: number;
  type: Storage_AttributionReportingSourceType;
  sourceOrigin: string;
  reportingOrigin: string;
  destinationSites: string[];
  eventId: Storage_UnsignedInt64AsBase10;
  priority: Storage_SignedInt64AsBase10;
  filterData: Storage_AttributionReportingFilterDataEntry[];
  aggregationKeys: Storage_AttributionReportingAggregationKeysEntry[];
  debugKey?: Storage_UnsignedInt64AsBase10;
  triggerDataMatching: Storage_AttributionReportingTriggerDataMatching;
};

/**
 * @experimental
 */
export type Storage_AttributionReportingSourceRegistrationResult =
  | "success"
  | "internalError"
  | "insufficientSourceCapacity"
  | "insufficientUniqueDestinationCapacity"
  | "excessiveReportingOrigins"
  | "prohibitedByBrowserPolicy"
  | "successNoised"
  | "destinationReportingLimitReached"
  | "destinationGlobalLimitReached"
  | "destinationBothLimitsReached"
  | "reportingOriginsPerSiteLimitReached"
  | "exceedsMaxChannelCapacity"
  | "exceedsMaxTriggerStateCardinality";

/**
 * @experimental
 */
export type Storage_AttributionReportingSourceRegistrationTimeConfig =
  | "include"
  | "exclude";

/**
 * @experimental
 */
export type Storage_AttributionReportingAggregatableValueDictEntry = {
  key: string;
  /**
   * number instead of integer because not all uint32 can be represented by
   * int
   */
  value: number;
};

/**
 * @experimental
 */
export type Storage_AttributionReportingAggregatableValueEntry = {
  values: Storage_AttributionReportingAggregatableValueDictEntry[];
  filters: Storage_AttributionReportingFilterPair;
};

/**
 * @experimental
 */
export type Storage_AttributionReportingEventTriggerData = {
  data: Storage_UnsignedInt64AsBase10;
  priority: Storage_SignedInt64AsBase10;
  dedupKey?: Storage_UnsignedInt64AsBase10;
  filters: Storage_AttributionReportingFilterPair;
};

/**
 * @experimental
 */
export type Storage_AttributionReportingAggregatableTriggerData = {
  keyPiece: Storage_UnsignedInt128AsBase16;
  sourceKeys: string[];
  filters: Storage_AttributionReportingFilterPair;
};

/**
 * @experimental
 */
export type Storage_AttributionReportingAggregatableDedupKey = {
  dedupKey?: Storage_UnsignedInt64AsBase10;
  filters: Storage_AttributionReportingFilterPair;
};

/**
 * @experimental
 */
export type Storage_AttributionReportingTriggerRegistration = {
  filters: Storage_AttributionReportingFilterPair;
  debugKey?: Storage_UnsignedInt64AsBase10;
  aggregatableDedupKeys: Storage_AttributionReportingAggregatableDedupKey[];
  eventTriggerData: Storage_AttributionReportingEventTriggerData[];
  aggregatableTriggerData:
    Storage_AttributionReportingAggregatableTriggerData[];
  aggregatableValues: Storage_AttributionReportingAggregatableValueEntry[];
  debugReporting: boolean;
  aggregationCoordinatorOrigin?: string;
  sourceRegistrationTimeConfig:
    Storage_AttributionReportingSourceRegistrationTimeConfig;
  triggerContextId?: string;
};

/**
 * @experimental
 */
export type Storage_AttributionReportingEventLevelResult =
  | "success"
  | "successDroppedLowerPriority"
  | "internalError"
  | "noCapacityForAttributionDestination"
  | "noMatchingSources"
  | "deduplicated"
  | "excessiveAttributions"
  | "priorityTooLow"
  | "neverAttributedSource"
  | "excessiveReportingOrigins"
  | "noMatchingSourceFilterData"
  | "prohibitedByBrowserPolicy"
  | "noMatchingConfigurations"
  | "excessiveReports"
  | "falselyAttributedSource"
  | "reportWindowPassed"
  | "notRegistered"
  | "reportWindowNotStarted"
  | "noMatchingTriggerData";

/**
 * @experimental
 */
export type Storage_AttributionReportingAggregatableResult =
  | "success"
  | "internalError"
  | "noCapacityForAttributionDestination"
  | "noMatchingSources"
  | "excessiveAttributions"
  | "excessiveReportingOrigins"
  | "noHistograms"
  | "insufficientBudget"
  | "noMatchingSourceFilterData"
  | "notRegistered"
  | "prohibitedByBrowserPolicy"
  | "deduplicated"
  | "reportWindowPassed"
  | "excessiveReports";

/**
 * @experimental
 * A single Related Website Set object.
 */
export type Storage_RelatedWebsiteSet = {
  /**
   * The primary site of this set, along with the ccTLDs if there is any.
   */
  primarySites: string[];
  /**
   * The associated sites of this set, along with the ccTLDs if there is any.
   */
  associatedSites: string[];
  /**
   * The service sites of this set, along with the ccTLDs if there is any.
   */
  serviceSites: string[];
};

// ----------------- SystemInfo Types -----------------

/**
 * Describes a single graphics processor (GPU).
 */
export type SystemInfo_GPUDevice = {
  /**
   * PCI ID of the GPU vendor, if available; 0 otherwise.
   */
  vendorId: number;
  /**
   * PCI ID of the GPU device, if available; 0 otherwise.
   */
  deviceId: number;
  /**
   * Sub sys ID of the GPU, only available on Windows.
   */
  subSysId?: number;
  /**
   * Revision of the GPU, only available on Windows.
   */
  revision?: number;
  /**
   * String description of the GPU vendor, if the PCI ID is not available.
   */
  vendorString: string;
  /**
   * String description of the GPU device, if the PCI ID is not available.
   */
  deviceString: string;
  /**
   * String description of the GPU driver vendor.
   */
  driverVendor: string;
  /**
   * String description of the GPU driver version.
   */
  driverVersion: string;
};

/**
 * Describes the width and height dimensions of an entity.
 */
export type SystemInfo_Size = {
  /**
   * Width in pixels.
   */
  width: number;
  /**
   * Height in pixels.
   */
  height: number;
};

/**
 * Describes a supported video decoding profile with its associated minimum and
 * maximum resolutions.
 */
export type SystemInfo_VideoDecodeAcceleratorCapability = {
  /**
   * Video codec profile that is supported, e.g. VP9 Profile 2.
   */
  profile: string;
  /**
   * Maximum video dimensions in pixels supported for this |profile|.
   */
  maxResolution: SystemInfo_Size;
  /**
   * Minimum video dimensions in pixels supported for this |profile|.
   */
  minResolution: SystemInfo_Size;
};

/**
 * Describes a supported video encoding profile with its associated maximum
 * resolution and maximum framerate.
 */
export type SystemInfo_VideoEncodeAcceleratorCapability = {
  /**
   * Video codec profile that is supported, e.g H264 Main.
   */
  profile: string;
  /**
   * Maximum video dimensions in pixels supported for this |profile|.
   */
  maxResolution: SystemInfo_Size;
  /**
   * Maximum encoding framerate in frames per second supported for this
   * |profile|, as fraction's numerator and denominator, e.g. 24/1 fps,
   * 24000/1001 fps, etc.
   */
  maxFramerateNumerator: number;
  maxFramerateDenominator: number;
};

/**
 * YUV subsampling type of the pixels of a given image.
 */
export type SystemInfo_SubsamplingFormat = "yuv420" | "yuv422" | "yuv444";

/**
 * Image format of a given image.
 */
export type SystemInfo_ImageType = "jpeg" | "webp" | "unknown";

/**
 * Describes a supported image decoding profile with its associated minimum and
 * maximum resolutions and subsampling.
 */
export type SystemInfo_ImageDecodeAcceleratorCapability = {
  /**
   * Image coded, e.g. Jpeg.
   */
  imageType: SystemInfo_ImageType;
  /**
   * Maximum supported dimensions of the image in pixels.
   */
  maxDimensions: SystemInfo_Size;
  /**
   * Minimum supported dimensions of the image in pixels.
   */
  minDimensions: SystemInfo_Size;
  /**
   * Optional array of supported subsampling formats, e.g. 4:2:0, if known.
   */
  subsamplings: SystemInfo_SubsamplingFormat[];
};

/**
 * Provides information about the GPU(s) on the system.
 */
export type SystemInfo_GPUInfo = {
  /**
   * The graphics devices on the system. Element 0 is the primary GPU.
   */
  devices: SystemInfo_GPUDevice[];
  /**
   * An optional dictionary of additional GPU related attributes.
   */
  auxAttributes?: object;
  /**
   * An optional dictionary of graphics features and their status.
   */
  featureStatus?: object;
  /**
   * An optional array of GPU driver bug workarounds.
   */
  driverBugWorkarounds: string[];
  /**
   * Supported accelerated video decoding capabilities.
   */
  videoDecoding: SystemInfo_VideoDecodeAcceleratorCapability[];
  /**
   * Supported accelerated video encoding capabilities.
   */
  videoEncoding: SystemInfo_VideoEncodeAcceleratorCapability[];
  /**
   * Supported accelerated image decoding capabilities.
   */
  imageDecoding: SystemInfo_ImageDecodeAcceleratorCapability[];
};

/**
 * Represents process info.
 */
export type SystemInfo_ProcessInfo = {
  /**
   * Specifies process type.
   */
  type: string;
  /**
   * Specifies process id.
   */
  id: number;
  /**
   * Specifies cumulative CPU usage in seconds across all threads of the
   * process since the process start.
   */
  cpuTime: number;
};

// ----------------- Target Types -----------------

export type Target_TargetID = string;

/**
 * Unique identifier of attached debugging session.
 */
export type Target_SessionID = string;

export type Target_TargetInfo = {
  targetId: Target_TargetID;
  /**
   * List of types: https://source.chromium.org/chromium/chromium/src/+/main:content/browser/devtools/devtools_agent_host_impl.cc?ss=chromium&q=f:devtools%20-f:out%20%22::kTypeTab%5B%5D%22
   */
  type: string;
  title: string;
  url: string;
  /**
   * Whether the target has an attached client.
   */
  attached: boolean;
  /**
   * Opener target Id
   */
  openerId?: Target_TargetID;
  /**
   * @experimental
   * Whether the target has access to the originating window.
   */
  canAccessOpener: boolean;
  /**
   * @experimental
   * Frame id of originating window (is only set if target has an opener).
   */
  openerFrameId?: Page_FrameId;
  /**
   * @experimental
   */
  browserContextId?: Browser_BrowserContextID;
  /**
   * @experimental
   * Provides additional details for specific target types. For example, for
   * the type of "page", this may be set to "portal" or "prerender".
   */
  subtype?: string;
};

/**
 * @experimental
 * A filter used by target query/discovery/auto-attach operations.
 */
export type Target_FilterEntry = {
  /**
   * If set, causes exclusion of matching targets from the list.
   */
  exclude?: boolean;
  /**
   * If not present, matches any type.
   */
  type?: string;
};

/**
 * @experimental
 * The entries in TargetFilter are matched sequentially against targets and
 * the first entry that matches determines if the target is included or not,
 * depending on the value of `exclude` field in the entry.
 * If filter is not specified, the one assumed is
 * [{type: "browser", exclude: true}, {type: "tab", exclude: true}, {}]
 * (i.e. include everything but `browser` and `tab`).
 */
export type Target_TargetFilter = Target_FilterEntry[];

/**
 * @experimental
 */
export type Target_RemoteLocation = {
  host: string;
  port: number;
};

// ----------------- Tethering Types -----------------

// ----------------- Tracing Types -----------------

/**
 * @experimental
 * Configuration for memory dump. Used only when "memory-infra" category is enabled.
 */
export type Tracing_MemoryDumpConfig = object;

export type Tracing_TraceConfig = {
  /**
   * @experimental
   * Controls how the trace buffer stores data.
   */
  recordMode?:
    | "recordUntilFull"
    | "recordContinuously"
    | "recordAsMuchAsPossible"
    | "echoToConsole";
  /**
   * @experimental
   * Size of the trace buffer in kilobytes. If not specified or zero is passed, a default value
   * of 200 MB would be used.
   */
  traceBufferSizeInKb?: number;
  /**
   * @experimental
   * Turns on JavaScript stack sampling.
   */
  enableSampling?: boolean;
  /**
   * @experimental
   * Turns on system tracing.
   */
  enableSystrace?: boolean;
  /**
   * @experimental
   * Turns on argument filter.
   */
  enableArgumentFilter?: boolean;
  /**
   * Included category filters.
   */
  includedCategories?: string[];
  /**
   * Excluded category filters.
   */
  excludedCategories?: string[];
  /**
   * @experimental
   * Configuration to synthesize the delays in tracing.
   */
  syntheticDelays?: string[];
  /**
   * @experimental
   * Configuration for memory dump triggers. Used only when "memory-infra" category is enabled.
   */
  memoryDumpConfig?: Tracing_MemoryDumpConfig;
};

/**
 * @experimental
 * Data format of a trace. Can be either the legacy JSON format or the
 * protocol buffer format. Note that the JSON format will be deprecated soon.
 */
export type Tracing_StreamFormat = "json" | "proto";

/**
 * @experimental
 * Compression type to use for traces returned via streams.
 */
export type Tracing_StreamCompression = "none" | "gzip";

/**
 * @experimental
 * Details exposed when memory request explicitly declared.
 * Keep consistent with memory_dump_request_args.h and
 * memory_instrumentation.mojom
 */
export type Tracing_MemoryDumpLevelOfDetail =
  | "background"
  | "light"
  | "detailed";

/**
 * @experimental
 * Backend type to use for tracing. `chrome` uses the Chrome-integrated
 * tracing service and is supported on all platforms. `system` is only
 * supported on Chrome OS and uses the Perfetto system tracing service.
 * `auto` chooses `system` when the perfettoConfig provided to Tracing.start
 * specifies at least one non-Chrome data source; otherwise uses `chrome`.
 */
export type Tracing_TracingBackend = "auto" | "chrome" | "system";

// ----------------- Fetch Types -----------------

/**
 * Unique request identifier.
 */
export type Fetch_RequestId = string;

/**
 * Stages of the request to handle. Request will intercept before the request is
 * sent. Response will intercept after the response is received (but before response
 * body is received).
 */
export type Fetch_RequestStage = "Request" | "Response";

export type Fetch_RequestPattern = {
  /**
   * Wildcards (`'*'` -> zero or more, `'?'` -> exactly one) are allowed. Escape character is
   * backslash. Omitting is equivalent to `"*"`.
   */
  urlPattern?: string;
  /**
   * If set, only requests for matching resource types will be intercepted.
   */
  resourceType?: Network_ResourceType;
  /**
   * Stage at which to begin intercepting requests. Default is Request.
   */
  requestStage?: Fetch_RequestStage;
};

/**
 * Response HTTP header entry
 */
export type Fetch_HeaderEntry = {
  name: string;
  value: string;
};

/**
 * Authorization challenge for HTTP status code 401 or 407.
 */
export type Fetch_AuthChallenge = {
  /**
   * Source of the authentication challenge.
   */
  source?: "Server" | "Proxy";
  /**
   * Origin of the challenger.
   */
  origin: string;
  /**
   * The authentication scheme used, such as basic or digest
   */
  scheme: string;
  /**
   * The realm of the challenge. May be empty.
   */
  realm: string;
};

/**
 * Response to an AuthChallenge.
 */
export type Fetch_AuthChallengeResponse = {
  /**
   * The decision on what to do in response to the authorization challenge.  Default means
   * deferring to the default behavior of the net stack, which will likely either the Cancel
   * authentication or display a popup dialog box.
   */
  response: "Default" | "CancelAuth" | "ProvideCredentials";
  /**
   * The username to provide, possibly empty. Should only be set if response is
   * ProvideCredentials.
   */
  username?: string;
  /**
   * The password to provide, possibly empty. Should only be set if response is
   * ProvideCredentials.
   */
  password?: string;
};

// ----------------- WebAudio Types -----------------

/**
 * An unique ID for a graph object (AudioContext, AudioNode, AudioParam) in Web Audio API
 */
export type WebAudio_GraphObjectId = string;

/**
 * Enum of BaseAudioContext types
 */
export type WebAudio_ContextType = "realtime" | "offline";

/**
 * Enum of AudioContextState from the spec
 */
export type WebAudio_ContextState = "suspended" | "running" | "closed";

/**
 * Enum of AudioNode types
 */
export type WebAudio_NodeType = string;

/**
 * Enum of AudioNode::ChannelCountMode from the spec
 */
export type WebAudio_ChannelCountMode = "clamped-max" | "explicit" | "max";

/**
 * Enum of AudioNode::ChannelInterpretation from the spec
 */
export type WebAudio_ChannelInterpretation = "discrete" | "speakers";

/**
 * Enum of AudioParam types
 */
export type WebAudio_ParamType = string;

/**
 * Enum of AudioParam::AutomationRate from the spec
 */
export type WebAudio_AutomationRate = "a-rate" | "k-rate";

/**
 * Fields in AudioContext that change in real-time.
 */
export type WebAudio_ContextRealtimeData = {
  /**
   * The current context time in second in BaseAudioContext.
   */
  currentTime: number;
  /**
   * The time spent on rendering graph divided by render quantum duration,
   * and multiplied by 100. 100 means the audio renderer reached the full
   * capacity and glitch may occur.
   */
  renderCapacity: number;
  /**
   * A running mean of callback interval.
   */
  callbackIntervalMean: number;
  /**
   * A running variance of callback interval.
   */
  callbackIntervalVariance: number;
};

/**
 * Protocol object for BaseAudioContext
 */
export type WebAudio_BaseAudioContext = {
  contextId: WebAudio_GraphObjectId;
  contextType: WebAudio_ContextType;
  contextState: WebAudio_ContextState;
  realtimeData?: WebAudio_ContextRealtimeData;
  /**
   * Platform-dependent callback buffer size.
   */
  callbackBufferSize: number;
  /**
   * Number of output channels supported by audio hardware in use.
   */
  maxOutputChannelCount: number;
  /**
   * Context sample rate.
   */
  sampleRate: number;
};

/**
 * Protocol object for AudioListener
 */
export type WebAudio_AudioListener = {
  listenerId: WebAudio_GraphObjectId;
  contextId: WebAudio_GraphObjectId;
};

/**
 * Protocol object for AudioNode
 */
export type WebAudio_AudioNode = {
  nodeId: WebAudio_GraphObjectId;
  contextId: WebAudio_GraphObjectId;
  nodeType: WebAudio_NodeType;
  numberOfInputs: number;
  numberOfOutputs: number;
  channelCount: number;
  channelCountMode: WebAudio_ChannelCountMode;
  channelInterpretation: WebAudio_ChannelInterpretation;
};

/**
 * Protocol object for AudioParam
 */
export type WebAudio_AudioParam = {
  paramId: WebAudio_GraphObjectId;
  nodeId: WebAudio_GraphObjectId;
  contextId: WebAudio_GraphObjectId;
  paramType: WebAudio_ParamType;
  rate: WebAudio_AutomationRate;
  defaultValue: number;
  minValue: number;
  maxValue: number;
};

// ----------------- WebAuthn Types -----------------

export type WebAuthn_AuthenticatorId = string;

export type WebAuthn_AuthenticatorProtocol = "u2f" | "ctap2";

export type WebAuthn_Ctap2Version = "ctap2_0" | "ctap2_1";

export type WebAuthn_AuthenticatorTransport =
  | "usb"
  | "nfc"
  | "ble"
  | "cable"
  | "internal";

export type WebAuthn_VirtualAuthenticatorOptions = {
  protocol: WebAuthn_AuthenticatorProtocol;
  /**
   * Defaults to ctap2_0. Ignored if |protocol| == u2f.
   */
  ctap2Version?: WebAuthn_Ctap2Version;
  transport: WebAuthn_AuthenticatorTransport;
  /**
   * Defaults to false.
   */
  hasResidentKey?: boolean;
  /**
   * Defaults to false.
   */
  hasUserVerification?: boolean;
  /**
   * If set to true, the authenticator will support the largeBlob extension.
   * https://w3c.github.io/webauthn#largeBlob
   * Defaults to false.
   */
  hasLargeBlob?: boolean;
  /**
   * If set to true, the authenticator will support the credBlob extension.
   * https://fidoalliance.org/specs/fido-v2.1-rd-20201208/fido-client-to-authenticator-protocol-v2.1-rd-20201208.html#sctn-credBlob-extension
   * Defaults to false.
   */
  hasCredBlob?: boolean;
  /**
   * If set to true, the authenticator will support the minPinLength extension.
   * https://fidoalliance.org/specs/fido-v2.1-ps-20210615/fido-client-to-authenticator-protocol-v2.1-ps-20210615.html#sctn-minpinlength-extension
   * Defaults to false.
   */
  hasMinPinLength?: boolean;
  /**
   * If set to true, the authenticator will support the prf extension.
   * https://w3c.github.io/webauthn/#prf-extension
   * Defaults to false.
   */
  hasPrf?: boolean;
  /**
   * If set to true, tests of user presence will succeed immediately.
   * Otherwise, they will not be resolved. Defaults to true.
   */
  automaticPresenceSimulation?: boolean;
  /**
   * Sets whether User Verification succeeds or fails for an authenticator.
   * Defaults to false.
   */
  isUserVerified?: boolean;
  /**
   * Credentials created by this authenticator will have the backup
   * eligibility (BE) flag set to this value. Defaults to false.
   * https://w3c.github.io/webauthn/#sctn-credential-backup
   */
  defaultBackupEligibility?: boolean;
  /**
   * Credentials created by this authenticator will have the backup state
   * (BS) flag set to this value. Defaults to false.
   * https://w3c.github.io/webauthn/#sctn-credential-backup
   */
  defaultBackupState?: boolean;
};

export type WebAuthn_Credential = {
  credentialId: string;
  isResidentCredential: boolean;
  /**
   * Relying Party ID the credential is scoped to. Must be set when adding a
   * credential.
   */
  rpId?: string;
  /**
   * The ECDSA P-256 private key in PKCS#8 format.
   */
  privateKey: string;
  /**
   * An opaque byte sequence with a maximum size of 64 bytes mapping the
   * credential to a specific user.
   */
  userHandle?: string;
  /**
   * Signature counter. This is incremented by one for each successful
   * assertion.
   * See https://w3c.github.io/webauthn/#signature-counter
   */
  signCount: number;
  /**
   * The large blob associated with the credential.
   * See https://w3c.github.io/webauthn/#sctn-large-blob-extension
   */
  largeBlob?: string;
  /**
   * Assertions returned by this credential will have the backup eligibility
   * (BE) flag set to this value. Defaults to the authenticator's
   * defaultBackupEligibility value.
   */
  backupEligibility?: boolean;
  /**
   * Assertions returned by this credential will have the backup state (BS)
   * flag set to this value. Defaults to the authenticator's
   * defaultBackupState value.
   */
  backupState?: boolean;
};

// ----------------- Media Types -----------------

/**
 * Players will get an ID that is unique within the agent context.
 */
export type Media_PlayerId = string;

export type Media_Timestamp = number;

/**
 * Have one type per entry in MediaLogRecord::Type
 * Corresponds to kMessage
 */
export type Media_PlayerMessage = {
  /**
   * Keep in sync with MediaLogMessageLevel
   * We are currently keeping the message level 'error' separate from the
   * PlayerError type because right now they represent different things,
   * this one being a DVLOG(ERROR) style log message that gets printed
   * based on what log level is selected in the UI, and the other is a
   * representation of a media::PipelineStatus object. Soon however we're
   * going to be moving away from using PipelineStatus for errors and
   * introducing a new error type which should hopefully let us integrate
   * the error log level into the PlayerError type.
   */
  level: "error" | "warning" | "info" | "debug";
  message: string;
};

/**
 * Corresponds to kMediaPropertyChange
 */
export type Media_PlayerProperty = {
  name: string;
  value: string;
};

/**
 * Corresponds to kMediaEventTriggered
 */
export type Media_PlayerEvent = {
  timestamp: Media_Timestamp;
  value: string;
};

/**
 * Represents logged source line numbers reported in an error.
 * NOTE: file and line are from chromium c++ implementation code, not js.
 */
export type Media_PlayerErrorSourceLocation = {
  file: string;
  line: number;
};

/**
 * Corresponds to kMediaError
 */
export type Media_PlayerError = {
  errorType: string;
  /**
   * Code is the numeric enum entry for a specific set of error codes, such
   * as PipelineStatusCodes in media/base/pipeline_status.h
   */
  code: number;
  /**
   * A trace of where this error was caused / where it passed through.
   */
  stack: Media_PlayerErrorSourceLocation[];
  /**
   * Errors potentially have a root cause error, ie, a DecoderError might be
   * caused by an WindowsError
   */
  cause: Media_PlayerError[];
  /**
   * Extra data attached to an error, such as an HRESULT, Video Codec, etc.
   */
  data: object;
};

// ----------------- DeviceAccess Types -----------------

/**
 * Device request id.
 */
export type DeviceAccess_RequestId = string;

/**
 * A device id.
 */
export type DeviceAccess_DeviceId = string;

/**
 * Device information displayed in a user prompt to select a device.
 */
export type DeviceAccess_PromptDevice = {
  id: DeviceAccess_DeviceId;
  /**
   * Display name as it appears in a device request user prompt.
   */
  name: string;
};

// ----------------- Preload Types -----------------

/**
 * Unique id
 */
export type Preload_RuleSetId = string;

/**
 * Corresponds to SpeculationRuleSet
 */
export type Preload_RuleSet = {
  id: Preload_RuleSetId;
  /**
   * Identifies a document which the rule set is associated with.
   */
  loaderId: Network_LoaderId;
  /**
   * Source text of JSON representing the rule set. If it comes from
   * `<script>` tag, it is the textContent of the node. Note that it is
   * a JSON for valid case.
   *
   * See also:
   * - https://wicg.github.io/nav-speculation/speculation-rules.html
   * - https://github.com/WICG/nav-speculation/blob/main/triggers.md
   */
  sourceText: string;
  /**
   * A speculation rule set is either added through an inline
   * `<script>` tag or through an external resource via the
   * 'Speculation-Rules' HTTP header. For the first case, we include
   * the BackendNodeId of the relevant `<script>` tag. For the second
   * case, we include the external URL where the rule set was loaded
   * from, and also RequestId if Network domain is enabled.
   *
   * See also:
   * - https://wicg.github.io/nav-speculation/speculation-rules.html#speculation-rules-script
   * - https://wicg.github.io/nav-speculation/speculation-rules.html#speculation-rules-header
   */
  backendNodeId?: DOM_BackendNodeId;
  url?: string;
  requestId?: Network_RequestId;
  /**
   * Error information
   * `errorMessage` is null iff `errorType` is null.
   */
  errorType?: Preload_RuleSetErrorType;
  /**
   * @deprecated
   * TODO(https://crbug.com/1425354): Replace this property with structured error.
   */
  errorMessage?: string;
};

export type Preload_RuleSetErrorType =
  | "SourceIsNotJsonObject"
  | "InvalidRulesSkipped";

/**
 * The type of preloading attempted. It corresponds to
 * mojom::SpeculationAction (although PrefetchWithSubresources is omitted as it
 * isn't being used by clients).
 */
export type Preload_SpeculationAction = "Prefetch" | "Prerender";

/**
 * Corresponds to mojom::SpeculationTargetHint.
 * See https://github.com/WICG/nav-speculation/blob/main/triggers.md#window-name-targeting-hints
 */
export type Preload_SpeculationTargetHint = "Blank" | "Self";

/**
 * A key that identifies a preloading attempt.
 *
 * The url used is the url specified by the trigger (i.e. the initial URL), and
 * not the final url that is navigated to. For example, prerendering allows
 * same-origin main frame navigations during the attempt, but the attempt is
 * still keyed with the initial URL.
 */
export type Preload_PreloadingAttemptKey = {
  loaderId: Network_LoaderId;
  action: Preload_SpeculationAction;
  url: string;
  targetHint?: Preload_SpeculationTargetHint;
};

/**
 * Lists sources for a preloading attempt, specifically the ids of rule sets
 * that had a speculation rule that triggered the attempt, and the
 * BackendNodeIds of <a href> or <area href> elements that triggered the
 * attempt (in the case of attempts triggered by a document rule). It is
 * possible for multiple rule sets and links to trigger a single attempt.
 */
export type Preload_PreloadingAttemptSource = {
  key: Preload_PreloadingAttemptKey;
  ruleSetIds: Preload_RuleSetId[];
  nodeIds: DOM_BackendNodeId[];
};

/**
 * List of FinalStatus reasons for Prerender2.
 */
export type Preload_PrerenderFinalStatus =
  | "Activated"
  | "Destroyed"
  | "LowEndDevice"
  | "InvalidSchemeRedirect"
  | "InvalidSchemeNavigation"
  | "NavigationRequestBlockedByCsp"
  | "MainFrameNavigation"
  | "MojoBinderPolicy"
  | "RendererProcessCrashed"
  | "RendererProcessKilled"
  | "Download"
  | "TriggerDestroyed"
  | "NavigationNotCommitted"
  | "NavigationBadHttpStatus"
  | "ClientCertRequested"
  | "NavigationRequestNetworkError"
  | "CancelAllHostsForTesting"
  | "DidFailLoad"
  | "Stop"
  | "SslCertificateError"
  | "LoginAuthRequested"
  | "UaChangeRequiresReload"
  | "BlockedByClient"
  | "AudioOutputDeviceRequested"
  | "MixedContent"
  | "TriggerBackgrounded"
  | "MemoryLimitExceeded"
  | "DataSaverEnabled"
  | "TriggerUrlHasEffectiveUrl"
  | "ActivatedBeforeStarted"
  | "InactivePageRestriction"
  | "StartFailed"
  | "TimeoutBackgrounded"
  | "CrossSiteRedirectInInitialNavigation"
  | "CrossSiteNavigationInInitialNavigation"
  | "SameSiteCrossOriginRedirectNotOptInInInitialNavigation"
  | "SameSiteCrossOriginNavigationNotOptInInInitialNavigation"
  | "ActivationNavigationParameterMismatch"
  | "ActivatedInBackground"
  | "EmbedderHostDisallowed"
  | "ActivationNavigationDestroyedBeforeSuccess"
  | "TabClosedByUserGesture"
  | "TabClosedWithoutUserGesture"
  | "PrimaryMainFrameRendererProcessCrashed"
  | "PrimaryMainFrameRendererProcessKilled"
  | "ActivationFramePolicyNotCompatible"
  | "PreloadingDisabled"
  | "BatterySaverEnabled"
  | "ActivatedDuringMainFrameNavigation"
  | "PreloadingUnsupportedByWebContents"
  | "CrossSiteRedirectInMainFrameNavigation"
  | "CrossSiteNavigationInMainFrameNavigation"
  | "SameSiteCrossOriginRedirectNotOptInInMainFrameNavigation"
  | "SameSiteCrossOriginNavigationNotOptInInMainFrameNavigation"
  | "MemoryPressureOnTrigger"
  | "MemoryPressureAfterTriggered"
  | "PrerenderingDisabledByDevTools"
  | "SpeculationRuleRemoved"
  | "ActivatedWithAuxiliaryBrowsingContexts"
  | "MaxNumOfRunningEagerPrerendersExceeded"
  | "MaxNumOfRunningNonEagerPrerendersExceeded"
  | "MaxNumOfRunningEmbedderPrerendersExceeded"
  | "PrerenderingUrlHasEffectiveUrl"
  | "RedirectedPrerenderingUrlHasEffectiveUrl"
  | "ActivationUrlHasEffectiveUrl";

/**
 * Preloading status values, see also PreloadingTriggeringOutcome. This
 * status is shared by prefetchStatusUpdated and prerenderStatusUpdated.
 */
export type Preload_PreloadingStatus =
  | "Pending"
  | "Running"
  | "Ready"
  | "Success"
  | "Failure"
  | "NotSupported";

/**
 * TODO(https://crbug.com/1384419): revisit the list of PrefetchStatus and
 * filter out the ones that aren't necessary to the developers.
 */
export type Preload_PrefetchStatus =
  | "PrefetchAllowed"
  | "PrefetchFailedIneligibleRedirect"
  | "PrefetchFailedInvalidRedirect"
  | "PrefetchFailedMIMENotSupported"
  | "PrefetchFailedNetError"
  | "PrefetchFailedNon2XX"
  | "PrefetchFailedPerPageLimitExceeded"
  | "PrefetchEvictedAfterCandidateRemoved"
  | "PrefetchEvictedForNewerPrefetch"
  | "PrefetchHeldback"
  | "PrefetchIneligibleRetryAfter"
  | "PrefetchIsPrivacyDecoy"
  | "PrefetchIsStale"
  | "PrefetchNotEligibleBrowserContextOffTheRecord"
  | "PrefetchNotEligibleDataSaverEnabled"
  | "PrefetchNotEligibleExistingProxy"
  | "PrefetchNotEligibleHostIsNonUnique"
  | "PrefetchNotEligibleNonDefaultStoragePartition"
  | "PrefetchNotEligibleSameSiteCrossOriginPrefetchRequiredProxy"
  | "PrefetchNotEligibleSchemeIsNotHttps"
  | "PrefetchNotEligibleUserHasCookies"
  | "PrefetchNotEligibleUserHasServiceWorker"
  | "PrefetchNotEligibleBatterySaverEnabled"
  | "PrefetchNotEligiblePreloadingDisabled"
  | "PrefetchNotFinishedInTime"
  | "PrefetchNotStarted"
  | "PrefetchNotUsedCookiesChanged"
  | "PrefetchProxyNotAvailable"
  | "PrefetchResponseUsed"
  | "PrefetchSuccessfulButNotUsed"
  | "PrefetchNotUsedProbeFailed";

/**
 * Information of headers to be displayed when the header mismatch occurred.
 */
export type Preload_PrerenderMismatchedHeaders = {
  headerName: string;
  initialValue?: string;
  activationValue?: string;
};

// ----------------- FedCm Types -----------------

/**
 * Whether this is a sign-up or sign-in action for this account, i.e.
 * whether this account has ever been used to sign in to this RP before.
 */
export type FedCm_LoginState = "SignIn" | "SignUp";

/**
 * The types of FedCM dialogs.
 */
export type FedCm_DialogType =
  | "AccountChooser"
  | "AutoReauthn"
  | "ConfirmIdpLogin"
  | "Error";

/**
 * The buttons on the FedCM dialog.
 */
export type FedCm_DialogButton =
  | "ConfirmIdpLoginContinue"
  | "ErrorGotIt"
  | "ErrorMoreDetails";

/**
 * The URLs that each account has
 */
export type FedCm_AccountUrlType = "TermsOfService" | "PrivacyPolicy";

/**
 * Corresponds to IdentityRequestAccount
 */
export type FedCm_Account = {
  accountId: string;
  email: string;
  name: string;
  givenName: string;
  pictureUrl: string;
  idpConfigUrl: string;
  idpLoginUrl: string;
  loginState: FedCm_LoginState;
  /**
   * These two are only set if the loginState is signUp
   */
  termsOfServiceUrl?: string;
  privacyPolicyUrl?: string;
};

// ----------------- PWA Types -----------------

/**
 * The following types are the replica of
 * https://crsrc.org/c/chrome/browser/web_applications/proto/web_app_os_integration_state.proto;drc=9910d3be894c8f142c977ba1023f30a656bc13fc;l=67
 */
export type PWA_FileHandlerAccept = {
  /**
   * New name of the mimetype according to
   * https://www.iana.org/assignments/media-types/media-types.xhtml
   */
  mediaType: string;
  fileExtensions: string[];
};

export type PWA_FileHandler = {
  action: string;
  accepts: PWA_FileHandlerAccept[];
  displayName: string;
};

// ----------------- Console Types -----------------

/**
 * Console message.
 */
export type Console_ConsoleMessage = {
  /**
   * Message source.
   */
  source:
    | "xml"
    | "javascript"
    | "network"
    | "console-api"
    | "storage"
    | "appcache"
    | "rendering"
    | "security"
    | "other"
    | "deprecation"
    | "worker";
  /**
   * Message severity.
   */
  level: "log" | "warning" | "error" | "debug" | "info";
  /**
   * Message text.
   */
  text: string;
  /**
   * URL of the message origin.
   */
  url?: string;
  /**
   * Line number in the resource that generated this message (1-based).
   */
  line?: number;
  /**
   * Column number in the resource that generated this message (1-based).
   */
  column?: number;
};

// ----------------- Debugger Types -----------------

/**
 * Breakpoint identifier.
 */
export type Debugger_BreakpointId = string;

/**
 * Call frame identifier.
 */
export type Debugger_CallFrameId = string;

/**
 * Location in the source code.
 */
export type Debugger_Location = {
  /**
   * Script identifier as reported in the `Debugger.scriptParsed`.
   */
  scriptId: Runtime_ScriptId;
  /**
   * Line number in the script (0-based).
   */
  lineNumber: number;
  /**
   * Column number in the script (0-based).
   */
  columnNumber?: number;
};

/**
 * @experimental
 * Location in the source code.
 */
export type Debugger_ScriptPosition = {
  lineNumber: number;
  columnNumber: number;
};

/**
 * @experimental
 * Location range within one script.
 */
export type Debugger_LocationRange = {
  scriptId: Runtime_ScriptId;
  start: Debugger_ScriptPosition;
  end: Debugger_ScriptPosition;
};

/**
 * JavaScript call frame. Array of call frames form the call stack.
 */
export type Debugger_CallFrame = {
  /**
   * Call frame identifier. This identifier is only valid while the virtual machine is paused.
   */
  callFrameId: Debugger_CallFrameId;
  /**
   * Name of the JavaScript function called on this call frame.
   */
  functionName: string;
  /**
   * Location in the source code.
   */
  functionLocation?: Debugger_Location;
  /**
   * Location in the source code.
   */
  location: Debugger_Location;
  /**
   * @deprecated
   * JavaScript script name or url.
   * Deprecated in favor of using the `location.scriptId` to resolve the URL via a previously
   * sent `Debugger.scriptParsed` event.
   */
  url: string;
  /**
   * Scope chain for this call frame.
   */
  scopeChain: Debugger_Scope[];
  /**
   * `this` object for this call frame.
   */
  this: Runtime_RemoteObject;
  /**
   * The value being returned, if the function is at return point.
   */
  returnValue?: Runtime_RemoteObject;
  /**
   * @experimental
   * Valid only while the VM is paused and indicates whether this frame
   * can be restarted or not. Note that a `true` value here does not
   * guarantee that Debugger#restartFrame with this CallFrameId will be
   * successful, but it is very likely.
   */
  canBeRestarted?: boolean;
};

/**
 * Scope description.
 */
export type Debugger_Scope = {
  /**
   * Scope type.
   */
  type:
    | "global"
    | "local"
    | "with"
    | "closure"
    | "catch"
    | "block"
    | "script"
    | "eval"
    | "module"
    | "wasm-expression-stack";
  /**
   * Object representing the scope. For `global` and `with` scopes it represents the actual
   * object; for the rest of the scopes, it is artificial transient object enumerating scope
   * variables as its properties.
   */
  object: Runtime_RemoteObject;
  name?: string;
  /**
   * Location in the source code where scope starts
   */
  startLocation?: Debugger_Location;
  /**
   * Location in the source code where scope ends
   */
  endLocation?: Debugger_Location;
};

/**
 * Search match for resource.
 */
export type Debugger_SearchMatch = {
  /**
   * Line number in resource content.
   */
  lineNumber: number;
  /**
   * Line with match content.
   */
  lineContent: string;
};

export type Debugger_BreakLocation = {
  /**
   * Script identifier as reported in the `Debugger.scriptParsed`.
   */
  scriptId: Runtime_ScriptId;
  /**
   * Line number in the script (0-based).
   */
  lineNumber: number;
  /**
   * Column number in the script (0-based).
   */
  columnNumber?: number;
  type?: "debuggerStatement" | "call" | "return";
};

/**
 * @experimental
 */
export type Debugger_WasmDisassemblyChunk = {
  /**
   * The next chunk of disassembled lines.
   */
  lines: string[];
  /**
   * The bytecode offsets describing the start of each line.
   */
  bytecodeOffsets: number[];
};

/**
 * Enum of possible script languages.
 */
export type Debugger_ScriptLanguage = "JavaScript" | "WebAssembly";

/**
 * Debug symbols available for a wasm script.
 */
export type Debugger_DebugSymbols = {
  /**
   * Type of the debug symbols.
   */
  type: "None" | "SourceMap" | "EmbeddedDWARF" | "ExternalDWARF";
  /**
   * URL of the external symbol source.
   */
  externalURL?: string;
};

// ----------------- HeapProfiler Types -----------------

/**
 * Heap snapshot object id.
 */
export type HeapProfiler_HeapSnapshotObjectId = string;

/**
 * Sampling Heap Profile node. Holds callsite information, allocation statistics and child nodes.
 */
export type HeapProfiler_SamplingHeapProfileNode = {
  /**
   * Function location.
   */
  callFrame: Runtime_CallFrame;
  /**
   * Allocations size in bytes for the node excluding children.
   */
  selfSize: number;
  /**
   * Node id. Ids are unique across all profiles collected between startSampling and stopSampling.
   */
  id: number;
  /**
   * Child nodes.
   */
  children: HeapProfiler_SamplingHeapProfileNode[];
};

/**
 * A single sample from a sampling profile.
 */
export type HeapProfiler_SamplingHeapProfileSample = {
  /**
   * Allocation size in bytes attributed to the sample.
   */
  size: number;
  /**
   * Id of the corresponding profile tree node.
   */
  nodeId: number;
  /**
   * Time-ordered sample ordinal number. It is unique across all profiles retrieved
   * between startSampling and stopSampling.
   */
  ordinal: number;
};

/**
 * Sampling profile.
 */
export type HeapProfiler_SamplingHeapProfile = {
  head: HeapProfiler_SamplingHeapProfileNode;
  samples: HeapProfiler_SamplingHeapProfileSample[];
};

// ----------------- Profiler Types -----------------

/**
 * Profile node. Holds callsite information, execution statistics and child nodes.
 */
export type Profiler_ProfileNode = {
  /**
   * Unique id of the node.
   */
  id: number;
  /**
   * Function location.
   */
  callFrame: Runtime_CallFrame;
  /**
   * Number of samples where this node was on top of the call stack.
   */
  hitCount?: number;
  /**
   * Child node ids.
   */
  children?: number[];
  /**
   * The reason of being not optimized. The function may be deoptimized or marked as don't
   * optimize.
   */
  deoptReason?: string;
  /**
   * An array of source position ticks.
   */
  positionTicks?: Profiler_PositionTickInfo[];
};

/**
 * Profile.
 */
export type Profiler_Profile = {
  /**
   * The list of profile nodes. First item is the root node.
   */
  nodes: Profiler_ProfileNode[];
  /**
   * Profiling start timestamp in microseconds.
   */
  startTime: number;
  /**
   * Profiling end timestamp in microseconds.
   */
  endTime: number;
  /**
   * Ids of samples top nodes.
   */
  samples?: number[];
  /**
   * Time intervals between adjacent samples in microseconds. The first delta is relative to the
   * profile startTime.
   */
  timeDeltas?: number[];
};

/**
 * Specifies a number of samples attributed to a certain source position.
 */
export type Profiler_PositionTickInfo = {
  /**
   * Source line number (1-based).
   */
  line: number;
  /**
   * Number of samples attributed to the source line.
   */
  ticks: number;
};

/**
 * Coverage data for a source range.
 */
export type Profiler_CoverageRange = {
  /**
   * JavaScript script source offset for the range start.
   */
  startOffset: number;
  /**
   * JavaScript script source offset for the range end.
   */
  endOffset: number;
  /**
   * Collected execution count of the source range.
   */
  count: number;
};

/**
 * Coverage data for a JavaScript function.
 */
export type Profiler_FunctionCoverage = {
  /**
   * JavaScript function name.
   */
  functionName: string;
  /**
   * Source ranges inside the function with coverage data.
   */
  ranges: Profiler_CoverageRange[];
  /**
   * Whether coverage data for this function has block granularity.
   */
  isBlockCoverage: boolean;
};

/**
 * Coverage data for a JavaScript script.
 */
export type Profiler_ScriptCoverage = {
  /**
   * JavaScript script id.
   */
  scriptId: Runtime_ScriptId;
  /**
   * JavaScript script name or url.
   */
  url: string;
  /**
   * Functions contained in the script that has coverage data.
   */
  functions: Profiler_FunctionCoverage[];
};

// ----------------- Runtime Types -----------------

/**
 * Unique script identifier.
 */
export type Runtime_ScriptId = string;

/**
 * Represents options for serialization. Overrides `generatePreview` and `returnByValue`.
 */
export type Runtime_SerializationOptions = {
  serialization: "deep" | "json" | "idOnly";
  /**
   * Deep serialization depth. Default is full depth. Respected only in `deep` serialization mode.
   */
  maxDepth?: number;
  /**
   * Embedder-specific parameters. For example if connected to V8 in Chrome these control DOM
   * serialization via `maxNodeDepth: integer` and `includeShadowTree: "none" | "open" | "all"`.
   * Values can be only of type string or integer.
   */
  additionalParameters?: object;
};

/**
 * Represents deep serialized value.
 */
export type Runtime_DeepSerializedValue = {
  type:
    | "undefined"
    | "null"
    | "string"
    | "number"
    | "boolean"
    | "bigint"
    | "regexp"
    | "date"
    | "symbol"
    | "array"
    | "object"
    | "function"
    | "map"
    | "set"
    | "weakmap"
    | "weakset"
    | "error"
    | "proxy"
    | "promise"
    | "typedarray"
    | "arraybuffer"
    | "node"
    | "window"
    | "generator";
  value?: any;
  objectId?: string;
  /**
   * Set if value reference met more then once during serialization. In such
   * case, value is provided only to one of the serialized values. Unique
   * per value in the scope of one CDP call.
   */
  weakLocalObjectReference?: number;
};

/**
 * Unique object identifier.
 */
export type Runtime_RemoteObjectId = string;

/**
 * Primitive value which cannot be JSON-stringified. Includes values `-0`, `NaN`, `Infinity`,
 * `-Infinity`, and bigint literals.
 */
export type Runtime_UnserializableValue = string;

/**
 * Mirror object referencing original JavaScript object.
 */
export type Runtime_RemoteObject = {
  /**
   * Object type.
   */
  type:
    | "object"
    | "function"
    | "undefined"
    | "string"
    | "number"
    | "boolean"
    | "symbol"
    | "bigint";
  /**
   * Object subtype hint. Specified for `object` type values only.
   * NOTE: If you change anything here, make sure to also update
   * `subtype` in `ObjectPreview` and `PropertyPreview` below.
   */
  subtype?:
    | "array"
    | "null"
    | "node"
    | "regexp"
    | "date"
    | "map"
    | "set"
    | "weakmap"
    | "weakset"
    | "iterator"
    | "generator"
    | "error"
    | "proxy"
    | "promise"
    | "typedarray"
    | "arraybuffer"
    | "dataview"
    | "webassemblymemory"
    | "wasmvalue";
  /**
   * Object class (constructor) name. Specified for `object` type values only.
   */
  className?: string;
  /**
   * Remote object value in case of primitive values or JSON values (if it was requested).
   */
  value?: any;
  /**
   * Primitive value which can not be JSON-stringified does not have `value`, but gets this
   * property.
   */
  unserializableValue?: Runtime_UnserializableValue;
  /**
   * String representation of the object.
   */
  description?: string;
  /**
   * @experimental
   * Deep serialized value.
   */
  deepSerializedValue?: Runtime_DeepSerializedValue;
  /**
   * Unique object identifier (for non-primitive values).
   */
  objectId?: Runtime_RemoteObjectId;
  /**
   * @experimental
   * Preview containing abbreviated property values. Specified for `object` type values only.
   */
  preview?: Runtime_ObjectPreview;
  /**
   * @experimental
   */
  customPreview?: Runtime_CustomPreview;
};

/**
 * @experimental
 */
export type Runtime_CustomPreview = {
  /**
   * The JSON-stringified result of formatter.header(object, config) call.
   * It contains json ML array that represents RemoteObject.
   */
  header: string;
  /**
   * If formatter returns true as a result of formatter.hasBody call then bodyGetterId will
   * contain RemoteObjectId for the function that returns result of formatter.body(object, config) call.
   * The result value is json ML array.
   */
  bodyGetterId?: Runtime_RemoteObjectId;
};

/**
 * @experimental
 * Object containing abbreviated remote object value.
 */
export type Runtime_ObjectPreview = {
  /**
   * Object type.
   */
  type:
    | "object"
    | "function"
    | "undefined"
    | "string"
    | "number"
    | "boolean"
    | "symbol"
    | "bigint";
  /**
   * Object subtype hint. Specified for `object` type values only.
   */
  subtype?:
    | "array"
    | "null"
    | "node"
    | "regexp"
    | "date"
    | "map"
    | "set"
    | "weakmap"
    | "weakset"
    | "iterator"
    | "generator"
    | "error"
    | "proxy"
    | "promise"
    | "typedarray"
    | "arraybuffer"
    | "dataview"
    | "webassemblymemory"
    | "wasmvalue";
  /**
   * String representation of the object.
   */
  description?: string;
  /**
   * True iff some of the properties or entries of the original object did not fit.
   */
  overflow: boolean;
  /**
   * List of the properties.
   */
  properties: Runtime_PropertyPreview[];
  /**
   * List of the entries. Specified for `map` and `set` subtype values only.
   */
  entries?: Runtime_EntryPreview[];
};

/**
 * @experimental
 */
export type Runtime_PropertyPreview = {
  /**
   * Property name.
   */
  name: string;
  /**
   * Object type. Accessor means that the property itself is an accessor property.
   */
  type:
    | "object"
    | "function"
    | "undefined"
    | "string"
    | "number"
    | "boolean"
    | "symbol"
    | "accessor"
    | "bigint";
  /**
   * User-friendly property value string.
   */
  value?: string;
  /**
   * Nested value preview.
   */
  valuePreview?: Runtime_ObjectPreview;
  /**
   * Object subtype hint. Specified for `object` type values only.
   */
  subtype?:
    | "array"
    | "null"
    | "node"
    | "regexp"
    | "date"
    | "map"
    | "set"
    | "weakmap"
    | "weakset"
    | "iterator"
    | "generator"
    | "error"
    | "proxy"
    | "promise"
    | "typedarray"
    | "arraybuffer"
    | "dataview"
    | "webassemblymemory"
    | "wasmvalue";
};

/**
 * @experimental
 */
export type Runtime_EntryPreview = {
  /**
   * Preview of the key. Specified for map-like collection entries.
   */
  key?: Runtime_ObjectPreview;
  /**
   * Preview of the value.
   */
  value: Runtime_ObjectPreview;
};

/**
 * Object property descriptor.
 */
export type Runtime_PropertyDescriptor = {
  /**
   * Property name or symbol description.
   */
  name: string;
  /**
   * The value associated with the property.
   */
  value?: Runtime_RemoteObject;
  /**
   * True if the value associated with the property may be changed (data descriptors only).
   */
  writable?: boolean;
  /**
   * A function which serves as a getter for the property, or `undefined` if there is no getter
   * (accessor descriptors only).
   */
  get?: Runtime_RemoteObject;
  /**
   * A function which serves as a setter for the property, or `undefined` if there is no setter
   * (accessor descriptors only).
   */
  set?: Runtime_RemoteObject;
  /**
   * True if the type of this property descriptor may be changed and if the property may be
   * deleted from the corresponding object.
   */
  configurable: boolean;
  /**
   * True if this property shows up during enumeration of the properties on the corresponding
   * object.
   */
  enumerable: boolean;
  /**
   * True if the result was thrown during the evaluation.
   */
  wasThrown?: boolean;
  /**
   * True if the property is owned for the object.
   */
  isOwn?: boolean;
  /**
   * Property symbol object, if the property is of the `symbol` type.
   */
  symbol?: Runtime_RemoteObject;
};

/**
 * Object internal property descriptor. This property isn't normally visible in JavaScript code.
 */
export type Runtime_InternalPropertyDescriptor = {
  /**
   * Conventional property name.
   */
  name: string;
  /**
   * The value associated with the property.
   */
  value?: Runtime_RemoteObject;
};

/**
 * @experimental
 * Object private field descriptor.
 */
export type Runtime_PrivatePropertyDescriptor = {
  /**
   * Private property name.
   */
  name: string;
  /**
   * The value associated with the private property.
   */
  value?: Runtime_RemoteObject;
  /**
   * A function which serves as a getter for the private property,
   * or `undefined` if there is no getter (accessor descriptors only).
   */
  get?: Runtime_RemoteObject;
  /**
   * A function which serves as a setter for the private property,
   * or `undefined` if there is no setter (accessor descriptors only).
   */
  set?: Runtime_RemoteObject;
};

/**
 * Represents function call argument. Either remote object id `objectId`, primitive `value`,
 * unserializable primitive value or neither of (for undefined) them should be specified.
 */
export type Runtime_CallArgument = {
  /**
   * Primitive value or serializable javascript object.
   */
  value?: any;
  /**
   * Primitive value which can not be JSON-stringified.
   */
  unserializableValue?: Runtime_UnserializableValue;
  /**
   * Remote object handle.
   */
  objectId?: Runtime_RemoteObjectId;
};

/**
 * Id of an execution context.
 */
export type Runtime_ExecutionContextId = number;

/**
 * Description of an isolated world.
 */
export type Runtime_ExecutionContextDescription = {
  /**
   * Unique id of the execution context. It can be used to specify in which execution context
   * script evaluation should be performed.
   */
  id: Runtime_ExecutionContextId;
  /**
   * Execution context origin.
   */
  origin: string;
  /**
   * Human readable name describing given context.
   */
  name: string;
  /**
   * @experimental
   * A system-unique execution context identifier. Unlike the id, this is unique across
   * multiple processes, so can be reliably used to identify specific context while backend
   * performs a cross-process navigation.
   */
  uniqueId: string;
  /**
   * Embedder-specific auxiliary data likely matching {isDefault: boolean, type: 'default'|'isolated'|'worker', frameId: string}
   */
  auxData?: object;
};

/**
 * Detailed information about exception (or error) that was thrown during script compilation or
 * execution.
 */
export type Runtime_ExceptionDetails = {
  /**
   * Exception id.
   */
  exceptionId: number;
  /**
   * Exception text, which should be used together with exception object when available.
   */
  text: string;
  /**
   * Line number of the exception location (0-based).
   */
  lineNumber: number;
  /**
   * Column number of the exception location (0-based).
   */
  columnNumber: number;
  /**
   * Script ID of the exception location.
   */
  scriptId?: Runtime_ScriptId;
  /**
   * URL of the exception location, to be used when the script was not reported.
   */
  url?: string;
  /**
   * JavaScript stack trace if available.
   */
  stackTrace?: Runtime_StackTrace;
  /**
   * Exception object if available.
   */
  exception?: Runtime_RemoteObject;
  /**
   * Identifier of the context where exception happened.
   */
  executionContextId?: Runtime_ExecutionContextId;
  /**
   * @experimental
   * Dictionary with entries of meta data that the client associated
   * with this exception, such as information about associated network
   * requests, etc.
   */
  exceptionMetaData?: object;
};

/**
 * Number of milliseconds since epoch.
 */
export type Runtime_Timestamp = number;

/**
 * Number of milliseconds.
 */
export type Runtime_TimeDelta = number;

/**
 * Stack entry for runtime errors and assertions.
 */
export type Runtime_CallFrame = {
  /**
   * JavaScript function name.
   */
  functionName: string;
  /**
   * JavaScript script id.
   */
  scriptId: Runtime_ScriptId;
  /**
   * JavaScript script name or url.
   */
  url: string;
  /**
   * JavaScript script line number (0-based).
   */
  lineNumber: number;
  /**
   * JavaScript script column number (0-based).
   */
  columnNumber: number;
};

/**
 * Call frames for assertions or error messages.
 */
export type Runtime_StackTrace = {
  /**
   * String label of this stack trace. For async traces this may be a name of the function that
   * initiated the async call.
   */
  description?: string;
  /**
   * JavaScript function name.
   */
  callFrames: Runtime_CallFrame[];
  /**
   * Asynchronous JavaScript stack trace that preceded this stack, if available.
   */
  parent?: Runtime_StackTrace;
  /**
   * @experimental
   * Asynchronous JavaScript stack trace that preceded this stack, if available.
   */
  parentId?: Runtime_StackTraceId;
};

/**
 * @experimental
 * Unique identifier of current debugger.
 */
export type Runtime_UniqueDebuggerId = string;

/**
 * @experimental
 * If `debuggerId` is set stack trace comes from another debugger and can be resolved there. This
 * allows to track cross-debugger calls. See `Runtime.StackTrace` and `Debugger.paused` for usages.
 */
export type Runtime_StackTraceId = {
  id: string;
  debuggerId?: Runtime_UniqueDebuggerId;
};

// ----------------- Schema Types -----------------

/**
 * Description of the protocol domain.
 */
export type Schema_Domain = {
  /**
   * Domain name.
   */
  name: string;
  /**
   * Domain version.
   */
  version: string;
};

export interface Accessibility_loadComplete {
  /**
   * New document root node.
   */
  root: Accessibility_AXNode;
}

export class Accessibility_loadCompleteEvent
  extends CustomEvent<Accessibility_loadComplete> {
  constructor(detail: Accessibility_loadComplete) {
    super("Accessibility.loadComplete", { detail });
  }
}

export interface Accessibility_nodesUpdated {
  /**
   * Updated node data.
   */
  nodes: Accessibility_AXNode[];
}

export class Accessibility_nodesUpdatedEvent
  extends CustomEvent<Accessibility_nodesUpdated> {
  constructor(detail: Accessibility_nodesUpdated) {
    super("Accessibility.nodesUpdated", { detail });
  }
}

export interface Animation_animationCanceled {
  /**
   * Id of the animation that was cancelled.
   */
  id: string;
}

export class Animation_animationCanceledEvent
  extends CustomEvent<Animation_animationCanceled> {
  constructor(detail: Animation_animationCanceled) {
    super("Animation.animationCanceled", { detail });
  }
}

export interface Animation_animationCreated {
  /**
   * Id of the animation that was created.
   */
  id: string;
}

export class Animation_animationCreatedEvent
  extends CustomEvent<Animation_animationCreated> {
  constructor(detail: Animation_animationCreated) {
    super("Animation.animationCreated", { detail });
  }
}

export interface Animation_animationStarted {
  /**
   * Animation that was started.
   */
  animation: Animation_Animation;
}

export class Animation_animationStartedEvent
  extends CustomEvent<Animation_animationStarted> {
  constructor(detail: Animation_animationStarted) {
    super("Animation.animationStarted", { detail });
  }
}

export interface Audits_issueAdded {
  issue: Audits_InspectorIssue;
}

export class Audits_issueAddedEvent extends CustomEvent<Audits_issueAdded> {
  constructor(detail: Audits_issueAdded) {
    super("Audits.issueAdded", { detail });
  }
}

export interface Autofill_addressFormFilled {
  /**
   * Information about the fields that were filled
   */
  filledFields: Autofill_FilledField[];
  /**
   * An UI representation of the address used to fill the form.
   * Consists of a 2D array where each child represents an address/profile line.
   */
  addressUi: Autofill_AddressUI;
}

export class Autofill_addressFormFilledEvent
  extends CustomEvent<Autofill_addressFormFilled> {
  constructor(detail: Autofill_addressFormFilled) {
    super("Autofill.addressFormFilled", { detail });
  }
}

export interface BackgroundService_recordingStateChanged {
  isRecording: boolean;
  service: BackgroundService_ServiceName;
}

export class BackgroundService_recordingStateChangedEvent
  extends CustomEvent<BackgroundService_recordingStateChanged> {
  constructor(detail: BackgroundService_recordingStateChanged) {
    super("BackgroundService.recordingStateChanged", { detail });
  }
}

export interface BackgroundService_backgroundServiceEventReceived {
  backgroundServiceEvent: BackgroundService_BackgroundServiceEvent;
}

export class BackgroundService_backgroundServiceEventReceivedEvent
  extends CustomEvent<BackgroundService_backgroundServiceEventReceived> {
  constructor(detail: BackgroundService_backgroundServiceEventReceived) {
    super("BackgroundService.backgroundServiceEventReceived", { detail });
  }
}

export interface Browser_downloadWillBegin {
  /**
   * Id of the frame that caused the download to begin.
   */
  frameId: Page_FrameId;
  /**
   * Global unique identifier of the download.
   */
  guid: string;
  /**
   * URL of the resource being downloaded.
   */
  url: string;
  /**
   * Suggested file name of the resource (the actual name of the file saved on disk may differ).
   */
  suggestedFilename: string;
}

export class Browser_downloadWillBeginEvent
  extends CustomEvent<Browser_downloadWillBegin> {
  constructor(detail: Browser_downloadWillBegin) {
    super("Browser.downloadWillBegin", { detail });
  }
}

export interface Browser_downloadProgress {
  /**
   * Global unique identifier of the download.
   */
  guid: string;
  /**
   * Total expected bytes to download.
   */
  totalBytes: number;
  /**
   * Total bytes received.
   */
  receivedBytes: number;
  /**
   * Download status.
   */
  state: "inProgress" | "completed" | "canceled";
}

export class Browser_downloadProgressEvent
  extends CustomEvent<Browser_downloadProgress> {
  constructor(detail: Browser_downloadProgress) {
    super("Browser.downloadProgress", { detail });
  }
}

export interface CSS_fontsUpdated {
  /**
   * The web font that has loaded.
   */
  font?: CSS_FontFace;
}

export class CSS_fontsUpdatedEvent extends CustomEvent<CSS_fontsUpdated> {
  constructor(detail: CSS_fontsUpdated) {
    super("CSS.fontsUpdated", { detail });
  }
}

export interface CSS_styleSheetAdded {
  /**
   * Added stylesheet metainfo.
   */
  header: CSS_CSSStyleSheetHeader;
}

export class CSS_styleSheetAddedEvent extends CustomEvent<CSS_styleSheetAdded> {
  constructor(detail: CSS_styleSheetAdded) {
    super("CSS.styleSheetAdded", { detail });
  }
}

export interface CSS_styleSheetChanged {
  styleSheetId: CSS_StyleSheetId;
}

export class CSS_styleSheetChangedEvent
  extends CustomEvent<CSS_styleSheetChanged> {
  constructor(detail: CSS_styleSheetChanged) {
    super("CSS.styleSheetChanged", { detail });
  }
}

export interface CSS_styleSheetRemoved {
  /**
   * Identifier of the removed stylesheet.
   */
  styleSheetId: CSS_StyleSheetId;
}

export class CSS_styleSheetRemovedEvent
  extends CustomEvent<CSS_styleSheetRemoved> {
  constructor(detail: CSS_styleSheetRemoved) {
    super("CSS.styleSheetRemoved", { detail });
  }
}

export interface Cast_sinksUpdated {
  sinks: Cast_Sink[];
}

export class Cast_sinksUpdatedEvent extends CustomEvent<Cast_sinksUpdated> {
  constructor(detail: Cast_sinksUpdated) {
    super("Cast.sinksUpdated", { detail });
  }
}

export interface Cast_issueUpdated {
  issueMessage: string;
}

export class Cast_issueUpdatedEvent extends CustomEvent<Cast_issueUpdated> {
  constructor(detail: Cast_issueUpdated) {
    super("Cast.issueUpdated", { detail });
  }
}

export interface DOM_attributeModified {
  /**
   * Id of the node that has changed.
   */
  nodeId: DOM_NodeId;
  /**
   * Attribute name.
   */
  name: string;
  /**
   * Attribute value.
   */
  value: string;
}

export class DOM_attributeModifiedEvent
  extends CustomEvent<DOM_attributeModified> {
  constructor(detail: DOM_attributeModified) {
    super("DOM.attributeModified", { detail });
  }
}

export interface DOM_attributeRemoved {
  /**
   * Id of the node that has changed.
   */
  nodeId: DOM_NodeId;
  /**
   * A ttribute name.
   */
  name: string;
}

export class DOM_attributeRemovedEvent
  extends CustomEvent<DOM_attributeRemoved> {
  constructor(detail: DOM_attributeRemoved) {
    super("DOM.attributeRemoved", { detail });
  }
}

export interface DOM_characterDataModified {
  /**
   * Id of the node that has changed.
   */
  nodeId: DOM_NodeId;
  /**
   * New text value.
   */
  characterData: string;
}

export class DOM_characterDataModifiedEvent
  extends CustomEvent<DOM_characterDataModified> {
  constructor(detail: DOM_characterDataModified) {
    super("DOM.characterDataModified", { detail });
  }
}

export interface DOM_childNodeCountUpdated {
  /**
   * Id of the node that has changed.
   */
  nodeId: DOM_NodeId;
  /**
   * New node count.
   */
  childNodeCount: number;
}

export class DOM_childNodeCountUpdatedEvent
  extends CustomEvent<DOM_childNodeCountUpdated> {
  constructor(detail: DOM_childNodeCountUpdated) {
    super("DOM.childNodeCountUpdated", { detail });
  }
}

export interface DOM_childNodeInserted {
  /**
   * Id of the node that has changed.
   */
  parentNodeId: DOM_NodeId;
  /**
   * Id of the previous sibling.
   */
  previousNodeId: DOM_NodeId;
  /**
   * Inserted node data.
   */
  node: DOM_Node;
}

export class DOM_childNodeInsertedEvent
  extends CustomEvent<DOM_childNodeInserted> {
  constructor(detail: DOM_childNodeInserted) {
    super("DOM.childNodeInserted", { detail });
  }
}

export interface DOM_childNodeRemoved {
  /**
   * Parent id.
   */
  parentNodeId: DOM_NodeId;
  /**
   * Id of the node that has been removed.
   */
  nodeId: DOM_NodeId;
}

export class DOM_childNodeRemovedEvent
  extends CustomEvent<DOM_childNodeRemoved> {
  constructor(detail: DOM_childNodeRemoved) {
    super("DOM.childNodeRemoved", { detail });
  }
}

export interface DOM_distributedNodesUpdated {
  /**
   * Insertion point where distributed nodes were updated.
   */
  insertionPointId: DOM_NodeId;
  /**
   * Distributed nodes for given insertion point.
   */
  distributedNodes: DOM_BackendNode[];
}

export class DOM_distributedNodesUpdatedEvent
  extends CustomEvent<DOM_distributedNodesUpdated> {
  constructor(detail: DOM_distributedNodesUpdated) {
    super("DOM.distributedNodesUpdated", { detail });
  }
}

export interface DOM_inlineStyleInvalidated {
  /**
   * Ids of the nodes for which the inline styles have been invalidated.
   */
  nodeIds: DOM_NodeId[];
}

export class DOM_inlineStyleInvalidatedEvent
  extends CustomEvent<DOM_inlineStyleInvalidated> {
  constructor(detail: DOM_inlineStyleInvalidated) {
    super("DOM.inlineStyleInvalidated", { detail });
  }
}

export interface DOM_pseudoElementAdded {
  /**
   * Pseudo element's parent element id.
   */
  parentId: DOM_NodeId;
  /**
   * The added pseudo element.
   */
  pseudoElement: DOM_Node;
}

export class DOM_pseudoElementAddedEvent
  extends CustomEvent<DOM_pseudoElementAdded> {
  constructor(detail: DOM_pseudoElementAdded) {
    super("DOM.pseudoElementAdded", { detail });
  }
}

export interface DOM_pseudoElementRemoved {
  /**
   * Pseudo element's parent element id.
   */
  parentId: DOM_NodeId;
  /**
   * The removed pseudo element id.
   */
  pseudoElementId: DOM_NodeId;
}

export class DOM_pseudoElementRemovedEvent
  extends CustomEvent<DOM_pseudoElementRemoved> {
  constructor(detail: DOM_pseudoElementRemoved) {
    super("DOM.pseudoElementRemoved", { detail });
  }
}

export interface DOM_setChildNodes {
  /**
   * Parent node id to populate with children.
   */
  parentId: DOM_NodeId;
  /**
   * Child nodes array.
   */
  nodes: DOM_Node[];
}

export class DOM_setChildNodesEvent extends CustomEvent<DOM_setChildNodes> {
  constructor(detail: DOM_setChildNodes) {
    super("DOM.setChildNodes", { detail });
  }
}

export interface DOM_shadowRootPopped {
  /**
   * Host element id.
   */
  hostId: DOM_NodeId;
  /**
   * Shadow root id.
   */
  rootId: DOM_NodeId;
}

export class DOM_shadowRootPoppedEvent
  extends CustomEvent<DOM_shadowRootPopped> {
  constructor(detail: DOM_shadowRootPopped) {
    super("DOM.shadowRootPopped", { detail });
  }
}

export interface DOM_shadowRootPushed {
  /**
   * Host element id.
   */
  hostId: DOM_NodeId;
  /**
   * Shadow root.
   */
  root: DOM_Node;
}

export class DOM_shadowRootPushedEvent
  extends CustomEvent<DOM_shadowRootPushed> {
  constructor(detail: DOM_shadowRootPushed) {
    super("DOM.shadowRootPushed", { detail });
  }
}

export interface DOMStorage_domStorageItemAdded {
  storageId: DOMStorage_StorageId;
  key: string;
  newValue: string;
}

export class DOMStorage_domStorageItemAddedEvent
  extends CustomEvent<DOMStorage_domStorageItemAdded> {
  constructor(detail: DOMStorage_domStorageItemAdded) {
    super("DOMStorage.domStorageItemAdded", { detail });
  }
}

export interface DOMStorage_domStorageItemRemoved {
  storageId: DOMStorage_StorageId;
  key: string;
}

export class DOMStorage_domStorageItemRemovedEvent
  extends CustomEvent<DOMStorage_domStorageItemRemoved> {
  constructor(detail: DOMStorage_domStorageItemRemoved) {
    super("DOMStorage.domStorageItemRemoved", { detail });
  }
}

export interface DOMStorage_domStorageItemUpdated {
  storageId: DOMStorage_StorageId;
  key: string;
  oldValue: string;
  newValue: string;
}

export class DOMStorage_domStorageItemUpdatedEvent
  extends CustomEvent<DOMStorage_domStorageItemUpdated> {
  constructor(detail: DOMStorage_domStorageItemUpdated) {
    super("DOMStorage.domStorageItemUpdated", { detail });
  }
}

export interface DOMStorage_domStorageItemsCleared {
  storageId: DOMStorage_StorageId;
}

export class DOMStorage_domStorageItemsClearedEvent
  extends CustomEvent<DOMStorage_domStorageItemsCleared> {
  constructor(detail: DOMStorage_domStorageItemsCleared) {
    super("DOMStorage.domStorageItemsCleared", { detail });
  }
}

export interface Database_addDatabase {
  database: Database_Database;
}

export class Database_addDatabaseEvent
  extends CustomEvent<Database_addDatabase> {
  constructor(detail: Database_addDatabase) {
    super("Database.addDatabase", { detail });
  }
}

export interface Input_dragIntercepted {
  data: Input_DragData;
}

export class Input_dragInterceptedEvent
  extends CustomEvent<Input_dragIntercepted> {
  constructor(detail: Input_dragIntercepted) {
    super("Input.dragIntercepted", { detail });
  }
}

export interface Inspector_detached {
  /**
   * The reason why connection has been terminated.
   */
  reason: string;
}

export class Inspector_detachedEvent extends CustomEvent<Inspector_detached> {
  constructor(detail: Inspector_detached) {
    super("Inspector.detached", { detail });
  }
}

export interface LayerTree_layerPainted {
  /**
   * The id of the painted layer.
   */
  layerId: LayerTree_LayerId;
  /**
   * Clip rectangle.
   */
  clip: DOM_Rect;
}

export class LayerTree_layerPaintedEvent
  extends CustomEvent<LayerTree_layerPainted> {
  constructor(detail: LayerTree_layerPainted) {
    super("LayerTree.layerPainted", { detail });
  }
}

export interface LayerTree_layerTreeDidChange {
  /**
   * Layer tree, absent if not in the compositing mode.
   */
  layers?: LayerTree_Layer[];
}

export class LayerTree_layerTreeDidChangeEvent
  extends CustomEvent<LayerTree_layerTreeDidChange> {
  constructor(detail: LayerTree_layerTreeDidChange) {
    super("LayerTree.layerTreeDidChange", { detail });
  }
}

export interface Log_entryAdded {
  /**
   * The entry.
   */
  entry: Log_LogEntry;
}

export class Log_entryAddedEvent extends CustomEvent<Log_entryAdded> {
  constructor(detail: Log_entryAdded) {
    super("Log.entryAdded", { detail });
  }
}

export interface Network_dataReceived {
  /**
   * Request identifier.
   */
  requestId: Network_RequestId;
  /**
   * Timestamp.
   */
  timestamp: Network_MonotonicTime;
  /**
   * Data chunk length.
   */
  dataLength: number;
  /**
   * Actual bytes received (might be less than dataLength for compressed encodings).
   */
  encodedDataLength: number;
  /**
   * @experimental
   * Data that was received.
   */
  data?: string;
}

export class Network_dataReceivedEvent
  extends CustomEvent<Network_dataReceived> {
  constructor(detail: Network_dataReceived) {
    super("Network.dataReceived", { detail });
  }
}

export interface Network_eventSourceMessageReceived {
  /**
   * Request identifier.
   */
  requestId: Network_RequestId;
  /**
   * Timestamp.
   */
  timestamp: Network_MonotonicTime;
  /**
   * Message type.
   */
  eventName: string;
  /**
   * Message identifier.
   */
  eventId: string;
  /**
   * Message content.
   */
  data: string;
}

export class Network_eventSourceMessageReceivedEvent
  extends CustomEvent<Network_eventSourceMessageReceived> {
  constructor(detail: Network_eventSourceMessageReceived) {
    super("Network.eventSourceMessageReceived", { detail });
  }
}

export interface Network_loadingFailed {
  /**
   * Request identifier.
   */
  requestId: Network_RequestId;
  /**
   * Timestamp.
   */
  timestamp: Network_MonotonicTime;
  /**
   * Resource type.
   */
  type: Network_ResourceType;
  /**
   * Error message. List of network errors: https://cs.chromium.org/chromium/src/net/base/net_error_list.h
   */
  errorText: string;
  /**
   * True if loading was canceled.
   */
  canceled?: boolean;
  /**
   * The reason why loading was blocked, if any.
   */
  blockedReason?: Network_BlockedReason;
  /**
   * The reason why loading was blocked by CORS, if any.
   */
  corsErrorStatus?: Network_CorsErrorStatus;
}

export class Network_loadingFailedEvent
  extends CustomEvent<Network_loadingFailed> {
  constructor(detail: Network_loadingFailed) {
    super("Network.loadingFailed", { detail });
  }
}

export interface Network_loadingFinished {
  /**
   * Request identifier.
   */
  requestId: Network_RequestId;
  /**
   * Timestamp.
   */
  timestamp: Network_MonotonicTime;
  /**
   * Total number of bytes received for this request.
   */
  encodedDataLength: number;
}

export class Network_loadingFinishedEvent
  extends CustomEvent<Network_loadingFinished> {
  constructor(detail: Network_loadingFinished) {
    super("Network.loadingFinished", { detail });
  }
}

export interface Network_requestIntercepted {
  /**
   * Each request the page makes will have a unique id, however if any redirects are encountered
   * while processing that fetch, they will be reported with the same id as the original fetch.
   * Likewise if HTTP authentication is needed then the same fetch id will be used.
   */
  interceptionId: Network_InterceptionId;
  request: Network_Request;
  /**
   * The id of the frame that initiated the request.
   */
  frameId: Page_FrameId;
  /**
   * How the requested resource will be used.
   */
  resourceType: Network_ResourceType;
  /**
   * Whether this is a navigation request, which can abort the navigation completely.
   */
  isNavigationRequest: boolean;
  /**
   * Set if the request is a navigation that will result in a download.
   * Only present after response is received from the server (i.e. HeadersReceived stage).
   */
  isDownload?: boolean;
  /**
   * Redirect location, only sent if a redirect was intercepted.
   */
  redirectUrl?: string;
  /**
   * Details of the Authorization Challenge encountered. If this is set then
   * continueInterceptedRequest must contain an authChallengeResponse.
   */
  authChallenge?: Network_AuthChallenge;
  /**
   * Response error if intercepted at response stage or if redirect occurred while intercepting
   * request.
   */
  responseErrorReason?: Network_ErrorReason;
  /**
   * Response code if intercepted at response stage or if redirect occurred while intercepting
   * request or auth retry occurred.
   */
  responseStatusCode?: number;
  /**
   * Response headers if intercepted at the response stage or if redirect occurred while
   * intercepting request or auth retry occurred.
   */
  responseHeaders?: Network_Headers;
  /**
   * If the intercepted request had a corresponding requestWillBeSent event fired for it, then
   * this requestId will be the same as the requestId present in the requestWillBeSent event.
   */
  requestId?: Network_RequestId;
}

export class Network_requestInterceptedEvent
  extends CustomEvent<Network_requestIntercepted> {
  constructor(detail: Network_requestIntercepted) {
    super("Network.requestIntercepted", { detail });
  }
}

export interface Network_requestServedFromCache {
  /**
   * Request identifier.
   */
  requestId: Network_RequestId;
}

export class Network_requestServedFromCacheEvent
  extends CustomEvent<Network_requestServedFromCache> {
  constructor(detail: Network_requestServedFromCache) {
    super("Network.requestServedFromCache", { detail });
  }
}

export interface Network_requestWillBeSent {
  /**
   * Request identifier.
   */
  requestId: Network_RequestId;
  /**
   * Loader identifier. Empty string if the request is fetched from worker.
   */
  loaderId: Network_LoaderId;
  /**
   * URL of the document this request is loaded for.
   */
  documentURL: string;
  /**
   * Request data.
   */
  request: Network_Request;
  /**
   * Timestamp.
   */
  timestamp: Network_MonotonicTime;
  /**
   * Timestamp.
   */
  wallTime: Network_TimeSinceEpoch;
  /**
   * Request initiator.
   */
  initiator: Network_Initiator;
  /**
   * @experimental
   * In the case that redirectResponse is populated, this flag indicates whether
   * requestWillBeSentExtraInfo and responseReceivedExtraInfo events will be or were emitted
   * for the request which was just redirected.
   */
  redirectHasExtraInfo: boolean;
  /**
   * Redirect response data.
   */
  redirectResponse?: Network_Response;
  /**
   * Type of this resource.
   */
  type?: Network_ResourceType;
  /**
   * Frame identifier.
   */
  frameId?: Page_FrameId;
  /**
   * Whether the request is initiated by a user gesture. Defaults to false.
   */
  hasUserGesture?: boolean;
}

export class Network_requestWillBeSentEvent
  extends CustomEvent<Network_requestWillBeSent> {
  constructor(detail: Network_requestWillBeSent) {
    super("Network.requestWillBeSent", { detail });
  }
}

export interface Network_resourceChangedPriority {
  /**
   * Request identifier.
   */
  requestId: Network_RequestId;
  /**
   * New priority
   */
  newPriority: Network_ResourcePriority;
  /**
   * Timestamp.
   */
  timestamp: Network_MonotonicTime;
}

export class Network_resourceChangedPriorityEvent
  extends CustomEvent<Network_resourceChangedPriority> {
  constructor(detail: Network_resourceChangedPriority) {
    super("Network.resourceChangedPriority", { detail });
  }
}

export interface Network_signedExchangeReceived {
  /**
   * Request identifier.
   */
  requestId: Network_RequestId;
  /**
   * Information about the signed exchange response.
   */
  info: Network_SignedExchangeInfo;
}

export class Network_signedExchangeReceivedEvent
  extends CustomEvent<Network_signedExchangeReceived> {
  constructor(detail: Network_signedExchangeReceived) {
    super("Network.signedExchangeReceived", { detail });
  }
}

export interface Network_responseReceived {
  /**
   * Request identifier.
   */
  requestId: Network_RequestId;
  /**
   * Loader identifier. Empty string if the request is fetched from worker.
   */
  loaderId: Network_LoaderId;
  /**
   * Timestamp.
   */
  timestamp: Network_MonotonicTime;
  /**
   * Resource type.
   */
  type: Network_ResourceType;
  /**
   * Response data.
   */
  response: Network_Response;
  /**
   * @experimental
   * Indicates whether requestWillBeSentExtraInfo and responseReceivedExtraInfo events will be
   * or were emitted for this request.
   */
  hasExtraInfo: boolean;
  /**
   * Frame identifier.
   */
  frameId?: Page_FrameId;
}

export class Network_responseReceivedEvent
  extends CustomEvent<Network_responseReceived> {
  constructor(detail: Network_responseReceived) {
    super("Network.responseReceived", { detail });
  }
}

export interface Network_webSocketClosed {
  /**
   * Request identifier.
   */
  requestId: Network_RequestId;
  /**
   * Timestamp.
   */
  timestamp: Network_MonotonicTime;
}

export class Network_webSocketClosedEvent
  extends CustomEvent<Network_webSocketClosed> {
  constructor(detail: Network_webSocketClosed) {
    super("Network.webSocketClosed", { detail });
  }
}

export interface Network_webSocketCreated {
  /**
   * Request identifier.
   */
  requestId: Network_RequestId;
  /**
   * WebSocket request URL.
   */
  url: string;
  /**
   * Request initiator.
   */
  initiator?: Network_Initiator;
}

export class Network_webSocketCreatedEvent
  extends CustomEvent<Network_webSocketCreated> {
  constructor(detail: Network_webSocketCreated) {
    super("Network.webSocketCreated", { detail });
  }
}

export interface Network_webSocketFrameError {
  /**
   * Request identifier.
   */
  requestId: Network_RequestId;
  /**
   * Timestamp.
   */
  timestamp: Network_MonotonicTime;
  /**
   * WebSocket error message.
   */
  errorMessage: string;
}

export class Network_webSocketFrameErrorEvent
  extends CustomEvent<Network_webSocketFrameError> {
  constructor(detail: Network_webSocketFrameError) {
    super("Network.webSocketFrameError", { detail });
  }
}

export interface Network_webSocketFrameReceived {
  /**
   * Request identifier.
   */
  requestId: Network_RequestId;
  /**
   * Timestamp.
   */
  timestamp: Network_MonotonicTime;
  /**
   * WebSocket response data.
   */
  response: Network_WebSocketFrame;
}

export class Network_webSocketFrameReceivedEvent
  extends CustomEvent<Network_webSocketFrameReceived> {
  constructor(detail: Network_webSocketFrameReceived) {
    super("Network.webSocketFrameReceived", { detail });
  }
}

export interface Network_webSocketFrameSent {
  /**
   * Request identifier.
   */
  requestId: Network_RequestId;
  /**
   * Timestamp.
   */
  timestamp: Network_MonotonicTime;
  /**
   * WebSocket response data.
   */
  response: Network_WebSocketFrame;
}

export class Network_webSocketFrameSentEvent
  extends CustomEvent<Network_webSocketFrameSent> {
  constructor(detail: Network_webSocketFrameSent) {
    super("Network.webSocketFrameSent", { detail });
  }
}

export interface Network_webSocketHandshakeResponseReceived {
  /**
   * Request identifier.
   */
  requestId: Network_RequestId;
  /**
   * Timestamp.
   */
  timestamp: Network_MonotonicTime;
  /**
   * WebSocket response data.
   */
  response: Network_WebSocketResponse;
}

export class Network_webSocketHandshakeResponseReceivedEvent
  extends CustomEvent<Network_webSocketHandshakeResponseReceived> {
  constructor(detail: Network_webSocketHandshakeResponseReceived) {
    super("Network.webSocketHandshakeResponseReceived", { detail });
  }
}

export interface Network_webSocketWillSendHandshakeRequest {
  /**
   * Request identifier.
   */
  requestId: Network_RequestId;
  /**
   * Timestamp.
   */
  timestamp: Network_MonotonicTime;
  /**
   * UTC Timestamp.
   */
  wallTime: Network_TimeSinceEpoch;
  /**
   * WebSocket request data.
   */
  request: Network_WebSocketRequest;
}

export class Network_webSocketWillSendHandshakeRequestEvent
  extends CustomEvent<Network_webSocketWillSendHandshakeRequest> {
  constructor(detail: Network_webSocketWillSendHandshakeRequest) {
    super("Network.webSocketWillSendHandshakeRequest", { detail });
  }
}

export interface Network_webTransportCreated {
  /**
   * WebTransport identifier.
   */
  transportId: Network_RequestId;
  /**
   * WebTransport request URL.
   */
  url: string;
  /**
   * Timestamp.
   */
  timestamp: Network_MonotonicTime;
  /**
   * Request initiator.
   */
  initiator?: Network_Initiator;
}

export class Network_webTransportCreatedEvent
  extends CustomEvent<Network_webTransportCreated> {
  constructor(detail: Network_webTransportCreated) {
    super("Network.webTransportCreated", { detail });
  }
}

export interface Network_webTransportConnectionEstablished {
  /**
   * WebTransport identifier.
   */
  transportId: Network_RequestId;
  /**
   * Timestamp.
   */
  timestamp: Network_MonotonicTime;
}

export class Network_webTransportConnectionEstablishedEvent
  extends CustomEvent<Network_webTransportConnectionEstablished> {
  constructor(detail: Network_webTransportConnectionEstablished) {
    super("Network.webTransportConnectionEstablished", { detail });
  }
}

export interface Network_webTransportClosed {
  /**
   * WebTransport identifier.
   */
  transportId: Network_RequestId;
  /**
   * Timestamp.
   */
  timestamp: Network_MonotonicTime;
}

export class Network_webTransportClosedEvent
  extends CustomEvent<Network_webTransportClosed> {
  constructor(detail: Network_webTransportClosed) {
    super("Network.webTransportClosed", { detail });
  }
}

export interface Network_requestWillBeSentExtraInfo {
  /**
   * Request identifier. Used to match this information to an existing requestWillBeSent event.
   */
  requestId: Network_RequestId;
  /**
   * A list of cookies potentially associated to the requested URL. This includes both cookies sent with
   * the request and the ones not sent; the latter are distinguished by having blockedReasons field set.
   */
  associatedCookies: Network_AssociatedCookie[];
  /**
   * Raw request headers as they will be sent over the wire.
   */
  headers: Network_Headers;
  /**
   * @experimental
   * Connection timing information for the request.
   */
  connectTiming: Network_ConnectTiming;
  /**
   * The client security state set for the request.
   */
  clientSecurityState?: Network_ClientSecurityState;
  /**
   * Whether the site has partitioned cookies stored in a partition different than the current one.
   */
  siteHasCookieInOtherPartition?: boolean;
}

export class Network_requestWillBeSentExtraInfoEvent
  extends CustomEvent<Network_requestWillBeSentExtraInfo> {
  constructor(detail: Network_requestWillBeSentExtraInfo) {
    super("Network.requestWillBeSentExtraInfo", { detail });
  }
}

export interface Network_responseReceivedExtraInfo {
  /**
   * Request identifier. Used to match this information to another responseReceived event.
   */
  requestId: Network_RequestId;
  /**
   * A list of cookies which were not stored from the response along with the corresponding
   * reasons for blocking. The cookies here may not be valid due to syntax errors, which
   * are represented by the invalid cookie line string instead of a proper cookie.
   */
  blockedCookies: Network_BlockedSetCookieWithReason[];
  /**
   * Raw response headers as they were received over the wire.
   */
  headers: Network_Headers;
  /**
   * The IP address space of the resource. The address space can only be determined once the transport
   * established the connection, so we can't send it in `requestWillBeSentExtraInfo`.
   */
  resourceIPAddressSpace: Network_IPAddressSpace;
  /**
   * The status code of the response. This is useful in cases the request failed and no responseReceived
   * event is triggered, which is the case for, e.g., CORS errors. This is also the correct status code
   * for cached requests, where the status in responseReceived is a 200 and this will be 304.
   */
  statusCode: number;
  /**
   * Raw response header text as it was received over the wire. The raw text may not always be
   * available, such as in the case of HTTP/2 or QUIC.
   */
  headersText?: string;
  /**
   * The cookie partition key that will be used to store partitioned cookies set in this response.
   * Only sent when partitioned cookies are enabled.
   */
  cookiePartitionKey?: string;
  /**
   * True if partitioned cookies are enabled, but the partition key is not serializable to string.
   */
  cookiePartitionKeyOpaque?: boolean;
  /**
   * A list of cookies which should have been blocked by 3PCD but are exempted and stored from
   * the response with the corresponding reason.
   */
  exemptedCookies?: Network_ExemptedSetCookieWithReason[];
}

export class Network_responseReceivedExtraInfoEvent
  extends CustomEvent<Network_responseReceivedExtraInfo> {
  constructor(detail: Network_responseReceivedExtraInfo) {
    super("Network.responseReceivedExtraInfo", { detail });
  }
}

export interface Network_responseReceivedEarlyHints {
  /**
   * Request identifier. Used to match this information to another responseReceived event.
   */
  requestId: Network_RequestId;
  /**
   * Raw response headers as they were received over the wire.
   */
  headers: Network_Headers;
}

export class Network_responseReceivedEarlyHintsEvent
  extends CustomEvent<Network_responseReceivedEarlyHints> {
  constructor(detail: Network_responseReceivedEarlyHints) {
    super("Network.responseReceivedEarlyHints", { detail });
  }
}

export interface Network_trustTokenOperationDone {
  /**
   * Detailed success or error status of the operation.
   * 'AlreadyExists' also signifies a successful operation, as the result
   * of the operation already exists und thus, the operation was abort
   * preemptively (e.g. a cache hit).
   */
  status:
    | "Ok"
    | "InvalidArgument"
    | "MissingIssuerKeys"
    | "FailedPrecondition"
    | "ResourceExhausted"
    | "AlreadyExists"
    | "Unavailable"
    | "Unauthorized"
    | "BadResponse"
    | "InternalError"
    | "UnknownError"
    | "FulfilledLocally";
  type: Network_TrustTokenOperationType;
  requestId: Network_RequestId;
  /**
   * Top level origin. The context in which the operation was attempted.
   */
  topLevelOrigin?: string;
  /**
   * Origin of the issuer in case of a "Issuance" or "Redemption" operation.
   */
  issuerOrigin?: string;
  /**
   * The number of obtained Trust Tokens on a successful "Issuance" operation.
   */
  issuedTokenCount?: number;
}

export class Network_trustTokenOperationDoneEvent
  extends CustomEvent<Network_trustTokenOperationDone> {
  constructor(detail: Network_trustTokenOperationDone) {
    super("Network.trustTokenOperationDone", { detail });
  }
}

export interface Network_subresourceWebBundleMetadataReceived {
  /**
   * Request identifier. Used to match this information to another event.
   */
  requestId: Network_RequestId;
  /**
   * A list of URLs of resources in the subresource Web Bundle.
   */
  urls: string[];
}

export class Network_subresourceWebBundleMetadataReceivedEvent
  extends CustomEvent<Network_subresourceWebBundleMetadataReceived> {
  constructor(detail: Network_subresourceWebBundleMetadataReceived) {
    super("Network.subresourceWebBundleMetadataReceived", { detail });
  }
}

export interface Network_subresourceWebBundleMetadataError {
  /**
   * Request identifier. Used to match this information to another event.
   */
  requestId: Network_RequestId;
  /**
   * Error message
   */
  errorMessage: string;
}

export class Network_subresourceWebBundleMetadataErrorEvent
  extends CustomEvent<Network_subresourceWebBundleMetadataError> {
  constructor(detail: Network_subresourceWebBundleMetadataError) {
    super("Network.subresourceWebBundleMetadataError", { detail });
  }
}

export interface Network_subresourceWebBundleInnerResponseParsed {
  /**
   * Request identifier of the subresource request
   */
  innerRequestId: Network_RequestId;
  /**
   * URL of the subresource resource.
   */
  innerRequestURL: string;
  /**
   * Bundle request identifier. Used to match this information to another event.
   * This made be absent in case when the instrumentation was enabled only
   * after webbundle was parsed.
   */
  bundleRequestId?: Network_RequestId;
}

export class Network_subresourceWebBundleInnerResponseParsedEvent
  extends CustomEvent<Network_subresourceWebBundleInnerResponseParsed> {
  constructor(detail: Network_subresourceWebBundleInnerResponseParsed) {
    super("Network.subresourceWebBundleInnerResponseParsed", { detail });
  }
}

export interface Network_subresourceWebBundleInnerResponseError {
  /**
   * Request identifier of the subresource request
   */
  innerRequestId: Network_RequestId;
  /**
   * URL of the subresource resource.
   */
  innerRequestURL: string;
  /**
   * Error message
   */
  errorMessage: string;
  /**
   * Bundle request identifier. Used to match this information to another event.
   * This made be absent in case when the instrumentation was enabled only
   * after webbundle was parsed.
   */
  bundleRequestId?: Network_RequestId;
}

export class Network_subresourceWebBundleInnerResponseErrorEvent
  extends CustomEvent<Network_subresourceWebBundleInnerResponseError> {
  constructor(detail: Network_subresourceWebBundleInnerResponseError) {
    super("Network.subresourceWebBundleInnerResponseError", { detail });
  }
}

export interface Network_reportingApiReportAdded {
  report: Network_ReportingApiReport;
}

export class Network_reportingApiReportAddedEvent
  extends CustomEvent<Network_reportingApiReportAdded> {
  constructor(detail: Network_reportingApiReportAdded) {
    super("Network.reportingApiReportAdded", { detail });
  }
}

export interface Network_reportingApiReportUpdated {
  report: Network_ReportingApiReport;
}

export class Network_reportingApiReportUpdatedEvent
  extends CustomEvent<Network_reportingApiReportUpdated> {
  constructor(detail: Network_reportingApiReportUpdated) {
    super("Network.reportingApiReportUpdated", { detail });
  }
}

export interface Network_reportingApiEndpointsChangedForOrigin {
  /**
   * Origin of the document(s) which configured the endpoints.
   */
  origin: string;
  endpoints: Network_ReportingApiEndpoint[];
}

export class Network_reportingApiEndpointsChangedForOriginEvent
  extends CustomEvent<Network_reportingApiEndpointsChangedForOrigin> {
  constructor(detail: Network_reportingApiEndpointsChangedForOrigin) {
    super("Network.reportingApiEndpointsChangedForOrigin", { detail });
  }
}

export interface Overlay_inspectNodeRequested {
  /**
   * Id of the node to inspect.
   */
  backendNodeId: DOM_BackendNodeId;
}

export class Overlay_inspectNodeRequestedEvent
  extends CustomEvent<Overlay_inspectNodeRequested> {
  constructor(detail: Overlay_inspectNodeRequested) {
    super("Overlay.inspectNodeRequested", { detail });
  }
}

export interface Overlay_nodeHighlightRequested {
  nodeId: DOM_NodeId;
}

export class Overlay_nodeHighlightRequestedEvent
  extends CustomEvent<Overlay_nodeHighlightRequested> {
  constructor(detail: Overlay_nodeHighlightRequested) {
    super("Overlay.nodeHighlightRequested", { detail });
  }
}

export interface Overlay_screenshotRequested {
  /**
   * Viewport to capture, in device independent pixels (dip).
   */
  viewport: Page_Viewport;
}

export class Overlay_screenshotRequestedEvent
  extends CustomEvent<Overlay_screenshotRequested> {
  constructor(detail: Overlay_screenshotRequested) {
    super("Overlay.screenshotRequested", { detail });
  }
}

export interface Page_domContentEventFired {
  timestamp: Network_MonotonicTime;
}

export class Page_domContentEventFiredEvent
  extends CustomEvent<Page_domContentEventFired> {
  constructor(detail: Page_domContentEventFired) {
    super("Page.domContentEventFired", { detail });
  }
}

export interface Page_fileChooserOpened {
  /**
   * @experimental
   * Id of the frame containing input node.
   */
  frameId: Page_FrameId;
  /**
   * Input mode.
   */
  mode: "selectSingle" | "selectMultiple";
  /**
   * @experimental
   * Input node id. Only present for file choosers opened via an `<input type="file">` element.
   */
  backendNodeId?: DOM_BackendNodeId;
}

export class Page_fileChooserOpenedEvent
  extends CustomEvent<Page_fileChooserOpened> {
  constructor(detail: Page_fileChooserOpened) {
    super("Page.fileChooserOpened", { detail });
  }
}

export interface Page_frameAttached {
  /**
   * Id of the frame that has been attached.
   */
  frameId: Page_FrameId;
  /**
   * Parent frame identifier.
   */
  parentFrameId: Page_FrameId;
  /**
   * JavaScript stack trace of when frame was attached, only set if frame initiated from script.
   */
  stack?: Runtime_StackTrace;
}

export class Page_frameAttachedEvent extends CustomEvent<Page_frameAttached> {
  constructor(detail: Page_frameAttached) {
    super("Page.frameAttached", { detail });
  }
}

export interface Page_frameClearedScheduledNavigation {
  /**
   * Id of the frame that has cleared its scheduled navigation.
   */
  frameId: Page_FrameId;
}

export class Page_frameClearedScheduledNavigationEvent
  extends CustomEvent<Page_frameClearedScheduledNavigation> {
  constructor(detail: Page_frameClearedScheduledNavigation) {
    super("Page.frameClearedScheduledNavigation", { detail });
  }
}

export interface Page_frameDetached {
  /**
   * Id of the frame that has been detached.
   */
  frameId: Page_FrameId;
  /**
   * @experimental
   */
  reason: "remove" | "swap";
}

export class Page_frameDetachedEvent extends CustomEvent<Page_frameDetached> {
  constructor(detail: Page_frameDetached) {
    super("Page.frameDetached", { detail });
  }
}

export interface Page_frameNavigated {
  /**
   * Frame object.
   */
  frame: Page_Frame;
  /**
   * @experimental
   */
  type: Page_NavigationType;
}

export class Page_frameNavigatedEvent extends CustomEvent<Page_frameNavigated> {
  constructor(detail: Page_frameNavigated) {
    super("Page.frameNavigated", { detail });
  }
}

export interface Page_documentOpened {
  /**
   * Frame object.
   */
  frame: Page_Frame;
}

export class Page_documentOpenedEvent extends CustomEvent<Page_documentOpened> {
  constructor(detail: Page_documentOpened) {
    super("Page.documentOpened", { detail });
  }
}

export interface Page_frameRequestedNavigation {
  /**
   * Id of the frame that is being navigated.
   */
  frameId: Page_FrameId;
  /**
   * The reason for the navigation.
   */
  reason: Page_ClientNavigationReason;
  /**
   * The destination URL for the requested navigation.
   */
  url: string;
  /**
   * The disposition for the navigation.
   */
  disposition: Page_ClientNavigationDisposition;
}

export class Page_frameRequestedNavigationEvent
  extends CustomEvent<Page_frameRequestedNavigation> {
  constructor(detail: Page_frameRequestedNavigation) {
    super("Page.frameRequestedNavigation", { detail });
  }
}

export interface Page_frameScheduledNavigation {
  /**
   * Id of the frame that has scheduled a navigation.
   */
  frameId: Page_FrameId;
  /**
   * Delay (in seconds) until the navigation is scheduled to begin. The navigation is not
   * guaranteed to start.
   */
  delay: number;
  /**
   * The reason for the navigation.
   */
  reason: Page_ClientNavigationReason;
  /**
   * The destination URL for the scheduled navigation.
   */
  url: string;
}

export class Page_frameScheduledNavigationEvent
  extends CustomEvent<Page_frameScheduledNavigation> {
  constructor(detail: Page_frameScheduledNavigation) {
    super("Page.frameScheduledNavigation", { detail });
  }
}

export interface Page_frameStartedLoading {
  /**
   * Id of the frame that has started loading.
   */
  frameId: Page_FrameId;
}

export class Page_frameStartedLoadingEvent
  extends CustomEvent<Page_frameStartedLoading> {
  constructor(detail: Page_frameStartedLoading) {
    super("Page.frameStartedLoading", { detail });
  }
}

export interface Page_frameStoppedLoading {
  /**
   * Id of the frame that has stopped loading.
   */
  frameId: Page_FrameId;
}

export class Page_frameStoppedLoadingEvent
  extends CustomEvent<Page_frameStoppedLoading> {
  constructor(detail: Page_frameStoppedLoading) {
    super("Page.frameStoppedLoading", { detail });
  }
}

export interface Page_downloadWillBegin {
  /**
   * Id of the frame that caused download to begin.
   */
  frameId: Page_FrameId;
  /**
   * Global unique identifier of the download.
   */
  guid: string;
  /**
   * URL of the resource being downloaded.
   */
  url: string;
  /**
   * Suggested file name of the resource (the actual name of the file saved on disk may differ).
   */
  suggestedFilename: string;
}

export class Page_downloadWillBeginEvent
  extends CustomEvent<Page_downloadWillBegin> {
  constructor(detail: Page_downloadWillBegin) {
    super("Page.downloadWillBegin", { detail });
  }
}

export interface Page_downloadProgress {
  /**
   * Global unique identifier of the download.
   */
  guid: string;
  /**
   * Total expected bytes to download.
   */
  totalBytes: number;
  /**
   * Total bytes received.
   */
  receivedBytes: number;
  /**
   * Download status.
   */
  state: "inProgress" | "completed" | "canceled";
}

export class Page_downloadProgressEvent
  extends CustomEvent<Page_downloadProgress> {
  constructor(detail: Page_downloadProgress) {
    super("Page.downloadProgress", { detail });
  }
}

export interface Page_javascriptDialogClosed {
  /**
   * Whether dialog was confirmed.
   */
  result: boolean;
  /**
   * User input in case of prompt.
   */
  userInput: string;
}

export class Page_javascriptDialogClosedEvent
  extends CustomEvent<Page_javascriptDialogClosed> {
  constructor(detail: Page_javascriptDialogClosed) {
    super("Page.javascriptDialogClosed", { detail });
  }
}

export interface Page_javascriptDialogOpening {
  /**
   * Frame url.
   */
  url: string;
  /**
   * Message that will be displayed by the dialog.
   */
  message: string;
  /**
   * Dialog type.
   */
  type: Page_DialogType;
  /**
   * True iff browser is capable showing or acting on the given dialog. When browser has no
   * dialog handler for given target, calling alert while Page domain is engaged will stall
   * the page execution. Execution can be resumed via calling Page.handleJavaScriptDialog.
   */
  hasBrowserHandler: boolean;
  /**
   * Default dialog prompt.
   */
  defaultPrompt?: string;
}

export class Page_javascriptDialogOpeningEvent
  extends CustomEvent<Page_javascriptDialogOpening> {
  constructor(detail: Page_javascriptDialogOpening) {
    super("Page.javascriptDialogOpening", { detail });
  }
}

export interface Page_lifecycleEvent {
  /**
   * Id of the frame.
   */
  frameId: Page_FrameId;
  /**
   * Loader identifier. Empty string if the request is fetched from worker.
   */
  loaderId: Network_LoaderId;
  name: string;
  timestamp: Network_MonotonicTime;
}

export class Page_lifecycleEventEvent extends CustomEvent<Page_lifecycleEvent> {
  constructor(detail: Page_lifecycleEvent) {
    super("Page.lifecycleEvent", { detail });
  }
}

export interface Page_backForwardCacheNotUsed {
  /**
   * The loader id for the associated navigation.
   */
  loaderId: Network_LoaderId;
  /**
   * The frame id of the associated frame.
   */
  frameId: Page_FrameId;
  /**
   * Array of reasons why the page could not be cached. This must not be empty.
   */
  notRestoredExplanations: Page_BackForwardCacheNotRestoredExplanation[];
  /**
   * Tree structure of reasons why the page could not be cached for each frame.
   */
  notRestoredExplanationsTree?: Page_BackForwardCacheNotRestoredExplanationTree;
}

export class Page_backForwardCacheNotUsedEvent
  extends CustomEvent<Page_backForwardCacheNotUsed> {
  constructor(detail: Page_backForwardCacheNotUsed) {
    super("Page.backForwardCacheNotUsed", { detail });
  }
}

export interface Page_loadEventFired {
  timestamp: Network_MonotonicTime;
}

export class Page_loadEventFiredEvent extends CustomEvent<Page_loadEventFired> {
  constructor(detail: Page_loadEventFired) {
    super("Page.loadEventFired", { detail });
  }
}

export interface Page_navigatedWithinDocument {
  /**
   * Id of the frame.
   */
  frameId: Page_FrameId;
  /**
   * Frame's new url.
   */
  url: string;
}

export class Page_navigatedWithinDocumentEvent
  extends CustomEvent<Page_navigatedWithinDocument> {
  constructor(detail: Page_navigatedWithinDocument) {
    super("Page.navigatedWithinDocument", { detail });
  }
}

export interface Page_screencastFrame {
  /**
   * Base64-encoded compressed image.
   */
  data: string;
  /**
   * Screencast frame metadata.
   */
  metadata: Page_ScreencastFrameMetadata;
  /**
   * Frame number.
   */
  sessionId: number;
}

export class Page_screencastFrameEvent
  extends CustomEvent<Page_screencastFrame> {
  constructor(detail: Page_screencastFrame) {
    super("Page.screencastFrame", { detail });
  }
}

export interface Page_screencastVisibilityChanged {
  /**
   * True if the page is visible.
   */
  visible: boolean;
}

export class Page_screencastVisibilityChangedEvent
  extends CustomEvent<Page_screencastVisibilityChanged> {
  constructor(detail: Page_screencastVisibilityChanged) {
    super("Page.screencastVisibilityChanged", { detail });
  }
}

export interface Page_windowOpen {
  /**
   * The URL for the new window.
   */
  url: string;
  /**
   * Window name.
   */
  windowName: string;
  /**
   * An array of enabled window features.
   */
  windowFeatures: string[];
  /**
   * Whether or not it was triggered by user gesture.
   */
  userGesture: boolean;
}

export class Page_windowOpenEvent extends CustomEvent<Page_windowOpen> {
  constructor(detail: Page_windowOpen) {
    super("Page.windowOpen", { detail });
  }
}

export interface Page_compilationCacheProduced {
  url: string;
  /**
   * Base64-encoded data
   */
  data: string;
}

export class Page_compilationCacheProducedEvent
  extends CustomEvent<Page_compilationCacheProduced> {
  constructor(detail: Page_compilationCacheProduced) {
    super("Page.compilationCacheProduced", { detail });
  }
}

export interface Performance_metrics {
  /**
   * Current values of the metrics.
   */
  metrics: Performance_Metric[];
  /**
   * Timestamp title.
   */
  title: string;
}

export class Performance_metricsEvent extends CustomEvent<Performance_metrics> {
  constructor(detail: Performance_metrics) {
    super("Performance.metrics", { detail });
  }
}

export interface PerformanceTimeline_timelineEventAdded {
  event: PerformanceTimeline_TimelineEvent;
}

export class PerformanceTimeline_timelineEventAddedEvent
  extends CustomEvent<PerformanceTimeline_timelineEventAdded> {
  constructor(detail: PerformanceTimeline_timelineEventAdded) {
    super("PerformanceTimeline.timelineEventAdded", { detail });
  }
}

export interface Security_certificateError {
  /**
   * The ID of the event.
   */
  eventId: number;
  /**
   * The type of the error.
   */
  errorType: string;
  /**
   * The url that was requested.
   */
  requestURL: string;
}

export class Security_certificateErrorEvent
  extends CustomEvent<Security_certificateError> {
  constructor(detail: Security_certificateError) {
    super("Security.certificateError", { detail });
  }
}

export interface Security_visibleSecurityStateChanged {
  /**
   * Security state information about the page.
   */
  visibleSecurityState: Security_VisibleSecurityState;
}

export class Security_visibleSecurityStateChangedEvent
  extends CustomEvent<Security_visibleSecurityStateChanged> {
  constructor(detail: Security_visibleSecurityStateChanged) {
    super("Security.visibleSecurityStateChanged", { detail });
  }
}

export interface Security_securityStateChanged {
  /**
   * Security state.
   */
  securityState: Security_SecurityState;
  /**
   * @deprecated
   * True if the page was loaded over cryptographic transport such as HTTPS.
   */
  schemeIsCryptographic: boolean;
  /**
   * @deprecated
   * Previously a list of explanations for the security state. Now always
   * empty.
   */
  explanations: Security_SecurityStateExplanation[];
  /**
   * @deprecated
   * Information about insecure content on the page.
   */
  insecureContentStatus: Security_InsecureContentStatus;
  /**
   * @deprecated
   * Overrides user-visible description of the state. Always omitted.
   */
  summary?: string;
}

export class Security_securityStateChangedEvent
  extends CustomEvent<Security_securityStateChanged> {
  constructor(detail: Security_securityStateChanged) {
    super("Security.securityStateChanged", { detail });
  }
}

export interface ServiceWorker_workerErrorReported {
  errorMessage: ServiceWorker_ServiceWorkerErrorMessage;
}

export class ServiceWorker_workerErrorReportedEvent
  extends CustomEvent<ServiceWorker_workerErrorReported> {
  constructor(detail: ServiceWorker_workerErrorReported) {
    super("ServiceWorker.workerErrorReported", { detail });
  }
}

export interface ServiceWorker_workerRegistrationUpdated {
  registrations: ServiceWorker_ServiceWorkerRegistration[];
}

export class ServiceWorker_workerRegistrationUpdatedEvent
  extends CustomEvent<ServiceWorker_workerRegistrationUpdated> {
  constructor(detail: ServiceWorker_workerRegistrationUpdated) {
    super("ServiceWorker.workerRegistrationUpdated", { detail });
  }
}

export interface ServiceWorker_workerVersionUpdated {
  versions: ServiceWorker_ServiceWorkerVersion[];
}

export class ServiceWorker_workerVersionUpdatedEvent
  extends CustomEvent<ServiceWorker_workerVersionUpdated> {
  constructor(detail: ServiceWorker_workerVersionUpdated) {
    super("ServiceWorker.workerVersionUpdated", { detail });
  }
}

export interface Storage_cacheStorageContentUpdated {
  /**
   * Origin to update.
   */
  origin: string;
  /**
   * Storage key to update.
   */
  storageKey: string;
  /**
   * Storage bucket to update.
   */
  bucketId: string;
  /**
   * Name of cache in origin.
   */
  cacheName: string;
}

export class Storage_cacheStorageContentUpdatedEvent
  extends CustomEvent<Storage_cacheStorageContentUpdated> {
  constructor(detail: Storage_cacheStorageContentUpdated) {
    super("Storage.cacheStorageContentUpdated", { detail });
  }
}

export interface Storage_cacheStorageListUpdated {
  /**
   * Origin to update.
   */
  origin: string;
  /**
   * Storage key to update.
   */
  storageKey: string;
  /**
   * Storage bucket to update.
   */
  bucketId: string;
}

export class Storage_cacheStorageListUpdatedEvent
  extends CustomEvent<Storage_cacheStorageListUpdated> {
  constructor(detail: Storage_cacheStorageListUpdated) {
    super("Storage.cacheStorageListUpdated", { detail });
  }
}

export interface Storage_indexedDBContentUpdated {
  /**
   * Origin to update.
   */
  origin: string;
  /**
   * Storage key to update.
   */
  storageKey: string;
  /**
   * Storage bucket to update.
   */
  bucketId: string;
  /**
   * Database to update.
   */
  databaseName: string;
  /**
   * ObjectStore to update.
   */
  objectStoreName: string;
}

export class Storage_indexedDBContentUpdatedEvent
  extends CustomEvent<Storage_indexedDBContentUpdated> {
  constructor(detail: Storage_indexedDBContentUpdated) {
    super("Storage.indexedDBContentUpdated", { detail });
  }
}

export interface Storage_indexedDBListUpdated {
  /**
   * Origin to update.
   */
  origin: string;
  /**
   * Storage key to update.
   */
  storageKey: string;
  /**
   * Storage bucket to update.
   */
  bucketId: string;
}

export class Storage_indexedDBListUpdatedEvent
  extends CustomEvent<Storage_indexedDBListUpdated> {
  constructor(detail: Storage_indexedDBListUpdated) {
    super("Storage.indexedDBListUpdated", { detail });
  }
}

export interface Storage_interestGroupAccessed {
  accessTime: Network_TimeSinceEpoch;
  type: Storage_InterestGroupAccessType;
  ownerOrigin: string;
  name: string;
  /**
   * For topLevelBid/topLevelAdditionalBid, and when appropriate,
   * win and additionalBidWin
   */
  componentSellerOrigin?: string;
  /**
   * For bid or somethingBid event, if done locally and not on a server.
   */
  bid?: number;
  bidCurrency?: string;
  /**
   * For non-global events --- links to interestGroupAuctionEvent
   */
  uniqueAuctionId?: Storage_InterestGroupAuctionId;
}

export class Storage_interestGroupAccessedEvent
  extends CustomEvent<Storage_interestGroupAccessed> {
  constructor(detail: Storage_interestGroupAccessed) {
    super("Storage.interestGroupAccessed", { detail });
  }
}

export interface Storage_interestGroupAuctionEventOccurred {
  eventTime: Network_TimeSinceEpoch;
  type: Storage_InterestGroupAuctionEventType;
  uniqueAuctionId: Storage_InterestGroupAuctionId;
  /**
   * Set for child auctions.
   */
  parentAuctionId?: Storage_InterestGroupAuctionId;
  /**
   * Set for started and configResolved
   */
  auctionConfig?: object;
}

export class Storage_interestGroupAuctionEventOccurredEvent
  extends CustomEvent<Storage_interestGroupAuctionEventOccurred> {
  constructor(detail: Storage_interestGroupAuctionEventOccurred) {
    super("Storage.interestGroupAuctionEventOccurred", { detail });
  }
}

export interface Storage_interestGroupAuctionNetworkRequestCreated {
  type: Storage_InterestGroupAuctionFetchType;
  requestId: Network_RequestId;
  /**
   * This is the set of the auctions using the worklet that issued this
   * request.  In the case of trusted signals, it's possible that only some of
   * them actually care about the keys being queried.
   */
  auctions: Storage_InterestGroupAuctionId[];
}

export class Storage_interestGroupAuctionNetworkRequestCreatedEvent
  extends CustomEvent<Storage_interestGroupAuctionNetworkRequestCreated> {
  constructor(detail: Storage_interestGroupAuctionNetworkRequestCreated) {
    super("Storage.interestGroupAuctionNetworkRequestCreated", { detail });
  }
}

export interface Storage_sharedStorageAccessed {
  /**
   * Time of the access.
   */
  accessTime: Network_TimeSinceEpoch;
  /**
   * Enum value indicating the Shared Storage API method invoked.
   */
  type: Storage_SharedStorageAccessType;
  /**
   * DevTools Frame Token for the primary frame tree's root.
   */
  mainFrameId: Page_FrameId;
  /**
   * Serialized origin for the context that invoked the Shared Storage API.
   */
  ownerOrigin: string;
  /**
   * The sub-parameters wrapped by `params` are all optional and their
   * presence/absence depends on `type`.
   */
  params: Storage_SharedStorageAccessParams;
}

export class Storage_sharedStorageAccessedEvent
  extends CustomEvent<Storage_sharedStorageAccessed> {
  constructor(detail: Storage_sharedStorageAccessed) {
    super("Storage.sharedStorageAccessed", { detail });
  }
}

export interface Storage_storageBucketCreatedOrUpdated {
  bucketInfo: Storage_StorageBucketInfo;
}

export class Storage_storageBucketCreatedOrUpdatedEvent
  extends CustomEvent<Storage_storageBucketCreatedOrUpdated> {
  constructor(detail: Storage_storageBucketCreatedOrUpdated) {
    super("Storage.storageBucketCreatedOrUpdated", { detail });
  }
}

export interface Storage_storageBucketDeleted {
  bucketId: string;
}

export class Storage_storageBucketDeletedEvent
  extends CustomEvent<Storage_storageBucketDeleted> {
  constructor(detail: Storage_storageBucketDeleted) {
    super("Storage.storageBucketDeleted", { detail });
  }
}

export interface Storage_attributionReportingSourceRegistered {
  registration: Storage_AttributionReportingSourceRegistration;
  result: Storage_AttributionReportingSourceRegistrationResult;
}

export class Storage_attributionReportingSourceRegisteredEvent
  extends CustomEvent<Storage_attributionReportingSourceRegistered> {
  constructor(detail: Storage_attributionReportingSourceRegistered) {
    super("Storage.attributionReportingSourceRegistered", { detail });
  }
}

export interface Storage_attributionReportingTriggerRegistered {
  registration: Storage_AttributionReportingTriggerRegistration;
  eventLevel: Storage_AttributionReportingEventLevelResult;
  aggregatable: Storage_AttributionReportingAggregatableResult;
}

export class Storage_attributionReportingTriggerRegisteredEvent
  extends CustomEvent<Storage_attributionReportingTriggerRegistered> {
  constructor(detail: Storage_attributionReportingTriggerRegistered) {
    super("Storage.attributionReportingTriggerRegistered", { detail });
  }
}

export interface Target_attachedToTarget {
  /**
   * Identifier assigned to the session used to send/receive messages.
   */
  sessionId: Target_SessionID;
  targetInfo: Target_TargetInfo;
  waitingForDebugger: boolean;
}

export class Target_attachedToTargetEvent
  extends CustomEvent<Target_attachedToTarget> {
  constructor(detail: Target_attachedToTarget) {
    super("Target.attachedToTarget", { detail });
  }
}

export interface Target_detachedFromTarget {
  /**
   * Detached session identifier.
   */
  sessionId: Target_SessionID;
  /**
   * @deprecated
   * Deprecated.
   */
  targetId?: Target_TargetID;
}

export class Target_detachedFromTargetEvent
  extends CustomEvent<Target_detachedFromTarget> {
  constructor(detail: Target_detachedFromTarget) {
    super("Target.detachedFromTarget", { detail });
  }
}

export interface Target_receivedMessageFromTarget {
  /**
   * Identifier of a session which sends a message.
   */
  sessionId: Target_SessionID;
  message: string;
  /**
   * @deprecated
   * Deprecated.
   */
  targetId?: Target_TargetID;
}

export class Target_receivedMessageFromTargetEvent
  extends CustomEvent<Target_receivedMessageFromTarget> {
  constructor(detail: Target_receivedMessageFromTarget) {
    super("Target.receivedMessageFromTarget", { detail });
  }
}

export interface Target_targetCreated {
  targetInfo: Target_TargetInfo;
}

export class Target_targetCreatedEvent
  extends CustomEvent<Target_targetCreated> {
  constructor(detail: Target_targetCreated) {
    super("Target.targetCreated", { detail });
  }
}

export interface Target_targetDestroyed {
  targetId: Target_TargetID;
}

export class Target_targetDestroyedEvent
  extends CustomEvent<Target_targetDestroyed> {
  constructor(detail: Target_targetDestroyed) {
    super("Target.targetDestroyed", { detail });
  }
}

export interface Target_targetCrashed {
  targetId: Target_TargetID;
  /**
   * Termination status type.
   */
  status: string;
  /**
   * Termination error code.
   */
  errorCode: number;
}

export class Target_targetCrashedEvent
  extends CustomEvent<Target_targetCrashed> {
  constructor(detail: Target_targetCrashed) {
    super("Target.targetCrashed", { detail });
  }
}

export interface Target_targetInfoChanged {
  targetInfo: Target_TargetInfo;
}

export class Target_targetInfoChangedEvent
  extends CustomEvent<Target_targetInfoChanged> {
  constructor(detail: Target_targetInfoChanged) {
    super("Target.targetInfoChanged", { detail });
  }
}

export interface Tethering_accepted {
  /**
   * Port number that was successfully bound.
   */
  port: number;
  /**
   * Connection id to be used.
   */
  connectionId: string;
}

export class Tethering_acceptedEvent extends CustomEvent<Tethering_accepted> {
  constructor(detail: Tethering_accepted) {
    super("Tethering.accepted", { detail });
  }
}

export interface Tracing_bufferUsage {
  /**
   * A number in range [0..1] that indicates the used size of event buffer as a fraction of its
   * total size.
   */
  percentFull?: number;
  /**
   * An approximate number of events in the trace log.
   */
  eventCount?: number;
  /**
   * A number in range [0..1] that indicates the used size of event buffer as a fraction of its
   * total size.
   */
  value?: number;
}

export class Tracing_bufferUsageEvent extends CustomEvent<Tracing_bufferUsage> {
  constructor(detail: Tracing_bufferUsage) {
    super("Tracing.bufferUsage", { detail });
  }
}

export interface Tracing_dataCollected {
  value: object[];
}

export class Tracing_dataCollectedEvent
  extends CustomEvent<Tracing_dataCollected> {
  constructor(detail: Tracing_dataCollected) {
    super("Tracing.dataCollected", { detail });
  }
}

export interface Tracing_tracingComplete {
  /**
   * Indicates whether some trace data is known to have been lost, e.g. because the trace ring
   * buffer wrapped around.
   */
  dataLossOccurred: boolean;
  /**
   * A handle of the stream that holds resulting trace data.
   */
  stream?: IO_StreamHandle;
  /**
   * Trace data format of returned stream.
   */
  traceFormat?: Tracing_StreamFormat;
  /**
   * Compression format of returned stream.
   */
  streamCompression?: Tracing_StreamCompression;
}

export class Tracing_tracingCompleteEvent
  extends CustomEvent<Tracing_tracingComplete> {
  constructor(detail: Tracing_tracingComplete) {
    super("Tracing.tracingComplete", { detail });
  }
}

export interface Fetch_requestPaused {
  /**
   * Each request the page makes will have a unique id.
   */
  requestId: Fetch_RequestId;
  /**
   * The details of the request.
   */
  request: Network_Request;
  /**
   * The id of the frame that initiated the request.
   */
  frameId: Page_FrameId;
  /**
   * How the requested resource will be used.
   */
  resourceType: Network_ResourceType;
  /**
   * Response error if intercepted at response stage.
   */
  responseErrorReason?: Network_ErrorReason;
  /**
   * Response code if intercepted at response stage.
   */
  responseStatusCode?: number;
  /**
   * Response status text if intercepted at response stage.
   */
  responseStatusText?: string;
  /**
   * Response headers if intercepted at the response stage.
   */
  responseHeaders?: Fetch_HeaderEntry[];
  /**
   * If the intercepted request had a corresponding Network.requestWillBeSent event fired for it,
   * then this networkId will be the same as the requestId present in the requestWillBeSent event.
   */
  networkId?: Network_RequestId;
  /**
   * @experimental
   * If the request is due to a redirect response from the server, the id of the request that
   * has caused the redirect.
   */
  redirectedRequestId?: Fetch_RequestId;
}

export class Fetch_requestPausedEvent extends CustomEvent<Fetch_requestPaused> {
  constructor(detail: Fetch_requestPaused) {
    super("Fetch.requestPaused", { detail });
  }
}

export interface Fetch_authRequired {
  /**
   * Each request the page makes will have a unique id.
   */
  requestId: Fetch_RequestId;
  /**
   * The details of the request.
   */
  request: Network_Request;
  /**
   * The id of the frame that initiated the request.
   */
  frameId: Page_FrameId;
  /**
   * How the requested resource will be used.
   */
  resourceType: Network_ResourceType;
  /**
   * Details of the Authorization Challenge encountered.
   * If this is set, client should respond with continueRequest that
   * contains AuthChallengeResponse.
   */
  authChallenge: Fetch_AuthChallenge;
}

export class Fetch_authRequiredEvent extends CustomEvent<Fetch_authRequired> {
  constructor(detail: Fetch_authRequired) {
    super("Fetch.authRequired", { detail });
  }
}

export interface WebAudio_contextCreated {
  context: WebAudio_BaseAudioContext;
}

export class WebAudio_contextCreatedEvent
  extends CustomEvent<WebAudio_contextCreated> {
  constructor(detail: WebAudio_contextCreated) {
    super("WebAudio.contextCreated", { detail });
  }
}

export interface WebAudio_contextWillBeDestroyed {
  contextId: WebAudio_GraphObjectId;
}

export class WebAudio_contextWillBeDestroyedEvent
  extends CustomEvent<WebAudio_contextWillBeDestroyed> {
  constructor(detail: WebAudio_contextWillBeDestroyed) {
    super("WebAudio.contextWillBeDestroyed", { detail });
  }
}

export interface WebAudio_contextChanged {
  context: WebAudio_BaseAudioContext;
}

export class WebAudio_contextChangedEvent
  extends CustomEvent<WebAudio_contextChanged> {
  constructor(detail: WebAudio_contextChanged) {
    super("WebAudio.contextChanged", { detail });
  }
}

export interface WebAudio_audioListenerCreated {
  listener: WebAudio_AudioListener;
}

export class WebAudio_audioListenerCreatedEvent
  extends CustomEvent<WebAudio_audioListenerCreated> {
  constructor(detail: WebAudio_audioListenerCreated) {
    super("WebAudio.audioListenerCreated", { detail });
  }
}

export interface WebAudio_audioListenerWillBeDestroyed {
  contextId: WebAudio_GraphObjectId;
  listenerId: WebAudio_GraphObjectId;
}

export class WebAudio_audioListenerWillBeDestroyedEvent
  extends CustomEvent<WebAudio_audioListenerWillBeDestroyed> {
  constructor(detail: WebAudio_audioListenerWillBeDestroyed) {
    super("WebAudio.audioListenerWillBeDestroyed", { detail });
  }
}

export interface WebAudio_audioNodeCreated {
  node: WebAudio_AudioNode;
}

export class WebAudio_audioNodeCreatedEvent
  extends CustomEvent<WebAudio_audioNodeCreated> {
  constructor(detail: WebAudio_audioNodeCreated) {
    super("WebAudio.audioNodeCreated", { detail });
  }
}

export interface WebAudio_audioNodeWillBeDestroyed {
  contextId: WebAudio_GraphObjectId;
  nodeId: WebAudio_GraphObjectId;
}

export class WebAudio_audioNodeWillBeDestroyedEvent
  extends CustomEvent<WebAudio_audioNodeWillBeDestroyed> {
  constructor(detail: WebAudio_audioNodeWillBeDestroyed) {
    super("WebAudio.audioNodeWillBeDestroyed", { detail });
  }
}

export interface WebAudio_audioParamCreated {
  param: WebAudio_AudioParam;
}

export class WebAudio_audioParamCreatedEvent
  extends CustomEvent<WebAudio_audioParamCreated> {
  constructor(detail: WebAudio_audioParamCreated) {
    super("WebAudio.audioParamCreated", { detail });
  }
}

export interface WebAudio_audioParamWillBeDestroyed {
  contextId: WebAudio_GraphObjectId;
  nodeId: WebAudio_GraphObjectId;
  paramId: WebAudio_GraphObjectId;
}

export class WebAudio_audioParamWillBeDestroyedEvent
  extends CustomEvent<WebAudio_audioParamWillBeDestroyed> {
  constructor(detail: WebAudio_audioParamWillBeDestroyed) {
    super("WebAudio.audioParamWillBeDestroyed", { detail });
  }
}

export interface WebAudio_nodesConnected {
  contextId: WebAudio_GraphObjectId;
  sourceId: WebAudio_GraphObjectId;
  destinationId: WebAudio_GraphObjectId;
  sourceOutputIndex?: number;
  destinationInputIndex?: number;
}

export class WebAudio_nodesConnectedEvent
  extends CustomEvent<WebAudio_nodesConnected> {
  constructor(detail: WebAudio_nodesConnected) {
    super("WebAudio.nodesConnected", { detail });
  }
}

export interface WebAudio_nodesDisconnected {
  contextId: WebAudio_GraphObjectId;
  sourceId: WebAudio_GraphObjectId;
  destinationId: WebAudio_GraphObjectId;
  sourceOutputIndex?: number;
  destinationInputIndex?: number;
}

export class WebAudio_nodesDisconnectedEvent
  extends CustomEvent<WebAudio_nodesDisconnected> {
  constructor(detail: WebAudio_nodesDisconnected) {
    super("WebAudio.nodesDisconnected", { detail });
  }
}

export interface WebAudio_nodeParamConnected {
  contextId: WebAudio_GraphObjectId;
  sourceId: WebAudio_GraphObjectId;
  destinationId: WebAudio_GraphObjectId;
  sourceOutputIndex?: number;
}

export class WebAudio_nodeParamConnectedEvent
  extends CustomEvent<WebAudio_nodeParamConnected> {
  constructor(detail: WebAudio_nodeParamConnected) {
    super("WebAudio.nodeParamConnected", { detail });
  }
}

export interface WebAudio_nodeParamDisconnected {
  contextId: WebAudio_GraphObjectId;
  sourceId: WebAudio_GraphObjectId;
  destinationId: WebAudio_GraphObjectId;
  sourceOutputIndex?: number;
}

export class WebAudio_nodeParamDisconnectedEvent
  extends CustomEvent<WebAudio_nodeParamDisconnected> {
  constructor(detail: WebAudio_nodeParamDisconnected) {
    super("WebAudio.nodeParamDisconnected", { detail });
  }
}

export interface WebAuthn_credentialAdded {
  authenticatorId: WebAuthn_AuthenticatorId;
  credential: WebAuthn_Credential;
}

export class WebAuthn_credentialAddedEvent
  extends CustomEvent<WebAuthn_credentialAdded> {
  constructor(detail: WebAuthn_credentialAdded) {
    super("WebAuthn.credentialAdded", { detail });
  }
}

export interface WebAuthn_credentialAsserted {
  authenticatorId: WebAuthn_AuthenticatorId;
  credential: WebAuthn_Credential;
}

export class WebAuthn_credentialAssertedEvent
  extends CustomEvent<WebAuthn_credentialAsserted> {
  constructor(detail: WebAuthn_credentialAsserted) {
    super("WebAuthn.credentialAsserted", { detail });
  }
}

export interface Media_playerPropertiesChanged {
  playerId: Media_PlayerId;
  properties: Media_PlayerProperty[];
}

export class Media_playerPropertiesChangedEvent
  extends CustomEvent<Media_playerPropertiesChanged> {
  constructor(detail: Media_playerPropertiesChanged) {
    super("Media.playerPropertiesChanged", { detail });
  }
}

export interface Media_playerEventsAdded {
  playerId: Media_PlayerId;
  events: Media_PlayerEvent[];
}

export class Media_playerEventsAddedEvent
  extends CustomEvent<Media_playerEventsAdded> {
  constructor(detail: Media_playerEventsAdded) {
    super("Media.playerEventsAdded", { detail });
  }
}

export interface Media_playerMessagesLogged {
  playerId: Media_PlayerId;
  messages: Media_PlayerMessage[];
}

export class Media_playerMessagesLoggedEvent
  extends CustomEvent<Media_playerMessagesLogged> {
  constructor(detail: Media_playerMessagesLogged) {
    super("Media.playerMessagesLogged", { detail });
  }
}

export interface Media_playerErrorsRaised {
  playerId: Media_PlayerId;
  errors: Media_PlayerError[];
}

export class Media_playerErrorsRaisedEvent
  extends CustomEvent<Media_playerErrorsRaised> {
  constructor(detail: Media_playerErrorsRaised) {
    super("Media.playerErrorsRaised", { detail });
  }
}

export interface Media_playersCreated {
  players: Media_PlayerId[];
}

export class Media_playersCreatedEvent
  extends CustomEvent<Media_playersCreated> {
  constructor(detail: Media_playersCreated) {
    super("Media.playersCreated", { detail });
  }
}

export interface DeviceAccess_deviceRequestPrompted {
  id: DeviceAccess_RequestId;
  devices: DeviceAccess_PromptDevice[];
}

export class DeviceAccess_deviceRequestPromptedEvent
  extends CustomEvent<DeviceAccess_deviceRequestPrompted> {
  constructor(detail: DeviceAccess_deviceRequestPrompted) {
    super("DeviceAccess.deviceRequestPrompted", { detail });
  }
}

export interface Preload_ruleSetUpdated {
  ruleSet: Preload_RuleSet;
}

export class Preload_ruleSetUpdatedEvent
  extends CustomEvent<Preload_ruleSetUpdated> {
  constructor(detail: Preload_ruleSetUpdated) {
    super("Preload.ruleSetUpdated", { detail });
  }
}

export interface Preload_ruleSetRemoved {
  id: Preload_RuleSetId;
}

export class Preload_ruleSetRemovedEvent
  extends CustomEvent<Preload_ruleSetRemoved> {
  constructor(detail: Preload_ruleSetRemoved) {
    super("Preload.ruleSetRemoved", { detail });
  }
}

export interface Preload_preloadEnabledStateUpdated {
  disabledByPreference: boolean;
  disabledByDataSaver: boolean;
  disabledByBatterySaver: boolean;
  disabledByHoldbackPrefetchSpeculationRules: boolean;
  disabledByHoldbackPrerenderSpeculationRules: boolean;
}

export class Preload_preloadEnabledStateUpdatedEvent
  extends CustomEvent<Preload_preloadEnabledStateUpdated> {
  constructor(detail: Preload_preloadEnabledStateUpdated) {
    super("Preload.preloadEnabledStateUpdated", { detail });
  }
}

export interface Preload_prefetchStatusUpdated {
  key: Preload_PreloadingAttemptKey;
  /**
   * The frame id of the frame initiating prefetch.
   */
  initiatingFrameId: Page_FrameId;
  prefetchUrl: string;
  status: Preload_PreloadingStatus;
  prefetchStatus: Preload_PrefetchStatus;
  requestId: Network_RequestId;
}

export class Preload_prefetchStatusUpdatedEvent
  extends CustomEvent<Preload_prefetchStatusUpdated> {
  constructor(detail: Preload_prefetchStatusUpdated) {
    super("Preload.prefetchStatusUpdated", { detail });
  }
}

export interface Preload_prerenderStatusUpdated {
  key: Preload_PreloadingAttemptKey;
  status: Preload_PreloadingStatus;
  prerenderStatus?: Preload_PrerenderFinalStatus;
  /**
   * This is used to give users more information about the name of Mojo interface
   * that is incompatible with prerender and has caused the cancellation of the attempt.
   */
  disallowedMojoInterface?: string;
  mismatchedHeaders?: Preload_PrerenderMismatchedHeaders[];
}

export class Preload_prerenderStatusUpdatedEvent
  extends CustomEvent<Preload_prerenderStatusUpdated> {
  constructor(detail: Preload_prerenderStatusUpdated) {
    super("Preload.prerenderStatusUpdated", { detail });
  }
}

export interface Preload_preloadingAttemptSourcesUpdated {
  loaderId: Network_LoaderId;
  preloadingAttemptSources: Preload_PreloadingAttemptSource[];
}

export class Preload_preloadingAttemptSourcesUpdatedEvent
  extends CustomEvent<Preload_preloadingAttemptSourcesUpdated> {
  constructor(detail: Preload_preloadingAttemptSourcesUpdated) {
    super("Preload.preloadingAttemptSourcesUpdated", { detail });
  }
}

export interface FedCm_dialogShown {
  dialogId: string;
  dialogType: FedCm_DialogType;
  accounts: FedCm_Account[];
  /**
   * These exist primarily so that the caller can verify the
   * RP context was used appropriately.
   */
  title: string;
  subtitle?: string;
}

export class FedCm_dialogShownEvent extends CustomEvent<FedCm_dialogShown> {
  constructor(detail: FedCm_dialogShown) {
    super("FedCm.dialogShown", { detail });
  }
}

export interface FedCm_dialogClosed {
  dialogId: string;
}

export class FedCm_dialogClosedEvent extends CustomEvent<FedCm_dialogClosed> {
  constructor(detail: FedCm_dialogClosed) {
    super("FedCm.dialogClosed", { detail });
  }
}

export interface Console_messageAdded {
  /**
   * Console message that has been added.
   */
  message: Console_ConsoleMessage;
}

export class Console_messageAddedEvent
  extends CustomEvent<Console_messageAdded> {
  constructor(detail: Console_messageAdded) {
    super("Console.messageAdded", { detail });
  }
}

export interface Debugger_breakpointResolved {
  /**
   * Breakpoint unique identifier.
   */
  breakpointId: Debugger_BreakpointId;
  /**
   * Actual breakpoint location.
   */
  location: Debugger_Location;
}

export class Debugger_breakpointResolvedEvent
  extends CustomEvent<Debugger_breakpointResolved> {
  constructor(detail: Debugger_breakpointResolved) {
    super("Debugger.breakpointResolved", { detail });
  }
}

export interface Debugger_paused {
  /**
   * Call stack the virtual machine stopped on.
   */
  callFrames: Debugger_CallFrame[];
  /**
   * Pause reason.
   */
  reason:
    | "ambiguous"
    | "assert"
    | "CSPViolation"
    | "debugCommand"
    | "DOM"
    | "EventListener"
    | "exception"
    | "instrumentation"
    | "OOM"
    | "other"
    | "promiseRejection"
    | "XHR"
    | "step";
  /**
   * Object containing break-specific auxiliary properties.
   */
  data?: object;
  /**
   * Hit breakpoints IDs
   */
  hitBreakpoints?: string[];
  /**
   * Async stack trace, if any.
   */
  asyncStackTrace?: Runtime_StackTrace;
  /**
   * @experimental
   * Async stack trace, if any.
   */
  asyncStackTraceId?: Runtime_StackTraceId;
  /**
   * @experimental
   * @deprecated
   * Never present, will be removed.
   */
  asyncCallStackTraceId?: Runtime_StackTraceId;
}

export class Debugger_pausedEvent extends CustomEvent<Debugger_paused> {
  constructor(detail: Debugger_paused) {
    super("Debugger.paused", { detail });
  }
}

export interface Debugger_scriptFailedToParse {
  /**
   * Identifier of the script parsed.
   */
  scriptId: Runtime_ScriptId;
  /**
   * URL or name of the script parsed (if any).
   */
  url: string;
  /**
   * Line offset of the script within the resource with given URL (for script tags).
   */
  startLine: number;
  /**
   * Column offset of the script within the resource with given URL.
   */
  startColumn: number;
  /**
   * Last line of the script.
   */
  endLine: number;
  /**
   * Length of the last line of the script.
   */
  endColumn: number;
  /**
   * Specifies script creation context.
   */
  executionContextId: Runtime_ExecutionContextId;
  /**
   * Content hash of the script, SHA-256.
   */
  hash: string;
  /**
   * Embedder-specific auxiliary data likely matching {isDefault: boolean, type: 'default'|'isolated'|'worker', frameId: string}
   */
  executionContextAuxData?: object;
  /**
   * URL of source map associated with script (if any).
   */
  sourceMapURL?: string;
  /**
   * True, if this script has sourceURL.
   */
  hasSourceURL?: boolean;
  /**
   * True, if this script is ES6 module.
   */
  isModule?: boolean;
  /**
   * This script length.
   */
  length?: number;
  /**
   * @experimental
   * JavaScript top stack frame of where the script parsed event was triggered if available.
   */
  stackTrace?: Runtime_StackTrace;
  /**
   * @experimental
   * If the scriptLanguage is WebAssembly, the code section offset in the module.
   */
  codeOffset?: number;
  /**
   * @experimental
   * The language of the script.
   */
  scriptLanguage?: Debugger_ScriptLanguage;
  /**
   * @experimental
   * The name the embedder supplied for this script.
   */
  embedderName?: string;
}

export class Debugger_scriptFailedToParseEvent
  extends CustomEvent<Debugger_scriptFailedToParse> {
  constructor(detail: Debugger_scriptFailedToParse) {
    super("Debugger.scriptFailedToParse", { detail });
  }
}

export interface Debugger_scriptParsed {
  /**
   * Identifier of the script parsed.
   */
  scriptId: Runtime_ScriptId;
  /**
   * URL or name of the script parsed (if any).
   */
  url: string;
  /**
   * Line offset of the script within the resource with given URL (for script tags).
   */
  startLine: number;
  /**
   * Column offset of the script within the resource with given URL.
   */
  startColumn: number;
  /**
   * Last line of the script.
   */
  endLine: number;
  /**
   * Length of the last line of the script.
   */
  endColumn: number;
  /**
   * Specifies script creation context.
   */
  executionContextId: Runtime_ExecutionContextId;
  /**
   * Content hash of the script, SHA-256.
   */
  hash: string;
  /**
   * Embedder-specific auxiliary data likely matching {isDefault: boolean, type: 'default'|'isolated'|'worker', frameId: string}
   */
  executionContextAuxData?: object;
  /**
   * @experimental
   * True, if this script is generated as a result of the live edit operation.
   */
  isLiveEdit?: boolean;
  /**
   * URL of source map associated with script (if any).
   */
  sourceMapURL?: string;
  /**
   * True, if this script has sourceURL.
   */
  hasSourceURL?: boolean;
  /**
   * True, if this script is ES6 module.
   */
  isModule?: boolean;
  /**
   * This script length.
   */
  length?: number;
  /**
   * @experimental
   * JavaScript top stack frame of where the script parsed event was triggered if available.
   */
  stackTrace?: Runtime_StackTrace;
  /**
   * @experimental
   * If the scriptLanguage is WebAssembly, the code section offset in the module.
   */
  codeOffset?: number;
  /**
   * @experimental
   * The language of the script.
   */
  scriptLanguage?: Debugger_ScriptLanguage;
  /**
   * @experimental
   * If the scriptLanguage is WebASsembly, the source of debug symbols for the module.
   */
  debugSymbols?: Debugger_DebugSymbols;
  /**
   * @experimental
   * The name the embedder supplied for this script.
   */
  embedderName?: string;
}

export class Debugger_scriptParsedEvent
  extends CustomEvent<Debugger_scriptParsed> {
  constructor(detail: Debugger_scriptParsed) {
    super("Debugger.scriptParsed", { detail });
  }
}

export interface HeapProfiler_addHeapSnapshotChunk {
  chunk: string;
}

export class HeapProfiler_addHeapSnapshotChunkEvent
  extends CustomEvent<HeapProfiler_addHeapSnapshotChunk> {
  constructor(detail: HeapProfiler_addHeapSnapshotChunk) {
    super("HeapProfiler.addHeapSnapshotChunk", { detail });
  }
}

export interface HeapProfiler_heapStatsUpdate {
  /**
   * An array of triplets. Each triplet describes a fragment. The first integer is the fragment
   * index, the second integer is a total count of objects for the fragment, the third integer is
   * a total size of the objects for the fragment.
   */
  statsUpdate: number[];
}

export class HeapProfiler_heapStatsUpdateEvent
  extends CustomEvent<HeapProfiler_heapStatsUpdate> {
  constructor(detail: HeapProfiler_heapStatsUpdate) {
    super("HeapProfiler.heapStatsUpdate", { detail });
  }
}

export interface HeapProfiler_lastSeenObjectId {
  lastSeenObjectId: number;
  timestamp: number;
}

export class HeapProfiler_lastSeenObjectIdEvent
  extends CustomEvent<HeapProfiler_lastSeenObjectId> {
  constructor(detail: HeapProfiler_lastSeenObjectId) {
    super("HeapProfiler.lastSeenObjectId", { detail });
  }
}

export interface HeapProfiler_reportHeapSnapshotProgress {
  done: number;
  total: number;
  finished?: boolean;
}

export class HeapProfiler_reportHeapSnapshotProgressEvent
  extends CustomEvent<HeapProfiler_reportHeapSnapshotProgress> {
  constructor(detail: HeapProfiler_reportHeapSnapshotProgress) {
    super("HeapProfiler.reportHeapSnapshotProgress", { detail });
  }
}

export interface Profiler_consoleProfileFinished {
  id: string;
  /**
   * Location of console.profileEnd().
   */
  location: Debugger_Location;
  profile: Profiler_Profile;
  /**
   * Profile title passed as an argument to console.profile().
   */
  title?: string;
}

export class Profiler_consoleProfileFinishedEvent
  extends CustomEvent<Profiler_consoleProfileFinished> {
  constructor(detail: Profiler_consoleProfileFinished) {
    super("Profiler.consoleProfileFinished", { detail });
  }
}

export interface Profiler_consoleProfileStarted {
  id: string;
  /**
   * Location of console.profile().
   */
  location: Debugger_Location;
  /**
   * Profile title passed as an argument to console.profile().
   */
  title?: string;
}

export class Profiler_consoleProfileStartedEvent
  extends CustomEvent<Profiler_consoleProfileStarted> {
  constructor(detail: Profiler_consoleProfileStarted) {
    super("Profiler.consoleProfileStarted", { detail });
  }
}

export interface Profiler_preciseCoverageDeltaUpdate {
  /**
   * Monotonically increasing time (in seconds) when the coverage update was taken in the backend.
   */
  timestamp: number;
  /**
   * Identifier for distinguishing coverage events.
   */
  occasion: string;
  /**
   * Coverage data for the current isolate.
   */
  result: Profiler_ScriptCoverage[];
}

export class Profiler_preciseCoverageDeltaUpdateEvent
  extends CustomEvent<Profiler_preciseCoverageDeltaUpdate> {
  constructor(detail: Profiler_preciseCoverageDeltaUpdate) {
    super("Profiler.preciseCoverageDeltaUpdate", { detail });
  }
}

export interface Runtime_bindingCalled {
  name: string;
  payload: string;
  /**
   * Identifier of the context where the call was made.
   */
  executionContextId: Runtime_ExecutionContextId;
}

export class Runtime_bindingCalledEvent
  extends CustomEvent<Runtime_bindingCalled> {
  constructor(detail: Runtime_bindingCalled) {
    super("Runtime.bindingCalled", { detail });
  }
}

export interface Runtime_consoleAPICalled {
  /**
   * Type of the call.
   */
  type:
    | "log"
    | "debug"
    | "info"
    | "error"
    | "warning"
    | "dir"
    | "dirxml"
    | "table"
    | "trace"
    | "clear"
    | "startGroup"
    | "startGroupCollapsed"
    | "endGroup"
    | "assert"
    | "profile"
    | "profileEnd"
    | "count"
    | "timeEnd";
  /**
   * Call arguments.
   */
  args: Runtime_RemoteObject[];
  /**
   * Identifier of the context where the call was made.
   */
  executionContextId: Runtime_ExecutionContextId;
  /**
   * Call timestamp.
   */
  timestamp: Runtime_Timestamp;
  /**
   * Stack trace captured when the call was made. The async stack chain is automatically reported for
   * the following call types: `assert`, `error`, `trace`, `warning`. For other types the async call
   * chain can be retrieved using `Debugger.getStackTrace` and `stackTrace.parentId` field.
   */
  stackTrace?: Runtime_StackTrace;
  /**
   * @experimental
   * Console context descriptor for calls on non-default console context (not console.*):
   * 'anonymous#unique-logger-id' for call on unnamed context, 'name#unique-logger-id' for call
   * on named context.
   */
  context?: string;
}

export class Runtime_consoleAPICalledEvent
  extends CustomEvent<Runtime_consoleAPICalled> {
  constructor(detail: Runtime_consoleAPICalled) {
    super("Runtime.consoleAPICalled", { detail });
  }
}

export interface Runtime_exceptionRevoked {
  /**
   * Reason describing why exception was revoked.
   */
  reason: string;
  /**
   * The id of revoked exception, as reported in `exceptionThrown`.
   */
  exceptionId: number;
}

export class Runtime_exceptionRevokedEvent
  extends CustomEvent<Runtime_exceptionRevoked> {
  constructor(detail: Runtime_exceptionRevoked) {
    super("Runtime.exceptionRevoked", { detail });
  }
}

export interface Runtime_exceptionThrown {
  /**
   * Timestamp of the exception.
   */
  timestamp: Runtime_Timestamp;
  exceptionDetails: Runtime_ExceptionDetails;
}

export class Runtime_exceptionThrownEvent
  extends CustomEvent<Runtime_exceptionThrown> {
  constructor(detail: Runtime_exceptionThrown) {
    super("Runtime.exceptionThrown", { detail });
  }
}

export interface Runtime_executionContextCreated {
  /**
   * A newly created execution context.
   */
  context: Runtime_ExecutionContextDescription;
}

export class Runtime_executionContextCreatedEvent
  extends CustomEvent<Runtime_executionContextCreated> {
  constructor(detail: Runtime_executionContextCreated) {
    super("Runtime.executionContextCreated", { detail });
  }
}

export interface Runtime_executionContextDestroyed {
  /**
   * @deprecated
   * Id of the destroyed context
   */
  executionContextId: Runtime_ExecutionContextId;
  /**
   * @experimental
   * Unique Id of the destroyed context
   */
  executionContextUniqueId: string;
}

export class Runtime_executionContextDestroyedEvent
  extends CustomEvent<Runtime_executionContextDestroyed> {
  constructor(detail: Runtime_executionContextDestroyed) {
    super("Runtime.executionContextDestroyed", { detail });
  }
}

export interface Runtime_inspectRequested {
  object: Runtime_RemoteObject;
  hints: object;
  /**
   * @experimental
   * Identifier of the context where the call was made.
   */
  executionContextId?: Runtime_ExecutionContextId;
}

export class Runtime_inspectRequestedEvent
  extends CustomEvent<Runtime_inspectRequested> {
  constructor(detail: Runtime_inspectRequested) {
    super("Runtime.inspectRequested", { detail });
  }
}

const CelestialEvents = {
  "Accessibility.loadComplete": Accessibility_loadCompleteEvent,
  "Accessibility.nodesUpdated": Accessibility_nodesUpdatedEvent,
  "Animation.animationCanceled": Animation_animationCanceledEvent,
  "Animation.animationCreated": Animation_animationCreatedEvent,
  "Animation.animationStarted": Animation_animationStartedEvent,
  "Audits.issueAdded": Audits_issueAddedEvent,
  "Autofill.addressFormFilled": Autofill_addressFormFilledEvent,
  "BackgroundService.recordingStateChanged":
    BackgroundService_recordingStateChangedEvent,
  "BackgroundService.backgroundServiceEventReceived":
    BackgroundService_backgroundServiceEventReceivedEvent,
  "Browser.downloadWillBegin": Browser_downloadWillBeginEvent,
  "Browser.downloadProgress": Browser_downloadProgressEvent,
  "CSS.fontsUpdated": CSS_fontsUpdatedEvent,
  "CSS.mediaQueryResultChanged": Event,
  "CSS.styleSheetAdded": CSS_styleSheetAddedEvent,
  "CSS.styleSheetChanged": CSS_styleSheetChangedEvent,
  "CSS.styleSheetRemoved": CSS_styleSheetRemovedEvent,
  "Cast.sinksUpdated": Cast_sinksUpdatedEvent,
  "Cast.issueUpdated": Cast_issueUpdatedEvent,
  "DOM.attributeModified": DOM_attributeModifiedEvent,
  "DOM.attributeRemoved": DOM_attributeRemovedEvent,
  "DOM.characterDataModified": DOM_characterDataModifiedEvent,
  "DOM.childNodeCountUpdated": DOM_childNodeCountUpdatedEvent,
  "DOM.childNodeInserted": DOM_childNodeInsertedEvent,
  "DOM.childNodeRemoved": DOM_childNodeRemovedEvent,
  "DOM.distributedNodesUpdated": DOM_distributedNodesUpdatedEvent,
  "DOM.documentUpdated": Event,
  "DOM.inlineStyleInvalidated": DOM_inlineStyleInvalidatedEvent,
  "DOM.pseudoElementAdded": DOM_pseudoElementAddedEvent,
  "DOM.topLayerElementsUpdated": Event,
  "DOM.pseudoElementRemoved": DOM_pseudoElementRemovedEvent,
  "DOM.setChildNodes": DOM_setChildNodesEvent,
  "DOM.shadowRootPopped": DOM_shadowRootPoppedEvent,
  "DOM.shadowRootPushed": DOM_shadowRootPushedEvent,
  "DOMStorage.domStorageItemAdded": DOMStorage_domStorageItemAddedEvent,
  "DOMStorage.domStorageItemRemoved": DOMStorage_domStorageItemRemovedEvent,
  "DOMStorage.domStorageItemUpdated": DOMStorage_domStorageItemUpdatedEvent,
  "DOMStorage.domStorageItemsCleared": DOMStorage_domStorageItemsClearedEvent,
  "Database.addDatabase": Database_addDatabaseEvent,
  "Emulation.virtualTimeBudgetExpired": Event,
  "Input.dragIntercepted": Input_dragInterceptedEvent,
  "Inspector.detached": Inspector_detachedEvent,
  "Inspector.targetCrashed": Event,
  "Inspector.targetReloadedAfterCrash": Event,
  "LayerTree.layerPainted": LayerTree_layerPaintedEvent,
  "LayerTree.layerTreeDidChange": LayerTree_layerTreeDidChangeEvent,
  "Log.entryAdded": Log_entryAddedEvent,
  "Network.dataReceived": Network_dataReceivedEvent,
  "Network.eventSourceMessageReceived": Network_eventSourceMessageReceivedEvent,
  "Network.loadingFailed": Network_loadingFailedEvent,
  "Network.loadingFinished": Network_loadingFinishedEvent,
  "Network.requestIntercepted": Network_requestInterceptedEvent,
  "Network.requestServedFromCache": Network_requestServedFromCacheEvent,
  "Network.requestWillBeSent": Network_requestWillBeSentEvent,
  "Network.resourceChangedPriority": Network_resourceChangedPriorityEvent,
  "Network.signedExchangeReceived": Network_signedExchangeReceivedEvent,
  "Network.responseReceived": Network_responseReceivedEvent,
  "Network.webSocketClosed": Network_webSocketClosedEvent,
  "Network.webSocketCreated": Network_webSocketCreatedEvent,
  "Network.webSocketFrameError": Network_webSocketFrameErrorEvent,
  "Network.webSocketFrameReceived": Network_webSocketFrameReceivedEvent,
  "Network.webSocketFrameSent": Network_webSocketFrameSentEvent,
  "Network.webSocketHandshakeResponseReceived":
    Network_webSocketHandshakeResponseReceivedEvent,
  "Network.webSocketWillSendHandshakeRequest":
    Network_webSocketWillSendHandshakeRequestEvent,
  "Network.webTransportCreated": Network_webTransportCreatedEvent,
  "Network.webTransportConnectionEstablished":
    Network_webTransportConnectionEstablishedEvent,
  "Network.webTransportClosed": Network_webTransportClosedEvent,
  "Network.requestWillBeSentExtraInfo": Network_requestWillBeSentExtraInfoEvent,
  "Network.responseReceivedExtraInfo": Network_responseReceivedExtraInfoEvent,
  "Network.responseReceivedEarlyHints": Network_responseReceivedEarlyHintsEvent,
  "Network.trustTokenOperationDone": Network_trustTokenOperationDoneEvent,
  "Network.subresourceWebBundleMetadataReceived":
    Network_subresourceWebBundleMetadataReceivedEvent,
  "Network.subresourceWebBundleMetadataError":
    Network_subresourceWebBundleMetadataErrorEvent,
  "Network.subresourceWebBundleInnerResponseParsed":
    Network_subresourceWebBundleInnerResponseParsedEvent,
  "Network.subresourceWebBundleInnerResponseError":
    Network_subresourceWebBundleInnerResponseErrorEvent,
  "Network.reportingApiReportAdded": Network_reportingApiReportAddedEvent,
  "Network.reportingApiReportUpdated": Network_reportingApiReportUpdatedEvent,
  "Network.reportingApiEndpointsChangedForOrigin":
    Network_reportingApiEndpointsChangedForOriginEvent,
  "Overlay.inspectNodeRequested": Overlay_inspectNodeRequestedEvent,
  "Overlay.nodeHighlightRequested": Overlay_nodeHighlightRequestedEvent,
  "Overlay.screenshotRequested": Overlay_screenshotRequestedEvent,
  "Overlay.inspectModeCanceled": Event,
  "Page.domContentEventFired": Page_domContentEventFiredEvent,
  "Page.fileChooserOpened": Page_fileChooserOpenedEvent,
  "Page.frameAttached": Page_frameAttachedEvent,
  "Page.frameClearedScheduledNavigation":
    Page_frameClearedScheduledNavigationEvent,
  "Page.frameDetached": Page_frameDetachedEvent,
  "Page.frameNavigated": Page_frameNavigatedEvent,
  "Page.documentOpened": Page_documentOpenedEvent,
  "Page.frameResized": Event,
  "Page.frameRequestedNavigation": Page_frameRequestedNavigationEvent,
  "Page.frameScheduledNavigation": Page_frameScheduledNavigationEvent,
  "Page.frameStartedLoading": Page_frameStartedLoadingEvent,
  "Page.frameStoppedLoading": Page_frameStoppedLoadingEvent,
  "Page.downloadWillBegin": Page_downloadWillBeginEvent,
  "Page.downloadProgress": Page_downloadProgressEvent,
  "Page.interstitialHidden": Event,
  "Page.interstitialShown": Event,
  "Page.javascriptDialogClosed": Page_javascriptDialogClosedEvent,
  "Page.javascriptDialogOpening": Page_javascriptDialogOpeningEvent,
  "Page.lifecycleEvent": Page_lifecycleEventEvent,
  "Page.backForwardCacheNotUsed": Page_backForwardCacheNotUsedEvent,
  "Page.loadEventFired": Page_loadEventFiredEvent,
  "Page.navigatedWithinDocument": Page_navigatedWithinDocumentEvent,
  "Page.screencastFrame": Page_screencastFrameEvent,
  "Page.screencastVisibilityChanged": Page_screencastVisibilityChangedEvent,
  "Page.windowOpen": Page_windowOpenEvent,
  "Page.compilationCacheProduced": Page_compilationCacheProducedEvent,
  "Performance.metrics": Performance_metricsEvent,
  "PerformanceTimeline.timelineEventAdded":
    PerformanceTimeline_timelineEventAddedEvent,
  "Security.certificateError": Security_certificateErrorEvent,
  "Security.visibleSecurityStateChanged":
    Security_visibleSecurityStateChangedEvent,
  "Security.securityStateChanged": Security_securityStateChangedEvent,
  "ServiceWorker.workerErrorReported": ServiceWorker_workerErrorReportedEvent,
  "ServiceWorker.workerRegistrationUpdated":
    ServiceWorker_workerRegistrationUpdatedEvent,
  "ServiceWorker.workerVersionUpdated": ServiceWorker_workerVersionUpdatedEvent,
  "Storage.cacheStorageContentUpdated": Storage_cacheStorageContentUpdatedEvent,
  "Storage.cacheStorageListUpdated": Storage_cacheStorageListUpdatedEvent,
  "Storage.indexedDBContentUpdated": Storage_indexedDBContentUpdatedEvent,
  "Storage.indexedDBListUpdated": Storage_indexedDBListUpdatedEvent,
  "Storage.interestGroupAccessed": Storage_interestGroupAccessedEvent,
  "Storage.interestGroupAuctionEventOccurred":
    Storage_interestGroupAuctionEventOccurredEvent,
  "Storage.interestGroupAuctionNetworkRequestCreated":
    Storage_interestGroupAuctionNetworkRequestCreatedEvent,
  "Storage.sharedStorageAccessed": Storage_sharedStorageAccessedEvent,
  "Storage.storageBucketCreatedOrUpdated":
    Storage_storageBucketCreatedOrUpdatedEvent,
  "Storage.storageBucketDeleted": Storage_storageBucketDeletedEvent,
  "Storage.attributionReportingSourceRegistered":
    Storage_attributionReportingSourceRegisteredEvent,
  "Storage.attributionReportingTriggerRegistered":
    Storage_attributionReportingTriggerRegisteredEvent,
  "Target.attachedToTarget": Target_attachedToTargetEvent,
  "Target.detachedFromTarget": Target_detachedFromTargetEvent,
  "Target.receivedMessageFromTarget": Target_receivedMessageFromTargetEvent,
  "Target.targetCreated": Target_targetCreatedEvent,
  "Target.targetDestroyed": Target_targetDestroyedEvent,
  "Target.targetCrashed": Target_targetCrashedEvent,
  "Target.targetInfoChanged": Target_targetInfoChangedEvent,
  "Tethering.accepted": Tethering_acceptedEvent,
  "Tracing.bufferUsage": Tracing_bufferUsageEvent,
  "Tracing.dataCollected": Tracing_dataCollectedEvent,
  "Tracing.tracingComplete": Tracing_tracingCompleteEvent,
  "Fetch.requestPaused": Fetch_requestPausedEvent,
  "Fetch.authRequired": Fetch_authRequiredEvent,
  "WebAudio.contextCreated": WebAudio_contextCreatedEvent,
  "WebAudio.contextWillBeDestroyed": WebAudio_contextWillBeDestroyedEvent,
  "WebAudio.contextChanged": WebAudio_contextChangedEvent,
  "WebAudio.audioListenerCreated": WebAudio_audioListenerCreatedEvent,
  "WebAudio.audioListenerWillBeDestroyed":
    WebAudio_audioListenerWillBeDestroyedEvent,
  "WebAudio.audioNodeCreated": WebAudio_audioNodeCreatedEvent,
  "WebAudio.audioNodeWillBeDestroyed": WebAudio_audioNodeWillBeDestroyedEvent,
  "WebAudio.audioParamCreated": WebAudio_audioParamCreatedEvent,
  "WebAudio.audioParamWillBeDestroyed": WebAudio_audioParamWillBeDestroyedEvent,
  "WebAudio.nodesConnected": WebAudio_nodesConnectedEvent,
  "WebAudio.nodesDisconnected": WebAudio_nodesDisconnectedEvent,
  "WebAudio.nodeParamConnected": WebAudio_nodeParamConnectedEvent,
  "WebAudio.nodeParamDisconnected": WebAudio_nodeParamDisconnectedEvent,
  "WebAuthn.credentialAdded": WebAuthn_credentialAddedEvent,
  "WebAuthn.credentialAsserted": WebAuthn_credentialAssertedEvent,
  "Media.playerPropertiesChanged": Media_playerPropertiesChangedEvent,
  "Media.playerEventsAdded": Media_playerEventsAddedEvent,
  "Media.playerMessagesLogged": Media_playerMessagesLoggedEvent,
  "Media.playerErrorsRaised": Media_playerErrorsRaisedEvent,
  "Media.playersCreated": Media_playersCreatedEvent,
  "DeviceAccess.deviceRequestPrompted": DeviceAccess_deviceRequestPromptedEvent,
  "Preload.ruleSetUpdated": Preload_ruleSetUpdatedEvent,
  "Preload.ruleSetRemoved": Preload_ruleSetRemovedEvent,
  "Preload.preloadEnabledStateUpdated": Preload_preloadEnabledStateUpdatedEvent,
  "Preload.prefetchStatusUpdated": Preload_prefetchStatusUpdatedEvent,
  "Preload.prerenderStatusUpdated": Preload_prerenderStatusUpdatedEvent,
  "Preload.preloadingAttemptSourcesUpdated":
    Preload_preloadingAttemptSourcesUpdatedEvent,
  "FedCm.dialogShown": FedCm_dialogShownEvent,
  "FedCm.dialogClosed": FedCm_dialogClosedEvent,
  "Console.messageAdded": Console_messageAddedEvent,
  "Debugger.breakpointResolved": Debugger_breakpointResolvedEvent,
  "Debugger.paused": Debugger_pausedEvent,
  "Debugger.resumed": Event,
  "Debugger.scriptFailedToParse": Debugger_scriptFailedToParseEvent,
  "Debugger.scriptParsed": Debugger_scriptParsedEvent,
  "HeapProfiler.addHeapSnapshotChunk": HeapProfiler_addHeapSnapshotChunkEvent,
  "HeapProfiler.heapStatsUpdate": HeapProfiler_heapStatsUpdateEvent,
  "HeapProfiler.lastSeenObjectId": HeapProfiler_lastSeenObjectIdEvent,
  "HeapProfiler.reportHeapSnapshotProgress":
    HeapProfiler_reportHeapSnapshotProgressEvent,
  "HeapProfiler.resetProfiles": Event,
  "Profiler.consoleProfileFinished": Profiler_consoleProfileFinishedEvent,
  "Profiler.consoleProfileStarted": Profiler_consoleProfileStartedEvent,
  "Profiler.preciseCoverageDeltaUpdate":
    Profiler_preciseCoverageDeltaUpdateEvent,
  "Runtime.bindingCalled": Runtime_bindingCalledEvent,
  "Runtime.consoleAPICalled": Runtime_consoleAPICalledEvent,
  "Runtime.exceptionRevoked": Runtime_exceptionRevokedEvent,
  "Runtime.exceptionThrown": Runtime_exceptionThrownEvent,
  "Runtime.executionContextCreated": Runtime_executionContextCreatedEvent,
  "Runtime.executionContextDestroyed": Runtime_executionContextDestroyedEvent,
  "Runtime.executionContextsCleared": Event,
  "Runtime.inspectRequested": Runtime_inspectRequestedEvent,
};

export interface CelestialEventMap {
  "Accessibility.loadComplete": Accessibility_loadCompleteEvent;
  "Accessibility.nodesUpdated": Accessibility_nodesUpdatedEvent;
  "Animation.animationCanceled": Animation_animationCanceledEvent;
  "Animation.animationCreated": Animation_animationCreatedEvent;
  "Animation.animationStarted": Animation_animationStartedEvent;
  "Audits.issueAdded": Audits_issueAddedEvent;
  "Autofill.addressFormFilled": Autofill_addressFormFilledEvent;
  "BackgroundService.recordingStateChanged":
    BackgroundService_recordingStateChangedEvent;
  "BackgroundService.backgroundServiceEventReceived":
    BackgroundService_backgroundServiceEventReceivedEvent;
  "Browser.downloadWillBegin": Browser_downloadWillBeginEvent;
  "Browser.downloadProgress": Browser_downloadProgressEvent;
  "CSS.fontsUpdated": CSS_fontsUpdatedEvent;
  "CSS.mediaQueryResultChanged": Event;
  "CSS.styleSheetAdded": CSS_styleSheetAddedEvent;
  "CSS.styleSheetChanged": CSS_styleSheetChangedEvent;
  "CSS.styleSheetRemoved": CSS_styleSheetRemovedEvent;
  "Cast.sinksUpdated": Cast_sinksUpdatedEvent;
  "Cast.issueUpdated": Cast_issueUpdatedEvent;
  "DOM.attributeModified": DOM_attributeModifiedEvent;
  "DOM.attributeRemoved": DOM_attributeRemovedEvent;
  "DOM.characterDataModified": DOM_characterDataModifiedEvent;
  "DOM.childNodeCountUpdated": DOM_childNodeCountUpdatedEvent;
  "DOM.childNodeInserted": DOM_childNodeInsertedEvent;
  "DOM.childNodeRemoved": DOM_childNodeRemovedEvent;
  "DOM.distributedNodesUpdated": DOM_distributedNodesUpdatedEvent;
  "DOM.documentUpdated": Event;
  "DOM.inlineStyleInvalidated": DOM_inlineStyleInvalidatedEvent;
  "DOM.pseudoElementAdded": DOM_pseudoElementAddedEvent;
  "DOM.topLayerElementsUpdated": Event;
  "DOM.pseudoElementRemoved": DOM_pseudoElementRemovedEvent;
  "DOM.setChildNodes": DOM_setChildNodesEvent;
  "DOM.shadowRootPopped": DOM_shadowRootPoppedEvent;
  "DOM.shadowRootPushed": DOM_shadowRootPushedEvent;
  "DOMStorage.domStorageItemAdded": DOMStorage_domStorageItemAddedEvent;
  "DOMStorage.domStorageItemRemoved": DOMStorage_domStorageItemRemovedEvent;
  "DOMStorage.domStorageItemUpdated": DOMStorage_domStorageItemUpdatedEvent;
  "DOMStorage.domStorageItemsCleared": DOMStorage_domStorageItemsClearedEvent;
  "Database.addDatabase": Database_addDatabaseEvent;
  "Emulation.virtualTimeBudgetExpired": Event;
  "Input.dragIntercepted": Input_dragInterceptedEvent;
  "Inspector.detached": Inspector_detachedEvent;
  "Inspector.targetCrashed": Event;
  "Inspector.targetReloadedAfterCrash": Event;
  "LayerTree.layerPainted": LayerTree_layerPaintedEvent;
  "LayerTree.layerTreeDidChange": LayerTree_layerTreeDidChangeEvent;
  "Log.entryAdded": Log_entryAddedEvent;
  "Network.dataReceived": Network_dataReceivedEvent;
  "Network.eventSourceMessageReceived": Network_eventSourceMessageReceivedEvent;
  "Network.loadingFailed": Network_loadingFailedEvent;
  "Network.loadingFinished": Network_loadingFinishedEvent;
  "Network.requestIntercepted": Network_requestInterceptedEvent;
  "Network.requestServedFromCache": Network_requestServedFromCacheEvent;
  "Network.requestWillBeSent": Network_requestWillBeSentEvent;
  "Network.resourceChangedPriority": Network_resourceChangedPriorityEvent;
  "Network.signedExchangeReceived": Network_signedExchangeReceivedEvent;
  "Network.responseReceived": Network_responseReceivedEvent;
  "Network.webSocketClosed": Network_webSocketClosedEvent;
  "Network.webSocketCreated": Network_webSocketCreatedEvent;
  "Network.webSocketFrameError": Network_webSocketFrameErrorEvent;
  "Network.webSocketFrameReceived": Network_webSocketFrameReceivedEvent;
  "Network.webSocketFrameSent": Network_webSocketFrameSentEvent;
  "Network.webSocketHandshakeResponseReceived":
    Network_webSocketHandshakeResponseReceivedEvent;
  "Network.webSocketWillSendHandshakeRequest":
    Network_webSocketWillSendHandshakeRequestEvent;
  "Network.webTransportCreated": Network_webTransportCreatedEvent;
  "Network.webTransportConnectionEstablished":
    Network_webTransportConnectionEstablishedEvent;
  "Network.webTransportClosed": Network_webTransportClosedEvent;
  "Network.requestWillBeSentExtraInfo": Network_requestWillBeSentExtraInfoEvent;
  "Network.responseReceivedExtraInfo": Network_responseReceivedExtraInfoEvent;
  "Network.responseReceivedEarlyHints": Network_responseReceivedEarlyHintsEvent;
  "Network.trustTokenOperationDone": Network_trustTokenOperationDoneEvent;
  "Network.subresourceWebBundleMetadataReceived":
    Network_subresourceWebBundleMetadataReceivedEvent;
  "Network.subresourceWebBundleMetadataError":
    Network_subresourceWebBundleMetadataErrorEvent;
  "Network.subresourceWebBundleInnerResponseParsed":
    Network_subresourceWebBundleInnerResponseParsedEvent;
  "Network.subresourceWebBundleInnerResponseError":
    Network_subresourceWebBundleInnerResponseErrorEvent;
  "Network.reportingApiReportAdded": Network_reportingApiReportAddedEvent;
  "Network.reportingApiReportUpdated": Network_reportingApiReportUpdatedEvent;
  "Network.reportingApiEndpointsChangedForOrigin":
    Network_reportingApiEndpointsChangedForOriginEvent;
  "Overlay.inspectNodeRequested": Overlay_inspectNodeRequestedEvent;
  "Overlay.nodeHighlightRequested": Overlay_nodeHighlightRequestedEvent;
  "Overlay.screenshotRequested": Overlay_screenshotRequestedEvent;
  "Overlay.inspectModeCanceled": Event;
  "Page.domContentEventFired": Page_domContentEventFiredEvent;
  "Page.fileChooserOpened": Page_fileChooserOpenedEvent;
  "Page.frameAttached": Page_frameAttachedEvent;
  "Page.frameClearedScheduledNavigation":
    Page_frameClearedScheduledNavigationEvent;
  "Page.frameDetached": Page_frameDetachedEvent;
  "Page.frameNavigated": Page_frameNavigatedEvent;
  "Page.documentOpened": Page_documentOpenedEvent;
  "Page.frameResized": Event;
  "Page.frameRequestedNavigation": Page_frameRequestedNavigationEvent;
  "Page.frameScheduledNavigation": Page_frameScheduledNavigationEvent;
  "Page.frameStartedLoading": Page_frameStartedLoadingEvent;
  "Page.frameStoppedLoading": Page_frameStoppedLoadingEvent;
  "Page.downloadWillBegin": Page_downloadWillBeginEvent;
  "Page.downloadProgress": Page_downloadProgressEvent;
  "Page.interstitialHidden": Event;
  "Page.interstitialShown": Event;
  "Page.javascriptDialogClosed": Page_javascriptDialogClosedEvent;
  "Page.javascriptDialogOpening": Page_javascriptDialogOpeningEvent;
  "Page.lifecycleEvent": Page_lifecycleEventEvent;
  "Page.backForwardCacheNotUsed": Page_backForwardCacheNotUsedEvent;
  "Page.loadEventFired": Page_loadEventFiredEvent;
  "Page.navigatedWithinDocument": Page_navigatedWithinDocumentEvent;
  "Page.screencastFrame": Page_screencastFrameEvent;
  "Page.screencastVisibilityChanged": Page_screencastVisibilityChangedEvent;
  "Page.windowOpen": Page_windowOpenEvent;
  "Page.compilationCacheProduced": Page_compilationCacheProducedEvent;
  "Performance.metrics": Performance_metricsEvent;
  "PerformanceTimeline.timelineEventAdded":
    PerformanceTimeline_timelineEventAddedEvent;
  "Security.certificateError": Security_certificateErrorEvent;
  "Security.visibleSecurityStateChanged":
    Security_visibleSecurityStateChangedEvent;
  "Security.securityStateChanged": Security_securityStateChangedEvent;
  "ServiceWorker.workerErrorReported": ServiceWorker_workerErrorReportedEvent;
  "ServiceWorker.workerRegistrationUpdated":
    ServiceWorker_workerRegistrationUpdatedEvent;
  "ServiceWorker.workerVersionUpdated": ServiceWorker_workerVersionUpdatedEvent;
  "Storage.cacheStorageContentUpdated": Storage_cacheStorageContentUpdatedEvent;
  "Storage.cacheStorageListUpdated": Storage_cacheStorageListUpdatedEvent;
  "Storage.indexedDBContentUpdated": Storage_indexedDBContentUpdatedEvent;
  "Storage.indexedDBListUpdated": Storage_indexedDBListUpdatedEvent;
  "Storage.interestGroupAccessed": Storage_interestGroupAccessedEvent;
  "Storage.interestGroupAuctionEventOccurred":
    Storage_interestGroupAuctionEventOccurredEvent;
  "Storage.interestGroupAuctionNetworkRequestCreated":
    Storage_interestGroupAuctionNetworkRequestCreatedEvent;
  "Storage.sharedStorageAccessed": Storage_sharedStorageAccessedEvent;
  "Storage.storageBucketCreatedOrUpdated":
    Storage_storageBucketCreatedOrUpdatedEvent;
  "Storage.storageBucketDeleted": Storage_storageBucketDeletedEvent;
  "Storage.attributionReportingSourceRegistered":
    Storage_attributionReportingSourceRegisteredEvent;
  "Storage.attributionReportingTriggerRegistered":
    Storage_attributionReportingTriggerRegisteredEvent;
  "Target.attachedToTarget": Target_attachedToTargetEvent;
  "Target.detachedFromTarget": Target_detachedFromTargetEvent;
  "Target.receivedMessageFromTarget": Target_receivedMessageFromTargetEvent;
  "Target.targetCreated": Target_targetCreatedEvent;
  "Target.targetDestroyed": Target_targetDestroyedEvent;
  "Target.targetCrashed": Target_targetCrashedEvent;
  "Target.targetInfoChanged": Target_targetInfoChangedEvent;
  "Tethering.accepted": Tethering_acceptedEvent;
  "Tracing.bufferUsage": Tracing_bufferUsageEvent;
  "Tracing.dataCollected": Tracing_dataCollectedEvent;
  "Tracing.tracingComplete": Tracing_tracingCompleteEvent;
  "Fetch.requestPaused": Fetch_requestPausedEvent;
  "Fetch.authRequired": Fetch_authRequiredEvent;
  "WebAudio.contextCreated": WebAudio_contextCreatedEvent;
  "WebAudio.contextWillBeDestroyed": WebAudio_contextWillBeDestroyedEvent;
  "WebAudio.contextChanged": WebAudio_contextChangedEvent;
  "WebAudio.audioListenerCreated": WebAudio_audioListenerCreatedEvent;
  "WebAudio.audioListenerWillBeDestroyed":
    WebAudio_audioListenerWillBeDestroyedEvent;
  "WebAudio.audioNodeCreated": WebAudio_audioNodeCreatedEvent;
  "WebAudio.audioNodeWillBeDestroyed": WebAudio_audioNodeWillBeDestroyedEvent;
  "WebAudio.audioParamCreated": WebAudio_audioParamCreatedEvent;
  "WebAudio.audioParamWillBeDestroyed": WebAudio_audioParamWillBeDestroyedEvent;
  "WebAudio.nodesConnected": WebAudio_nodesConnectedEvent;
  "WebAudio.nodesDisconnected": WebAudio_nodesDisconnectedEvent;
  "WebAudio.nodeParamConnected": WebAudio_nodeParamConnectedEvent;
  "WebAudio.nodeParamDisconnected": WebAudio_nodeParamDisconnectedEvent;
  "WebAuthn.credentialAdded": WebAuthn_credentialAddedEvent;
  "WebAuthn.credentialAsserted": WebAuthn_credentialAssertedEvent;
  "Media.playerPropertiesChanged": Media_playerPropertiesChangedEvent;
  "Media.playerEventsAdded": Media_playerEventsAddedEvent;
  "Media.playerMessagesLogged": Media_playerMessagesLoggedEvent;
  "Media.playerErrorsRaised": Media_playerErrorsRaisedEvent;
  "Media.playersCreated": Media_playersCreatedEvent;
  "DeviceAccess.deviceRequestPrompted": DeviceAccess_deviceRequestPromptedEvent;
  "Preload.ruleSetUpdated": Preload_ruleSetUpdatedEvent;
  "Preload.ruleSetRemoved": Preload_ruleSetRemovedEvent;
  "Preload.preloadEnabledStateUpdated": Preload_preloadEnabledStateUpdatedEvent;
  "Preload.prefetchStatusUpdated": Preload_prefetchStatusUpdatedEvent;
  "Preload.prerenderStatusUpdated": Preload_prerenderStatusUpdatedEvent;
  "Preload.preloadingAttemptSourcesUpdated":
    Preload_preloadingAttemptSourcesUpdatedEvent;
  "FedCm.dialogShown": FedCm_dialogShownEvent;
  "FedCm.dialogClosed": FedCm_dialogClosedEvent;
  "Console.messageAdded": Console_messageAddedEvent;
  "Debugger.breakpointResolved": Debugger_breakpointResolvedEvent;
  "Debugger.paused": Debugger_pausedEvent;
  "Debugger.resumed": Event;
  "Debugger.scriptFailedToParse": Debugger_scriptFailedToParseEvent;
  "Debugger.scriptParsed": Debugger_scriptParsedEvent;
  "HeapProfiler.addHeapSnapshotChunk": HeapProfiler_addHeapSnapshotChunkEvent;
  "HeapProfiler.heapStatsUpdate": HeapProfiler_heapStatsUpdateEvent;
  "HeapProfiler.lastSeenObjectId": HeapProfiler_lastSeenObjectIdEvent;
  "HeapProfiler.reportHeapSnapshotProgress":
    HeapProfiler_reportHeapSnapshotProgressEvent;
  "HeapProfiler.resetProfiles": Event;
  "Profiler.consoleProfileFinished": Profiler_consoleProfileFinishedEvent;
  "Profiler.consoleProfileStarted": Profiler_consoleProfileStartedEvent;
  "Profiler.preciseCoverageDeltaUpdate":
    Profiler_preciseCoverageDeltaUpdateEvent;
  "Runtime.bindingCalled": Runtime_bindingCalledEvent;
  "Runtime.consoleAPICalled": Runtime_consoleAPICalledEvent;
  "Runtime.exceptionRevoked": Runtime_exceptionRevokedEvent;
  "Runtime.exceptionThrown": Runtime_exceptionThrownEvent;
  "Runtime.executionContextCreated": Runtime_executionContextCreatedEvent;
  "Runtime.executionContextDestroyed": Runtime_executionContextDestroyedEvent;
  "Runtime.executionContextsCleared": Event;
  "Runtime.inspectRequested": Runtime_inspectRequestedEvent;
}

export class Celestial extends EventTarget {
  ws: WebSocket;
  #wsClosed: Promise<unknown>;
  #id = 0;
  #handlers: Map<number, (value: unknown) => void> = new Map();

  /**
   * Celestial expects a open websocket to communicate over
   */
  constructor(ws: WebSocket) {
    super();

    this.ws = ws;

    if (DEBUG) {
      attachWs(ws);
    }

    this.ws.onmessage = (e) => {
      const data = JSON.parse(e.data);

      const handler = this.#handlers.get(data.id);

      if (handler) {
        handler(data.result);
        this.#handlers.delete(data.id);
      } else {
        const className =
          CelestialEvents[data.method as keyof CelestialEventMap];
        if (className === undefined) {
          if (DEBUG) {
            console.error("[CELESTIAL] Unknown event", data);
          }
          return;
        }
        if (data.params) {
          this.dispatchEvent(new className(data.params));
        } else {
          // @ts-ignore trust me
          this.dispatchEvent(new className());
        }
      }
    };

    const { promise, resolve } = Promise.withResolvers();
    this.#wsClosed = promise;
    const closed = () => {
      if (this.ws.readyState === WebSocket.CLOSED) {
        resolve(true);
        return;
      }
      setTimeout(closed, 100);
    };
    this.ws.onclose = closed;
  }

  /**
   * Close the websocket connection, does nothing if already closed.
   */
  async close() {
    this.ws.close();
    await this.#wsClosed;
  }

  // @ts-ignore everything is fine
  addEventListener<K extends keyof CelestialEventMap>(
    type: K,
    listener: (this: Celestial, ev: CelestialEventMap[K]) => any,
    options?: boolean | AddEventListenerOptions,
  ): void {
    // @ts-ignore and I am calm.
    super.addEventListener(type, listener, options);
  }

  #sendReq(method: string, params?: unknown): Promise<any> {
    this.ws.send(JSON.stringify({
      id: ++this.#id,
      method,
      params,
    }));

    return new Promise((res) => {
      this.#handlers.set(this.#id, res);
    });
  }
  /**
   * @experimental
   */
  Accessibility = {
    /**
     * Disables the accessibility domain.
     */

    disable: async (): Promise<void> => {
      return await this.#sendReq("Accessibility.disable");
    },

    /**
     * Enables the accessibility domain which causes `AXNodeId`s to remain consistent between method calls.
     * This turns on accessibility for the page, which can impact performance until accessibility is disabled.
     */

    enable: async (): Promise<void> => {
      return await this.#sendReq("Accessibility.enable");
    },

    /**
     * @experimental
     * Fetches the accessibility node and partial accessibility tree for this DOM node, if it exists.
     */

    getPartialAXTree: async (opts: {
      /**
       * Identifier of the node to get the partial accessibility tree for.
       */
      nodeId?: DOM_NodeId;
      /**
       * Identifier of the backend node to get the partial accessibility tree for.
       */
      backendNodeId?: DOM_BackendNodeId;
      /**
       * JavaScript object id of the node wrapper to get the partial accessibility tree for.
       */
      objectId?: Runtime_RemoteObjectId;
      /**
       * Whether to fetch this node's ancestors, siblings and children. Defaults to true.
       */
      fetchRelatives?: boolean;
    }): Promise<{
      /**
       * The `Accessibility.AXNode` for this DOM node, if it exists, plus its ancestors, siblings and
       * children, if requested.
       */
      nodes: Accessibility_AXNode[];
    }> => {
      return await this.#sendReq("Accessibility.getPartialAXTree", opts);
    },

    /**
     * @experimental
     * Fetches the entire accessibility tree for the root Document
     */

    getFullAXTree: async (opts: {
      /**
       * The maximum depth at which descendants of the root node should be retrieved.
       * If omitted, the full tree is returned.
       */
      depth?: number;
      /**
       * The frame for whose document the AX tree should be retrieved.
       * If omitted, the root frame is used.
       */
      frameId?: Page_FrameId;
    }): Promise<{ nodes: Accessibility_AXNode[] }> => {
      return await this.#sendReq("Accessibility.getFullAXTree", opts);
    },

    /**
     * @experimental
     * Fetches the root node.
     * Requires `enable()` to have been called previously.
     */

    getRootAXNode: async (opts: {
      /**
       * The frame in whose document the node resides.
       * If omitted, the root frame is used.
       */
      frameId?: Page_FrameId;
    }): Promise<{ node: Accessibility_AXNode }> => {
      return await this.#sendReq("Accessibility.getRootAXNode", opts);
    },

    /**
     * @experimental
     * Fetches a node and all ancestors up to and including the root.
     * Requires `enable()` to have been called previously.
     */

    getAXNodeAndAncestors: async (opts: {
      /**
       * Identifier of the node to get.
       */
      nodeId?: DOM_NodeId;
      /**
       * Identifier of the backend node to get.
       */
      backendNodeId?: DOM_BackendNodeId;
      /**
       * JavaScript object id of the node wrapper to get.
       */
      objectId?: Runtime_RemoteObjectId;
    }): Promise<{ nodes: Accessibility_AXNode[] }> => {
      return await this.#sendReq("Accessibility.getAXNodeAndAncestors", opts);
    },

    /**
     * @experimental
     * Fetches a particular accessibility node by AXNodeId.
     * Requires `enable()` to have been called previously.
     */

    getChildAXNodes: async (opts: {
      id: Accessibility_AXNodeId;
      /**
       * The frame in whose document the node resides.
       * If omitted, the root frame is used.
       */
      frameId?: Page_FrameId;
    }): Promise<{ nodes: Accessibility_AXNode[] }> => {
      return await this.#sendReq("Accessibility.getChildAXNodes", opts);
    },

    /**
     * @experimental
     * Query a DOM node's accessibility subtree for accessible name and role.
     * This command computes the name and role for all nodes in the subtree, including those that are
     * ignored for accessibility, and returns those that match the specified name and role. If no DOM
     * node is specified, or the DOM node does not exist, the command returns an error. If neither
     * `accessibleName` or `role` is specified, it returns all the accessibility nodes in the subtree.
     */

    queryAXTree: async (opts: {
      /**
       * Identifier of the node for the root to query.
       */
      nodeId?: DOM_NodeId;
      /**
       * Identifier of the backend node for the root to query.
       */
      backendNodeId?: DOM_BackendNodeId;
      /**
       * JavaScript object id of the node wrapper for the root to query.
       */
      objectId?: Runtime_RemoteObjectId;
      /**
       * Find nodes with this computed name.
       */
      accessibleName?: string;
      /**
       * Find nodes with this computed role.
       */
      role?: string;
    }): Promise<{
      /**
       * A list of `Accessibility.AXNode` matching the specified attributes,
       * including nodes that are ignored for accessibility.
       */
      nodes: Accessibility_AXNode[];
    }> => {
      return await this.#sendReq("Accessibility.queryAXTree", opts);
    },
  };

  /**
   * @experimental
   */
  Animation = {
    /**
     * Disables animation domain notifications.
     */

    disable: async (): Promise<void> => {
      return await this.#sendReq("Animation.disable");
    },

    /**
     * Enables animation domain notifications.
     */

    enable: async (): Promise<void> => {
      return await this.#sendReq("Animation.enable");
    },

    /**
     * Returns the current time of the an animation.
     */

    getCurrentTime: async (opts: {
      /**
       * Id of animation.
       */
      id: string;
    }): Promise<{
      /**
       * Current time of the page.
       */
      currentTime: number;
    }> => {
      return await this.#sendReq("Animation.getCurrentTime", opts);
    },

    /**
     * Gets the playback rate of the document timeline.
     */

    getPlaybackRate: async (): Promise<{
      /**
       * Playback rate for animations on page.
       */
      playbackRate: number;
    }> => {
      return await this.#sendReq("Animation.getPlaybackRate");
    },

    /**
     * Releases a set of animations to no longer be manipulated.
     */

    releaseAnimations: async (opts: {
      /**
       * List of animation ids to seek.
       */
      animations: string[];
    }): Promise<void> => {
      return await this.#sendReq("Animation.releaseAnimations", opts);
    },

    /**
     * Gets the remote object of the Animation.
     */

    resolveAnimation: async (opts: {
      /**
       * Animation id.
       */
      animationId: string;
    }): Promise<{
      /**
       * Corresponding remote object.
       */
      remoteObject: Runtime_RemoteObject;
    }> => {
      return await this.#sendReq("Animation.resolveAnimation", opts);
    },

    /**
     * Seek a set of animations to a particular time within each animation.
     */

    seekAnimations: async (opts: {
      /**
       * List of animation ids to seek.
       */
      animations: string[];
      /**
       * Set the current time of each animation.
       */
      currentTime: number;
    }): Promise<void> => {
      return await this.#sendReq("Animation.seekAnimations", opts);
    },

    /**
     * Sets the paused state of a set of animations.
     */

    setPaused: async (opts: {
      /**
       * Animations to set the pause state of.
       */
      animations: string[];
      /**
       * Paused state to set to.
       */
      paused: boolean;
    }): Promise<void> => {
      return await this.#sendReq("Animation.setPaused", opts);
    },

    /**
     * Sets the playback rate of the document timeline.
     */

    setPlaybackRate: async (opts: {
      /**
       * Playback rate for animations on page
       */
      playbackRate: number;
    }): Promise<void> => {
      return await this.#sendReq("Animation.setPlaybackRate", opts);
    },

    /**
     * Sets the timing of an animation node.
     */

    setTiming: async (opts: {
      /**
       * Animation id.
       */
      animationId: string;
      /**
       * Duration of the animation.
       */
      duration: number;
      /**
       * Delay of the animation.
       */
      delay: number;
    }): Promise<void> => {
      return await this.#sendReq("Animation.setTiming", opts);
    },
  };

  /**
   * @experimental
   * Audits domain allows investigation of page violations and possible improvements.
   */
  Audits = {
    /**
     * Returns the response body and size if it were re-encoded with the specified settings. Only
     * applies to images.
     */

    getEncodedResponse: async (opts: {
      /**
       * Identifier of the network request to get content for.
       */
      requestId: Network_RequestId;
      /**
       * The encoding to use.
       */
      encoding: "webp" | "jpeg" | "png";
      /**
       * The quality of the encoding (0-1). (defaults to 1)
       */
      quality?: number;
      /**
       * Whether to only return the size information (defaults to false).
       */
      sizeOnly?: boolean;
    }): Promise<{
      /**
       * The encoded body as a base64 string. Omitted if sizeOnly is true.
       */
      body?: string;
      /**
       * Size before re-encoding.
       */
      originalSize: number;
      /**
       * Size after re-encoding.
       */
      encodedSize: number;
    }> => {
      return await this.#sendReq("Audits.getEncodedResponse", opts);
    },

    /**
     * Disables issues domain, prevents further issues from being reported to the client.
     */

    disable: async (): Promise<void> => {
      return await this.#sendReq("Audits.disable");
    },

    /**
     * Enables issues domain, sends the issues collected so far to the client by means of the
     * `issueAdded` event.
     */

    enable: async (): Promise<void> => {
      return await this.#sendReq("Audits.enable");
    },

    /**
     * Runs the contrast check for the target page. Found issues are reported
     * using Audits.issueAdded event.
     */

    checkContrast: async (opts: {
      /**
       * Whether to report WCAG AAA level issues. Default is false.
       */
      reportAAA?: boolean;
    }): Promise<void> => {
      return await this.#sendReq("Audits.checkContrast", opts);
    },

    /**
     * Runs the form issues check for the target page. Found issues are reported
     * using Audits.issueAdded event.
     */

    checkFormsIssues: async (): Promise<
      { formIssues: Audits_GenericIssueDetails[] }
    > => {
      return await this.#sendReq("Audits.checkFormsIssues");
    },
  };

  /**
   * @experimental
   * Defines commands and events for Autofill.
   */
  Autofill = {
    /**
     * Trigger autofill on a form identified by the fieldId.
     * If the field and related form cannot be autofilled, returns an error.
     */

    trigger: async (opts: {
      /**
       * Identifies a field that serves as an anchor for autofill.
       */
      fieldId: DOM_BackendNodeId;
      /**
       * Identifies the frame that field belongs to.
       */
      frameId?: Page_FrameId;
      /**
       * Credit card information to fill out the form. Credit card data is not saved.
       */
      card: Autofill_CreditCard;
    }): Promise<void> => {
      return await this.#sendReq("Autofill.trigger", opts);
    },

    /**
     * Set addresses so that developers can verify their forms implementation.
     */

    setAddresses: async (
      opts: { addresses: Autofill_Address[] },
    ): Promise<void> => {
      return await this.#sendReq("Autofill.setAddresses", opts);
    },

    /**
     * Disables autofill domain notifications.
     */

    disable: async (): Promise<void> => {
      return await this.#sendReq("Autofill.disable");
    },

    /**
     * Enables autofill domain notifications.
     */

    enable: async (): Promise<void> => {
      return await this.#sendReq("Autofill.enable");
    },
  };

  /**
   * @experimental
   * Defines events for background web platform features.
   */
  BackgroundService = {
    /**
     * Enables event updates for the service.
     */

    startObserving: async (
      opts: { service: BackgroundService_ServiceName },
    ): Promise<void> => {
      return await this.#sendReq("BackgroundService.startObserving", opts);
    },

    /**
     * Disables event updates for the service.
     */

    stopObserving: async (
      opts: { service: BackgroundService_ServiceName },
    ): Promise<void> => {
      return await this.#sendReq("BackgroundService.stopObserving", opts);
    },

    /**
     * Set the recording state for the service.
     */

    setRecording: async (
      opts: { shouldRecord: boolean; service: BackgroundService_ServiceName },
    ): Promise<void> => {
      return await this.#sendReq("BackgroundService.setRecording", opts);
    },

    /**
     * Clears all stored data for the service.
     */

    clearEvents: async (
      opts: { service: BackgroundService_ServiceName },
    ): Promise<void> => {
      return await this.#sendReq("BackgroundService.clearEvents", opts);
    },
  };

  /**
   * The Browser domain defines methods and events for browser managing.
   */
  Browser = {
    /**
     * @experimental
     * Set permission settings for given origin.
     */

    setPermission: async (opts: {
      /**
       * Descriptor of permission to override.
       */
      permission: Browser_PermissionDescriptor;
      /**
       * Setting of the permission.
       */
      setting: Browser_PermissionSetting;
      /**
       * Origin the permission applies to, all origins if not specified.
       */
      origin?: string;
      /**
       * Context to override. When omitted, default browser context is used.
       */
      browserContextId?: Browser_BrowserContextID;
    }): Promise<void> => {
      return await this.#sendReq("Browser.setPermission", opts);
    },

    /**
     * @experimental
     * Grant specific permissions to the given origin and reject all others.
     */

    grantPermissions: async (opts: {
      permissions: Browser_PermissionType[];
      /**
       * Origin the permission applies to, all origins if not specified.
       */
      origin?: string;
      /**
       * BrowserContext to override permissions. When omitted, default browser context is used.
       */
      browserContextId?: Browser_BrowserContextID;
    }): Promise<void> => {
      return await this.#sendReq("Browser.grantPermissions", opts);
    },

    /**
     * Reset all permission management for all origins.
     */

    resetPermissions: async (opts: {
      /**
       * BrowserContext to reset permissions. When omitted, default browser context is used.
       */
      browserContextId?: Browser_BrowserContextID;
    }): Promise<void> => {
      return await this.#sendReq("Browser.resetPermissions", opts);
    },

    /**
     * @experimental
     * Set the behavior when downloading a file.
     */

    setDownloadBehavior: async (opts: {
      /**
       * Whether to allow all or deny all download requests, or use default Chrome behavior if
       * available (otherwise deny). |allowAndName| allows download and names files according to
       * their download guids.
       */
      behavior: "deny" | "allow" | "allowAndName" | "default";
      /**
       * BrowserContext to set download behavior. When omitted, default browser context is used.
       */
      browserContextId?: Browser_BrowserContextID;
      /**
       * The default path to save downloaded files to. This is required if behavior is set to 'allow'
       * or 'allowAndName'.
       */
      downloadPath?: string;
      /**
       * Whether to emit download events (defaults to false).
       */
      eventsEnabled?: boolean;
    }): Promise<void> => {
      return await this.#sendReq("Browser.setDownloadBehavior", opts);
    },

    /**
     * @experimental
     * Cancel a download if in progress
     */

    cancelDownload: async (opts: {
      /**
       * Global unique identifier of the download.
       */
      guid: string;
      /**
       * BrowserContext to perform the action in. When omitted, default browser context is used.
       */
      browserContextId?: Browser_BrowserContextID;
    }): Promise<void> => {
      return await this.#sendReq("Browser.cancelDownload", opts);
    },

    /**
     * Close browser gracefully.
     */

    close: async (): Promise<void> => {
      return await this.#sendReq("Browser.close");
    },

    /**
     * @experimental
     * Crashes browser on the main thread.
     */

    crash: async (): Promise<void> => {
      return await this.#sendReq("Browser.crash");
    },

    /**
     * @experimental
     * Crashes GPU process.
     */

    crashGpuProcess: async (): Promise<void> => {
      return await this.#sendReq("Browser.crashGpuProcess");
    },

    /**
     * Returns version information.
     */

    getVersion: async (): Promise<{
      /**
       * Protocol version.
       */
      protocolVersion: string;
      /**
       * Product name.
       */
      product: string;
      /**
       * Product revision.
       */
      revision: string;
      /**
       * User-Agent.
       */
      userAgent: string;
      /**
       * V8 version.
       */
      jsVersion: string;
    }> => {
      return await this.#sendReq("Browser.getVersion");
    },

    /**
     * @experimental
     * Returns the command line switches for the browser process if, and only if
     * --enable-automation is on the commandline.
     */

    getBrowserCommandLine: async (): Promise<{
      /**
       * Commandline parameters
       */
      arguments: string[];
    }> => {
      return await this.#sendReq("Browser.getBrowserCommandLine");
    },

    /**
     * @experimental
     * Get Chrome histograms.
     */

    getHistograms: async (opts: {
      /**
       * Requested substring in name. Only histograms which have query as a
       * substring in their name are extracted. An empty or absent query returns
       * all histograms.
       */
      query?: string;
      /**
       * If true, retrieve delta since last delta call.
       */
      delta?: boolean;
    }): Promise<{
      /**
       * Histograms.
       */
      histograms: Browser_Histogram[];
    }> => {
      return await this.#sendReq("Browser.getHistograms", opts);
    },

    /**
     * @experimental
     * Get a Chrome histogram by name.
     */

    getHistogram: async (opts: {
      /**
       * Requested histogram name.
       */
      name: string;
      /**
       * If true, retrieve delta since last delta call.
       */
      delta?: boolean;
    }): Promise<{
      /**
       * Histogram.
       */
      histogram: Browser_Histogram;
    }> => {
      return await this.#sendReq("Browser.getHistogram", opts);
    },

    /**
     * @experimental
     * Get position and size of the browser window.
     */

    getWindowBounds: async (opts: {
      /**
       * Browser window id.
       */
      windowId: Browser_WindowID;
    }): Promise<{
      /**
       * Bounds information of the window. When window state is 'minimized', the restored window
       * position and size are returned.
       */
      bounds: Browser_Bounds;
    }> => {
      return await this.#sendReq("Browser.getWindowBounds", opts);
    },

    /**
     * @experimental
     * Get the browser window that contains the devtools target.
     */

    getWindowForTarget: async (opts: {
      /**
       * Devtools agent host id. If called as a part of the session, associated targetId is used.
       */
      targetId?: Target_TargetID;
    }): Promise<{
      /**
       * Browser window id.
       */
      windowId: Browser_WindowID;
      /**
       * Bounds information of the window. When window state is 'minimized', the restored window
       * position and size are returned.
       */
      bounds: Browser_Bounds;
    }> => {
      return await this.#sendReq("Browser.getWindowForTarget", opts);
    },

    /**
     * @experimental
     * Set position and/or size of the browser window.
     */

    setWindowBounds: async (opts: {
      /**
       * Browser window id.
       */
      windowId: Browser_WindowID;
      /**
       * New window bounds. The 'minimized', 'maximized' and 'fullscreen' states cannot be combined
       * with 'left', 'top', 'width' or 'height'. Leaves unspecified fields unchanged.
       */
      bounds: Browser_Bounds;
    }): Promise<void> => {
      return await this.#sendReq("Browser.setWindowBounds", opts);
    },

    /**
     * @experimental
     * Set dock tile details, platform-specific.
     */

    setDockTile: async (opts: {
      badgeLabel?: string;
      /**
       * Png encoded image.
       */
      image?: string;
    }): Promise<void> => {
      return await this.#sendReq("Browser.setDockTile", opts);
    },

    /**
     * @experimental
     * Invoke custom browser commands used by telemetry.
     */

    executeBrowserCommand: async (
      opts: { commandId: Browser_BrowserCommandId },
    ): Promise<void> => {
      return await this.#sendReq("Browser.executeBrowserCommand", opts);
    },

    /**
     * Allows a site to use privacy sandbox features that require enrollment
     * without the site actually being enrolled. Only supported on page targets.
     */

    addPrivacySandboxEnrollmentOverride: async (
      opts: { url: string },
    ): Promise<void> => {
      return await this.#sendReq(
        "Browser.addPrivacySandboxEnrollmentOverride",
        opts,
      );
    },
  };

  /**
   * @experimental
   * This domain exposes CSS read/write operations. All CSS objects (stylesheets, rules, and styles)
   * have an associated `id` used in subsequent operations on the related object. Each object type has
   * a specific `id` structure, and those are not interchangeable between objects of different kinds.
   * CSS objects can be loaded using the `get*ForNode()` calls (which accept a DOM node id). A client
   * can also keep track of stylesheets via the `styleSheetAdded`/`styleSheetRemoved` events and
   * subsequently load the required stylesheet contents using the `getStyleSheet[Text]()` methods.
   */
  CSS = {
    /**
     * Inserts a new rule with the given `ruleText` in a stylesheet with given `styleSheetId`, at the
     * position specified by `location`.
     */

    addRule: async (opts: {
      /**
       * The css style sheet identifier where a new rule should be inserted.
       */
      styleSheetId: CSS_StyleSheetId;
      /**
       * The text of a new rule.
       */
      ruleText: string;
      /**
       * Text position of a new rule in the target style sheet.
       */
      location: CSS_SourceRange;
      /**
       * @experimental
       * NodeId for the DOM node in whose context custom property declarations for registered properties should be
       * validated. If omitted, declarations in the new rule text can only be validated statically, which may produce
       * incorrect results if the declaration contains a var() for example.
       */
      nodeForPropertySyntaxValidation?: DOM_NodeId;
    }): Promise<{
      /**
       * The newly created rule.
       */
      rule: CSS_CSSRule;
    }> => {
      return await this.#sendReq("CSS.addRule", opts);
    },

    /**
     * Returns all class names from specified stylesheet.
     */

    collectClassNames: async (
      opts: { styleSheetId: CSS_StyleSheetId },
    ): Promise<{
      /**
       * Class name list.
       */
      classNames: string[];
    }> => {
      return await this.#sendReq("CSS.collectClassNames", opts);
    },

    /**
     * Creates a new special "via-inspector" stylesheet in the frame with given `frameId`.
     */

    createStyleSheet: async (opts: {
      /**
       * Identifier of the frame where "via-inspector" stylesheet should be created.
       */
      frameId: Page_FrameId;
    }): Promise<{
      /**
       * Identifier of the created "via-inspector" stylesheet.
       */
      styleSheetId: CSS_StyleSheetId;
    }> => {
      return await this.#sendReq("CSS.createStyleSheet", opts);
    },

    /**
     * Disables the CSS agent for the given page.
     */

    disable: async (): Promise<void> => {
      return await this.#sendReq("CSS.disable");
    },

    /**
     * Enables the CSS agent for the given page. Clients should not assume that the CSS agent has been
     * enabled until the result of this command is received.
     */

    enable: async (): Promise<void> => {
      return await this.#sendReq("CSS.enable");
    },

    /**
     * Ensures that the given node will have specified pseudo-classes whenever its style is computed by
     * the browser.
     */

    forcePseudoState: async (opts: {
      /**
       * The element id for which to force the pseudo state.
       */
      nodeId: DOM_NodeId;
      /**
       * Element pseudo classes to force when computing the element's style.
       */
      forcedPseudoClasses: string[];
    }): Promise<void> => {
      return await this.#sendReq("CSS.forcePseudoState", opts);
    },

    getBackgroundColors: async (opts: {
      /**
       * Id of the node to get background colors for.
       */
      nodeId: DOM_NodeId;
    }): Promise<{
      /**
       * The range of background colors behind this element, if it contains any visible text. If no
       * visible text is present, this will be undefined. In the case of a flat background color,
       * this will consist of simply that color. In the case of a gradient, this will consist of each
       * of the color stops. For anything more complicated, this will be an empty array. Images will
       * be ignored (as if the image had failed to load).
       */
      backgroundColors?: string[];
      /**
       * The computed font size for this node, as a CSS computed value string (e.g. '12px').
       */
      computedFontSize?: string;
      /**
       * The computed font weight for this node, as a CSS computed value string (e.g. 'normal' or
       * '100').
       */
      computedFontWeight?: string;
    }> => {
      return await this.#sendReq("CSS.getBackgroundColors", opts);
    },

    /**
     * Returns the computed style for a DOM node identified by `nodeId`.
     */

    getComputedStyleForNode: async (opts: { nodeId: DOM_NodeId }): Promise<{
      /**
       * Computed style for the specified DOM node.
       */
      computedStyle: CSS_CSSComputedStyleProperty[];
    }> => {
      return await this.#sendReq("CSS.getComputedStyleForNode", opts);
    },

    /**
     * Returns the styles defined inline (explicitly in the "style" attribute and implicitly, using DOM
     * attributes) for a DOM node identified by `nodeId`.
     */

    getInlineStylesForNode: async (opts: { nodeId: DOM_NodeId }): Promise<{
      /**
       * Inline style for the specified DOM node.
       */
      inlineStyle?: CSS_CSSStyle;
      /**
       * Attribute-defined element style (e.g. resulting from "width=20 height=100%").
       */
      attributesStyle?: CSS_CSSStyle;
    }> => {
      return await this.#sendReq("CSS.getInlineStylesForNode", opts);
    },

    /**
     * Returns requested styles for a DOM node identified by `nodeId`.
     */

    getMatchedStylesForNode: async (opts: { nodeId: DOM_NodeId }): Promise<{
      /**
       * Inline style for the specified DOM node.
       */
      inlineStyle?: CSS_CSSStyle;
      /**
       * Attribute-defined element style (e.g. resulting from "width=20 height=100%").
       */
      attributesStyle?: CSS_CSSStyle;
      /**
       * CSS rules matching this node, from all applicable stylesheets.
       */
      matchedCSSRules?: CSS_RuleMatch[];
      /**
       * Pseudo style matches for this node.
       */
      pseudoElements?: CSS_PseudoElementMatches[];
      /**
       * A chain of inherited styles (from the immediate node parent up to the DOM tree root).
       */
      inherited?: CSS_InheritedStyleEntry[];
      /**
       * A chain of inherited pseudo element styles (from the immediate node parent up to the DOM tree root).
       */
      inheritedPseudoElements?: CSS_InheritedPseudoElementMatches[];
      /**
       * A list of CSS keyframed animations matching this node.
       */
      cssKeyframesRules?: CSS_CSSKeyframesRule[];
      /**
       * @deprecated
       * A list of CSS position fallbacks matching this node.
       */
      cssPositionFallbackRules?: CSS_CSSPositionFallbackRule[];
      /**
       * A list of CSS @position-try rules matching this node, based on the position-try-options property.
       */
      cssPositionTryRules?: CSS_CSSPositionTryRule[];
      /**
       * A list of CSS at-property rules matching this node.
       */
      cssPropertyRules?: CSS_CSSPropertyRule[];
      /**
       * A list of CSS property registrations matching this node.
       */
      cssPropertyRegistrations?: CSS_CSSPropertyRegistration[];
      /**
       * A font-palette-values rule matching this node.
       */
      cssFontPaletteValuesRule?: CSS_CSSFontPaletteValuesRule;
      /**
       * @experimental
       * Id of the first parent element that does not have display: contents.
       */
      parentLayoutNodeId?: DOM_NodeId;
    }> => {
      return await this.#sendReq("CSS.getMatchedStylesForNode", opts);
    },

    /**
     * Returns all media queries parsed by the rendering engine.
     */

    getMediaQueries: async (): Promise<{ medias: CSS_CSSMedia[] }> => {
      return await this.#sendReq("CSS.getMediaQueries");
    },

    /**
     * Requests information about platform fonts which we used to render child TextNodes in the given
     * node.
     */

    getPlatformFontsForNode: async (opts: { nodeId: DOM_NodeId }): Promise<{
      /**
       * Usage statistics for every employed platform font.
       */
      fonts: CSS_PlatformFontUsage[];
    }> => {
      return await this.#sendReq("CSS.getPlatformFontsForNode", opts);
    },

    /**
     * Returns the current textual content for a stylesheet.
     */

    getStyleSheetText: async (
      opts: { styleSheetId: CSS_StyleSheetId },
    ): Promise<{
      /**
       * The stylesheet text.
       */
      text: string;
    }> => {
      return await this.#sendReq("CSS.getStyleSheetText", opts);
    },

    /**
     * @experimental
     * Returns all layers parsed by the rendering engine for the tree scope of a node.
     * Given a DOM element identified by nodeId, getLayersForNode returns the root
     * layer for the nearest ancestor document or shadow root. The layer root contains
     * the full layer tree for the tree scope and their ordering.
     */

    getLayersForNode: async (
      opts: { nodeId: DOM_NodeId },
    ): Promise<{ rootLayer: CSS_CSSLayerData }> => {
      return await this.#sendReq("CSS.getLayersForNode", opts);
    },

    /**
     * @experimental
     * Given a CSS selector text and a style sheet ID, getLocationForSelector
     * returns an array of locations of the CSS selector in the style sheet.
     */

    getLocationForSelector: async (
      opts: { styleSheetId: CSS_StyleSheetId; selectorText: string },
    ): Promise<{ ranges: CSS_SourceRange[] }> => {
      return await this.#sendReq("CSS.getLocationForSelector", opts);
    },

    /**
     * @experimental
     * Starts tracking the given computed styles for updates. The specified array of properties
     * replaces the one previously specified. Pass empty array to disable tracking.
     * Use takeComputedStyleUpdates to retrieve the list of nodes that had properties modified.
     * The changes to computed style properties are only tracked for nodes pushed to the front-end
     * by the DOM agent. If no changes to the tracked properties occur after the node has been pushed
     * to the front-end, no updates will be issued for the node.
     */

    trackComputedStyleUpdates: async (
      opts: { propertiesToTrack: CSS_CSSComputedStyleProperty[] },
    ): Promise<void> => {
      return await this.#sendReq("CSS.trackComputedStyleUpdates", opts);
    },

    /**
     * @experimental
     * Polls the next batch of computed style updates.
     */

    takeComputedStyleUpdates: async (): Promise<{
      /**
       * The list of node Ids that have their tracked computed styles updated.
       */
      nodeIds: DOM_NodeId[];
    }> => {
      return await this.#sendReq("CSS.takeComputedStyleUpdates");
    },

    /**
     * Find a rule with the given active property for the given node and set the new value for this
     * property
     */

    setEffectivePropertyValueForNode: async (opts: {
      /**
       * The element id for which to set property.
       */
      nodeId: DOM_NodeId;
      propertyName: string;
      value: string;
    }): Promise<void> => {
      return await this.#sendReq("CSS.setEffectivePropertyValueForNode", opts);
    },

    /**
     * Modifies the property rule property name.
     */

    setPropertyRulePropertyName: async (
      opts: {
        styleSheetId: CSS_StyleSheetId;
        range: CSS_SourceRange;
        propertyName: string;
      },
    ): Promise<{
      /**
       * The resulting key text after modification.
       */
      propertyName: CSS_Value;
    }> => {
      return await this.#sendReq("CSS.setPropertyRulePropertyName", opts);
    },

    /**
     * Modifies the keyframe rule key text.
     */

    setKeyframeKey: async (
      opts: {
        styleSheetId: CSS_StyleSheetId;
        range: CSS_SourceRange;
        keyText: string;
      },
    ): Promise<{
      /**
       * The resulting key text after modification.
       */
      keyText: CSS_Value;
    }> => {
      return await this.#sendReq("CSS.setKeyframeKey", opts);
    },

    /**
     * Modifies the rule selector.
     */

    setMediaText: async (
      opts: {
        styleSheetId: CSS_StyleSheetId;
        range: CSS_SourceRange;
        text: string;
      },
    ): Promise<{
      /**
       * The resulting CSS media rule after modification.
       */
      media: CSS_CSSMedia;
    }> => {
      return await this.#sendReq("CSS.setMediaText", opts);
    },

    /**
     * @experimental
     * Modifies the expression of a container query.
     */

    setContainerQueryText: async (
      opts: {
        styleSheetId: CSS_StyleSheetId;
        range: CSS_SourceRange;
        text: string;
      },
    ): Promise<{
      /**
       * The resulting CSS container query rule after modification.
       */
      containerQuery: CSS_CSSContainerQuery;
    }> => {
      return await this.#sendReq("CSS.setContainerQueryText", opts);
    },

    /**
     * @experimental
     * Modifies the expression of a supports at-rule.
     */

    setSupportsText: async (
      opts: {
        styleSheetId: CSS_StyleSheetId;
        range: CSS_SourceRange;
        text: string;
      },
    ): Promise<{
      /**
       * The resulting CSS Supports rule after modification.
       */
      supports: CSS_CSSSupports;
    }> => {
      return await this.#sendReq("CSS.setSupportsText", opts);
    },

    /**
     * @experimental
     * Modifies the expression of a scope at-rule.
     */

    setScopeText: async (
      opts: {
        styleSheetId: CSS_StyleSheetId;
        range: CSS_SourceRange;
        text: string;
      },
    ): Promise<{
      /**
       * The resulting CSS Scope rule after modification.
       */
      scope: CSS_CSSScope;
    }> => {
      return await this.#sendReq("CSS.setScopeText", opts);
    },

    /**
     * Modifies the rule selector.
     */

    setRuleSelector: async (
      opts: {
        styleSheetId: CSS_StyleSheetId;
        range: CSS_SourceRange;
        selector: string;
      },
    ): Promise<{
      /**
       * The resulting selector list after modification.
       */
      selectorList: CSS_SelectorList;
    }> => {
      return await this.#sendReq("CSS.setRuleSelector", opts);
    },

    /**
     * Sets the new stylesheet text.
     */

    setStyleSheetText: async (
      opts: { styleSheetId: CSS_StyleSheetId; text: string },
    ): Promise<{
      /**
       * URL of source map associated with script (if any).
       */
      sourceMapURL?: string;
    }> => {
      return await this.#sendReq("CSS.setStyleSheetText", opts);
    },

    /**
     * Applies specified style edits one after another in the given order.
     */

    setStyleTexts: async (opts: {
      edits: CSS_StyleDeclarationEdit[];
      /**
       * @experimental
       * NodeId for the DOM node in whose context custom property declarations for registered properties should be
       * validated. If omitted, declarations in the new rule text can only be validated statically, which may produce
       * incorrect results if the declaration contains a var() for example.
       */
      nodeForPropertySyntaxValidation?: DOM_NodeId;
    }): Promise<{
      /**
       * The resulting styles after modification.
       */
      styles: CSS_CSSStyle[];
    }> => {
      return await this.#sendReq("CSS.setStyleTexts", opts);
    },

    /**
     * Enables the selector recording.
     */

    startRuleUsageTracking: async (): Promise<void> => {
      return await this.#sendReq("CSS.startRuleUsageTracking");
    },

    /**
     * Stop tracking rule usage and return the list of rules that were used since last call to
     * `takeCoverageDelta` (or since start of coverage instrumentation).
     */

    stopRuleUsageTracking: async (): Promise<
      { ruleUsage: CSS_RuleUsage[] }
    > => {
      return await this.#sendReq("CSS.stopRuleUsageTracking");
    },

    /**
     * Obtain list of rules that became used since last call to this method (or since start of coverage
     * instrumentation).
     */

    takeCoverageDelta: async (): Promise<{
      coverage: CSS_RuleUsage[];
      /**
       * Monotonically increasing time, in seconds.
       */
      timestamp: number;
    }> => {
      return await this.#sendReq("CSS.takeCoverageDelta");
    },

    /**
     * @experimental
     * Enables/disables rendering of local CSS fonts (enabled by default).
     */

    setLocalFontsEnabled: async (opts: {
      /**
       * Whether rendering of local fonts is enabled.
       */
      enabled: boolean;
    }): Promise<void> => {
      return await this.#sendReq("CSS.setLocalFontsEnabled", opts);
    },
  };

  /**
   * @experimental
   */
  CacheStorage = {
    /**
     * Deletes a cache.
     */

    deleteCache: async (opts: {
      /**
       * Id of cache for deletion.
       */
      cacheId: CacheStorage_CacheId;
    }): Promise<void> => {
      return await this.#sendReq("CacheStorage.deleteCache", opts);
    },

    /**
     * Deletes a cache entry.
     */

    deleteEntry: async (opts: {
      /**
       * Id of cache where the entry will be deleted.
       */
      cacheId: CacheStorage_CacheId;
      /**
       * URL spec of the request.
       */
      request: string;
    }): Promise<void> => {
      return await this.#sendReq("CacheStorage.deleteEntry", opts);
    },

    /**
     * Requests cache names.
     */

    requestCacheNames: async (opts: {
      /**
       * At least and at most one of securityOrigin, storageKey, storageBucket must be specified.
       * Security origin.
       */
      securityOrigin?: string;
      /**
       * Storage key.
       */
      storageKey?: string;
      /**
       * Storage bucket. If not specified, it uses the default bucket.
       */
      storageBucket?: Storage_StorageBucket;
    }): Promise<{
      /**
       * Caches for the security origin.
       */
      caches: CacheStorage_Cache[];
    }> => {
      return await this.#sendReq("CacheStorage.requestCacheNames", opts);
    },

    /**
     * Fetches cache entry.
     */

    requestCachedResponse: async (opts: {
      /**
       * Id of cache that contains the entry.
       */
      cacheId: CacheStorage_CacheId;
      /**
       * URL spec of the request.
       */
      requestURL: string;
      /**
       * headers of the request.
       */
      requestHeaders: CacheStorage_Header[];
    }): Promise<{
      /**
       * Response read from the cache.
       */
      response: CacheStorage_CachedResponse;
    }> => {
      return await this.#sendReq("CacheStorage.requestCachedResponse", opts);
    },

    /**
     * Requests data from cache.
     */

    requestEntries: async (opts: {
      /**
       * ID of cache to get entries from.
       */
      cacheId: CacheStorage_CacheId;
      /**
       * Number of records to skip.
       */
      skipCount?: number;
      /**
       * Number of records to fetch.
       */
      pageSize?: number;
      /**
       * If present, only return the entries containing this substring in the path
       */
      pathFilter?: string;
    }): Promise<{
      /**
       * Array of object store data entries.
       */
      cacheDataEntries: CacheStorage_DataEntry[];
      /**
       * Count of returned entries from this storage. If pathFilter is empty, it
       * is the count of all entries from this storage.
       */
      returnCount: number;
    }> => {
      return await this.#sendReq("CacheStorage.requestEntries", opts);
    },
  };

  /**
   * @experimental
   * A domain for interacting with Cast, Presentation API, and Remote Playback API
   * functionalities.
   */
  Cast = {
    /**
     * Starts observing for sinks that can be used for tab mirroring, and if set,
     * sinks compatible with |presentationUrl| as well. When sinks are found, a
     * |sinksUpdated| event is fired.
     * Also starts observing for issue messages. When an issue is added or removed,
     * an |issueUpdated| event is fired.
     */

    enable: async (opts: { presentationUrl?: string }): Promise<void> => {
      return await this.#sendReq("Cast.enable", opts);
    },

    /**
     * Stops observing for sinks and issues.
     */

    disable: async (): Promise<void> => {
      return await this.#sendReq("Cast.disable");
    },

    /**
     * Sets a sink to be used when the web page requests the browser to choose a
     * sink via Presentation API, Remote Playback API, or Cast SDK.
     */

    setSinkToUse: async (opts: { sinkName: string }): Promise<void> => {
      return await this.#sendReq("Cast.setSinkToUse", opts);
    },

    /**
     * Starts mirroring the desktop to the sink.
     */

    startDesktopMirroring: async (
      opts: { sinkName: string },
    ): Promise<void> => {
      return await this.#sendReq("Cast.startDesktopMirroring", opts);
    },

    /**
     * Starts mirroring the tab to the sink.
     */

    startTabMirroring: async (opts: { sinkName: string }): Promise<void> => {
      return await this.#sendReq("Cast.startTabMirroring", opts);
    },

    /**
     * Stops the active Cast session on the sink.
     */

    stopCasting: async (opts: { sinkName: string }): Promise<void> => {
      return await this.#sendReq("Cast.stopCasting", opts);
    },
  };

  /**
   * This domain exposes DOM read/write operations. Each DOM Node is represented with its mirror object
   * that has an `id`. This `id` can be used to get additional information on the Node, resolve it into
   * the JavaScript object wrapper, etc. It is important that client receives DOM events only for the
   * nodes that are known to the client. Backend keeps track of the nodes that were sent to the client
   * and never sends the same node twice. It is client's responsibility to collect information about
   * the nodes that were sent to the client. Note that `iframe` owner elements will return
   * corresponding document elements as their child nodes.
   */
  DOM = {
    /**
     * @experimental
     * Collects class names for the node with given id and all of it's child nodes.
     */

    collectClassNamesFromSubtree: async (opts: {
      /**
       * Id of the node to collect class names.
       */
      nodeId: DOM_NodeId;
    }): Promise<{
      /**
       * Class name list.
       */
      classNames: string[];
    }> => {
      return await this.#sendReq("DOM.collectClassNamesFromSubtree", opts);
    },

    /**
     * @experimental
     * Creates a deep copy of the specified node and places it into the target container before the
     * given anchor.
     */

    copyTo: async (opts: {
      /**
       * Id of the node to copy.
       */
      nodeId: DOM_NodeId;
      /**
       * Id of the element to drop the copy into.
       */
      targetNodeId: DOM_NodeId;
      /**
       * Drop the copy before this node (if absent, the copy becomes the last child of
       * `targetNodeId`).
       */
      insertBeforeNodeId?: DOM_NodeId;
    }): Promise<{
      /**
       * Id of the node clone.
       */
      nodeId: DOM_NodeId;
    }> => {
      return await this.#sendReq("DOM.copyTo", opts);
    },

    /**
     * Describes node given its id, does not require domain to be enabled. Does not start tracking any
     * objects, can be used for automation.
     */

    describeNode: async (opts: {
      /**
       * Identifier of the node.
       */
      nodeId?: DOM_NodeId;
      /**
       * Identifier of the backend node.
       */
      backendNodeId?: DOM_BackendNodeId;
      /**
       * JavaScript object id of the node wrapper.
       */
      objectId?: Runtime_RemoteObjectId;
      /**
       * The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
       * entire subtree or provide an integer larger than 0.
       */
      depth?: number;
      /**
       * Whether or not iframes and shadow roots should be traversed when returning the subtree
       * (default is false).
       */
      pierce?: boolean;
    }): Promise<{
      /**
       * Node description.
       */
      node: DOM_Node;
    }> => {
      return await this.#sendReq("DOM.describeNode", opts);
    },

    /**
     * Scrolls the specified rect of the given node into view if not already visible.
     * Note: exactly one between nodeId, backendNodeId and objectId should be passed
     * to identify the node.
     */

    scrollIntoViewIfNeeded: async (opts: {
      /**
       * Identifier of the node.
       */
      nodeId?: DOM_NodeId;
      /**
       * Identifier of the backend node.
       */
      backendNodeId?: DOM_BackendNodeId;
      /**
       * JavaScript object id of the node wrapper.
       */
      objectId?: Runtime_RemoteObjectId;
      /**
       * The rect to be scrolled into view, relative to the node's border box, in CSS pixels.
       * When omitted, center of the node will be used, similar to Element.scrollIntoView.
       */
      rect?: DOM_Rect;
    }): Promise<void> => {
      return await this.#sendReq("DOM.scrollIntoViewIfNeeded", opts);
    },

    /**
     * Disables DOM agent for the given page.
     */

    disable: async (): Promise<void> => {
      return await this.#sendReq("DOM.disable");
    },

    /**
     * @experimental
     * Discards search results from the session with the given id. `getSearchResults` should no longer
     * be called for that search.
     */

    discardSearchResults: async (opts: {
      /**
       * Unique search session identifier.
       */
      searchId: string;
    }): Promise<void> => {
      return await this.#sendReq("DOM.discardSearchResults", opts);
    },

    /**
     * Enables DOM agent for the given page.
     */

    enable: async (opts: {
      /**
       * @experimental
       * Whether to include whitespaces in the children array of returned Nodes.
       */
      includeWhitespace?: "none" | "all";
    }): Promise<void> => {
      return await this.#sendReq("DOM.enable", opts);
    },

    /**
     * Focuses the given element.
     */

    focus: async (opts: {
      /**
       * Identifier of the node.
       */
      nodeId?: DOM_NodeId;
      /**
       * Identifier of the backend node.
       */
      backendNodeId?: DOM_BackendNodeId;
      /**
       * JavaScript object id of the node wrapper.
       */
      objectId?: Runtime_RemoteObjectId;
    }): Promise<void> => {
      return await this.#sendReq("DOM.focus", opts);
    },

    /**
     * Returns attributes for the specified node.
     */

    getAttributes: async (opts: {
      /**
       * Id of the node to retrieve attributes for.
       */
      nodeId: DOM_NodeId;
    }): Promise<{
      /**
       * An interleaved array of node attribute names and values.
       */
      attributes: string[];
    }> => {
      return await this.#sendReq("DOM.getAttributes", opts);
    },

    /**
     * Returns boxes for the given node.
     */

    getBoxModel: async (opts: {
      /**
       * Identifier of the node.
       */
      nodeId?: DOM_NodeId;
      /**
       * Identifier of the backend node.
       */
      backendNodeId?: DOM_BackendNodeId;
      /**
       * JavaScript object id of the node wrapper.
       */
      objectId?: Runtime_RemoteObjectId;
    }): Promise<{
      /**
       * Box model for the node.
       */
      model: DOM_BoxModel;
    }> => {
      return await this.#sendReq("DOM.getBoxModel", opts);
    },

    /**
     * @experimental
     * Returns quads that describe node position on the page. This method
     * might return multiple quads for inline nodes.
     */

    getContentQuads: async (opts: {
      /**
       * Identifier of the node.
       */
      nodeId?: DOM_NodeId;
      /**
       * Identifier of the backend node.
       */
      backendNodeId?: DOM_BackendNodeId;
      /**
       * JavaScript object id of the node wrapper.
       */
      objectId?: Runtime_RemoteObjectId;
    }): Promise<{
      /**
       * Quads that describe node layout relative to viewport.
       */
      quads: DOM_Quad[];
    }> => {
      return await this.#sendReq("DOM.getContentQuads", opts);
    },

    /**
     * Returns the root DOM node (and optionally the subtree) to the caller.
     * Implicitly enables the DOM domain events for the current target.
     */

    getDocument: async (opts: {
      /**
       * The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
       * entire subtree or provide an integer larger than 0.
       */
      depth?: number;
      /**
       * Whether or not iframes and shadow roots should be traversed when returning the subtree
       * (default is false).
       */
      pierce?: boolean;
    }): Promise<{
      /**
       * Resulting node.
       */
      root: DOM_Node;
    }> => {
      return await this.#sendReq("DOM.getDocument", opts);
    },

    /**
     * @deprecated
     * Returns the root DOM node (and optionally the subtree) to the caller.
     * Deprecated, as it is not designed to work well with the rest of the DOM agent.
     * Use DOMSnapshot.captureSnapshot instead.
     */

    getFlattenedDocument: async (opts: {
      /**
       * The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
       * entire subtree or provide an integer larger than 0.
       */
      depth?: number;
      /**
       * Whether or not iframes and shadow roots should be traversed when returning the subtree
       * (default is false).
       */
      pierce?: boolean;
    }): Promise<{
      /**
       * Resulting node.
       */
      nodes: DOM_Node[];
    }> => {
      return await this.#sendReq("DOM.getFlattenedDocument", opts);
    },

    /**
     * @experimental
     * Finds nodes with a given computed style in a subtree.
     */

    getNodesForSubtreeByStyle: async (opts: {
      /**
       * Node ID pointing to the root of a subtree.
       */
      nodeId: DOM_NodeId;
      /**
       * The style to filter nodes by (includes nodes if any of properties matches).
       */
      computedStyles: DOM_CSSComputedStyleProperty[];
      /**
       * Whether or not iframes and shadow roots in the same target should be traversed when returning the
       * results (default is false).
       */
      pierce?: boolean;
    }): Promise<{
      /**
       * Resulting nodes.
       */
      nodeIds: DOM_NodeId[];
    }> => {
      return await this.#sendReq("DOM.getNodesForSubtreeByStyle", opts);
    },

    /**
     * Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
     * either returned or not.
     */

    getNodeForLocation: async (opts: {
      /**
       * X coordinate.
       */
      x: number;
      /**
       * Y coordinate.
       */
      y: number;
      /**
       * False to skip to the nearest non-UA shadow root ancestor (default: false).
       */
      includeUserAgentShadowDOM?: boolean;
      /**
       * Whether to ignore pointer-events: none on elements and hit test them.
       */
      ignorePointerEventsNone?: boolean;
    }): Promise<{
      /**
       * Resulting node.
       */
      backendNodeId: DOM_BackendNodeId;
      /**
       * Frame this node belongs to.
       */
      frameId: Page_FrameId;
      /**
       * Id of the node at given coordinates, only when enabled and requested document.
       */
      nodeId?: DOM_NodeId;
    }> => {
      return await this.#sendReq("DOM.getNodeForLocation", opts);
    },

    /**
     * Returns node's HTML markup.
     */

    getOuterHTML: async (opts: {
      /**
       * Identifier of the node.
       */
      nodeId?: DOM_NodeId;
      /**
       * Identifier of the backend node.
       */
      backendNodeId?: DOM_BackendNodeId;
      /**
       * JavaScript object id of the node wrapper.
       */
      objectId?: Runtime_RemoteObjectId;
    }): Promise<{
      /**
       * Outer HTML markup.
       */
      outerHTML: string;
    }> => {
      return await this.#sendReq("DOM.getOuterHTML", opts);
    },

    /**
     * @experimental
     * Returns the id of the nearest ancestor that is a relayout boundary.
     */

    getRelayoutBoundary: async (opts: {
      /**
       * Id of the node.
       */
      nodeId: DOM_NodeId;
    }): Promise<{
      /**
       * Relayout boundary node id for the given node.
       */
      nodeId: DOM_NodeId;
    }> => {
      return await this.#sendReq("DOM.getRelayoutBoundary", opts);
    },

    /**
     * @experimental
     * Returns search results from given `fromIndex` to given `toIndex` from the search with the given
     * identifier.
     */

    getSearchResults: async (opts: {
      /**
       * Unique search session identifier.
       */
      searchId: string;
      /**
       * Start index of the search result to be returned.
       */
      fromIndex: number;
      /**
       * End index of the search result to be returned.
       */
      toIndex: number;
    }): Promise<{
      /**
       * Ids of the search result nodes.
       */
      nodeIds: DOM_NodeId[];
    }> => {
      return await this.#sendReq("DOM.getSearchResults", opts);
    },

    /**
     * Hides any highlight.
     */

    hideHighlight: async (): Promise<void> => {
      return await this.#sendReq("DOM.hideHighlight");
    },

    /**
     * Highlights DOM node.
     */

    highlightNode: async (): Promise<void> => {
      return await this.#sendReq("DOM.highlightNode");
    },

    /**
     * Highlights given rectangle.
     */

    highlightRect: async (): Promise<void> => {
      return await this.#sendReq("DOM.highlightRect");
    },

    /**
     * @experimental
     * Marks last undoable state.
     */

    markUndoableState: async (): Promise<void> => {
      return await this.#sendReq("DOM.markUndoableState");
    },

    /**
     * Moves node into the new container, places it before the given anchor.
     */

    moveTo: async (opts: {
      /**
       * Id of the node to move.
       */
      nodeId: DOM_NodeId;
      /**
       * Id of the element to drop the moved node into.
       */
      targetNodeId: DOM_NodeId;
      /**
       * Drop node before this one (if absent, the moved node becomes the last child of
       * `targetNodeId`).
       */
      insertBeforeNodeId?: DOM_NodeId;
    }): Promise<{
      /**
       * New id of the moved node.
       */
      nodeId: DOM_NodeId;
    }> => {
      return await this.#sendReq("DOM.moveTo", opts);
    },

    /**
     * @experimental
     * Searches for a given string in the DOM tree. Use `getSearchResults` to access search results or
     * `cancelSearch` to end this search session.
     */

    performSearch: async (opts: {
      /**
       * Plain text or query selector or XPath search query.
       */
      query: string;
      /**
       * True to search in user agent shadow DOM.
       */
      includeUserAgentShadowDOM?: boolean;
    }): Promise<{
      /**
       * Unique search session identifier.
       */
      searchId: string;
      /**
       * Number of search results.
       */
      resultCount: number;
    }> => {
      return await this.#sendReq("DOM.performSearch", opts);
    },

    /**
     * @experimental
     * Requests that the node is sent to the caller given its path. // FIXME, use XPath
     */

    pushNodeByPathToFrontend: async (opts: {
      /**
       * Path to node in the proprietary format.
       */
      path: string;
    }): Promise<{
      /**
       * Id of the node for given path.
       */
      nodeId: DOM_NodeId;
    }> => {
      return await this.#sendReq("DOM.pushNodeByPathToFrontend", opts);
    },

    /**
     * @experimental
     * Requests that a batch of nodes is sent to the caller given their backend node ids.
     */

    pushNodesByBackendIdsToFrontend: async (opts: {
      /**
       * The array of backend node ids.
       */
      backendNodeIds: DOM_BackendNodeId[];
    }): Promise<{
      /**
       * The array of ids of pushed nodes that correspond to the backend ids specified in
       * backendNodeIds.
       */
      nodeIds: DOM_NodeId[];
    }> => {
      return await this.#sendReq("DOM.pushNodesByBackendIdsToFrontend", opts);
    },

    /**
     * Executes `querySelector` on a given node.
     */

    querySelector: async (opts: {
      /**
       * Id of the node to query upon.
       */
      nodeId: DOM_NodeId;
      /**
       * Selector string.
       */
      selector: string;
    }): Promise<{
      /**
       * Query selector result.
       */
      nodeId: DOM_NodeId;
    }> => {
      return await this.#sendReq("DOM.querySelector", opts);
    },

    /**
     * Executes `querySelectorAll` on a given node.
     */

    querySelectorAll: async (opts: {
      /**
       * Id of the node to query upon.
       */
      nodeId: DOM_NodeId;
      /**
       * Selector string.
       */
      selector: string;
    }): Promise<{
      /**
       * Query selector result.
       */
      nodeIds: DOM_NodeId[];
    }> => {
      return await this.#sendReq("DOM.querySelectorAll", opts);
    },

    /**
     * @experimental
     * Returns NodeIds of current top layer elements.
     * Top layer is rendered closest to the user within a viewport, therefore its elements always
     * appear on top of all other content.
     */

    getTopLayerElements: async (): Promise<{
      /**
       * NodeIds of top layer elements
       */
      nodeIds: DOM_NodeId[];
    }> => {
      return await this.#sendReq("DOM.getTopLayerElements");
    },

    /**
     * @experimental
     * Re-does the last undone action.
     */

    redo: async (): Promise<void> => {
      return await this.#sendReq("DOM.redo");
    },

    /**
     * Removes attribute with given name from an element with given id.
     */

    removeAttribute: async (opts: {
      /**
       * Id of the element to remove attribute from.
       */
      nodeId: DOM_NodeId;
      /**
       * Name of the attribute to remove.
       */
      name: string;
    }): Promise<void> => {
      return await this.#sendReq("DOM.removeAttribute", opts);
    },

    /**
     * Removes node with given id.
     */

    removeNode: async (opts: {
      /**
       * Id of the node to remove.
       */
      nodeId: DOM_NodeId;
    }): Promise<void> => {
      return await this.#sendReq("DOM.removeNode", opts);
    },

    /**
     * Requests that children of the node with given id are returned to the caller in form of
     * `setChildNodes` events where not only immediate children are retrieved, but all children down to
     * the specified depth.
     */

    requestChildNodes: async (opts: {
      /**
       * Id of the node to get children for.
       */
      nodeId: DOM_NodeId;
      /**
       * The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
       * entire subtree or provide an integer larger than 0.
       */
      depth?: number;
      /**
       * Whether or not iframes and shadow roots should be traversed when returning the sub-tree
       * (default is false).
       */
      pierce?: boolean;
    }): Promise<void> => {
      return await this.#sendReq("DOM.requestChildNodes", opts);
    },

    /**
     * Requests that the node is sent to the caller given the JavaScript node object reference. All
     * nodes that form the path from the node to the root are also sent to the client as a series of
     * `setChildNodes` notifications.
     */

    requestNode: async (opts: {
      /**
       * JavaScript object id to convert into node.
       */
      objectId: Runtime_RemoteObjectId;
    }): Promise<{
      /**
       * Node id for given object.
       */
      nodeId: DOM_NodeId;
    }> => {
      return await this.#sendReq("DOM.requestNode", opts);
    },

    /**
     * Resolves the JavaScript node object for a given NodeId or BackendNodeId.
     */

    resolveNode: async (opts: {
      /**
       * Id of the node to resolve.
       */
      nodeId?: DOM_NodeId;
      /**
       * Backend identifier of the node to resolve.
       */
      backendNodeId?: DOM_BackendNodeId;
      /**
       * Symbolic group name that can be used to release multiple objects.
       */
      objectGroup?: string;
      /**
       * Execution context in which to resolve the node.
       */
      executionContextId?: Runtime_ExecutionContextId;
    }): Promise<{
      /**
       * JavaScript object wrapper for given node.
       */
      object: Runtime_RemoteObject;
    }> => {
      return await this.#sendReq("DOM.resolveNode", opts);
    },

    /**
     * Sets attribute for an element with given id.
     */

    setAttributeValue: async (opts: {
      /**
       * Id of the element to set attribute for.
       */
      nodeId: DOM_NodeId;
      /**
       * Attribute name.
       */
      name: string;
      /**
       * Attribute value.
       */
      value: string;
    }): Promise<void> => {
      return await this.#sendReq("DOM.setAttributeValue", opts);
    },

    /**
     * Sets attributes on element with given id. This method is useful when user edits some existing
     * attribute value and types in several attribute name/value pairs.
     */

    setAttributesAsText: async (opts: {
      /**
       * Id of the element to set attributes for.
       */
      nodeId: DOM_NodeId;
      /**
       * Text with a number of attributes. Will parse this text using HTML parser.
       */
      text: string;
      /**
       * Attribute name to replace with new attributes derived from text in case text parsed
       * successfully.
       */
      name?: string;
    }): Promise<void> => {
      return await this.#sendReq("DOM.setAttributesAsText", opts);
    },

    /**
     * Sets files for the given file input element.
     */

    setFileInputFiles: async (opts: {
      /**
       * Array of file paths to set.
       */
      files: string[];
      /**
       * Identifier of the node.
       */
      nodeId?: DOM_NodeId;
      /**
       * Identifier of the backend node.
       */
      backendNodeId?: DOM_BackendNodeId;
      /**
       * JavaScript object id of the node wrapper.
       */
      objectId?: Runtime_RemoteObjectId;
    }): Promise<void> => {
      return await this.#sendReq("DOM.setFileInputFiles", opts);
    },

    /**
     * @experimental
     * Sets if stack traces should be captured for Nodes. See `Node.getNodeStackTraces`. Default is disabled.
     */

    setNodeStackTracesEnabled: async (opts: {
      /**
       * Enable or disable.
       */
      enable: boolean;
    }): Promise<void> => {
      return await this.#sendReq("DOM.setNodeStackTracesEnabled", opts);
    },

    /**
     * @experimental
     * Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.
     */

    getNodeStackTraces: async (opts: {
      /**
       * Id of the node to get stack traces for.
       */
      nodeId: DOM_NodeId;
    }): Promise<{
      /**
       * Creation stack trace, if available.
       */
      creation?: Runtime_StackTrace;
    }> => {
      return await this.#sendReq("DOM.getNodeStackTraces", opts);
    },

    /**
     * @experimental
     * Returns file information for the given
     * File wrapper.
     */

    getFileInfo: async (opts: {
      /**
       * JavaScript object id of the node wrapper.
       */
      objectId: Runtime_RemoteObjectId;
    }): Promise<{ path: string }> => {
      return await this.#sendReq("DOM.getFileInfo", opts);
    },

    /**
     * @experimental
     * Enables console to refer to the node with given id via $x (see Command Line API for more details
     * $x functions).
     */

    setInspectedNode: async (opts: {
      /**
       * DOM node id to be accessible by means of $x command line API.
       */
      nodeId: DOM_NodeId;
    }): Promise<void> => {
      return await this.#sendReq("DOM.setInspectedNode", opts);
    },

    /**
     * Sets node name for a node with given id.
     */

    setNodeName: async (opts: {
      /**
       * Id of the node to set name for.
       */
      nodeId: DOM_NodeId;
      /**
       * New node's name.
       */
      name: string;
    }): Promise<{
      /**
       * New node's id.
       */
      nodeId: DOM_NodeId;
    }> => {
      return await this.#sendReq("DOM.setNodeName", opts);
    },

    /**
     * Sets node value for a node with given id.
     */

    setNodeValue: async (opts: {
      /**
       * Id of the node to set value for.
       */
      nodeId: DOM_NodeId;
      /**
       * New node's value.
       */
      value: string;
    }): Promise<void> => {
      return await this.#sendReq("DOM.setNodeValue", opts);
    },

    /**
     * Sets node HTML markup, returns new node id.
     */

    setOuterHTML: async (opts: {
      /**
       * Id of the node to set markup for.
       */
      nodeId: DOM_NodeId;
      /**
       * Outer HTML markup to set.
       */
      outerHTML: string;
    }): Promise<void> => {
      return await this.#sendReq("DOM.setOuterHTML", opts);
    },

    /**
     * @experimental
     * Undoes the last performed action.
     */

    undo: async (): Promise<void> => {
      return await this.#sendReq("DOM.undo");
    },

    /**
     * @experimental
     * Returns iframe node that owns iframe with the given domain.
     */

    getFrameOwner: async (opts: { frameId: Page_FrameId }): Promise<{
      /**
       * Resulting node.
       */
      backendNodeId: DOM_BackendNodeId;
      /**
       * Id of the node at given coordinates, only when enabled and requested document.
       */
      nodeId?: DOM_NodeId;
    }> => {
      return await this.#sendReq("DOM.getFrameOwner", opts);
    },

    /**
     * @experimental
     * Returns the query container of the given node based on container query
     * conditions: containerName, physical, and logical axes. If no axes are
     * provided, the style container is returned, which is the direct parent or the
     * closest element with a matching container-name.
     */

    getContainerForNode: async (
      opts: {
        nodeId: DOM_NodeId;
        containerName?: string;
        physicalAxes?: DOM_PhysicalAxes;
        logicalAxes?: DOM_LogicalAxes;
      },
    ): Promise<{
      /**
       * The container node for the given node, or null if not found.
       */
      nodeId?: DOM_NodeId;
    }> => {
      return await this.#sendReq("DOM.getContainerForNode", opts);
    },

    /**
     * @experimental
     * Returns the descendants of a container query container that have
     * container queries against this container.
     */

    getQueryingDescendantsForContainer: async (opts: {
      /**
       * Id of the container node to find querying descendants from.
       */
      nodeId: DOM_NodeId;
    }): Promise<{
      /**
       * Descendant nodes with container queries against the given container.
       */
      nodeIds: DOM_NodeId[];
    }> => {
      return await this.#sendReq(
        "DOM.getQueryingDescendantsForContainer",
        opts,
      );
    },
  };

  /**
   * DOM debugging allows setting breakpoints on particular DOM operations and events. JavaScript
   * execution will stop on these operations as if there was a regular breakpoint set.
   */
  DOMDebugger = {
    /**
     * Returns event listeners of the given object.
     */

    getEventListeners: async (opts: {
      /**
       * Identifier of the object to return listeners for.
       */
      objectId: Runtime_RemoteObjectId;
      /**
       * The maximum depth at which Node children should be retrieved, defaults to 1. Use -1 for the
       * entire subtree or provide an integer larger than 0.
       */
      depth?: number;
      /**
       * Whether or not iframes and shadow roots should be traversed when returning the subtree
       * (default is false). Reports listeners for all contexts if pierce is enabled.
       */
      pierce?: boolean;
    }): Promise<{
      /**
       * Array of relevant listeners.
       */
      listeners: DOMDebugger_EventListener[];
    }> => {
      return await this.#sendReq("DOMDebugger.getEventListeners", opts);
    },

    /**
     * Removes DOM breakpoint that was set using `setDOMBreakpoint`.
     */

    removeDOMBreakpoint: async (opts: {
      /**
       * Identifier of the node to remove breakpoint from.
       */
      nodeId: DOM_NodeId;
      /**
       * Type of the breakpoint to remove.
       */
      type: DOMDebugger_DOMBreakpointType;
    }): Promise<void> => {
      return await this.#sendReq("DOMDebugger.removeDOMBreakpoint", opts);
    },

    /**
     * Removes breakpoint on particular DOM event.
     */

    removeEventListenerBreakpoint: async (opts: {
      /**
       * Event name.
       */
      eventName: string;
      /**
       * @experimental
       * EventTarget interface name.
       */
      targetName?: string;
    }): Promise<void> => {
      return await this.#sendReq(
        "DOMDebugger.removeEventListenerBreakpoint",
        opts,
      );
    },

    /**
     * @experimental
     * @deprecated
     * Removes breakpoint on particular native event.
     */

    removeInstrumentationBreakpoint: async (opts: {
      /**
       * Instrumentation name to stop on.
       */
      eventName: string;
    }): Promise<void> => {
      return await this.#sendReq(
        "DOMDebugger.removeInstrumentationBreakpoint",
        opts,
      );
    },

    /**
     * Removes breakpoint from XMLHttpRequest.
     */

    removeXHRBreakpoint: async (opts: {
      /**
       * Resource URL substring.
       */
      url: string;
    }): Promise<void> => {
      return await this.#sendReq("DOMDebugger.removeXHRBreakpoint", opts);
    },

    /**
     * @experimental
     * Sets breakpoint on particular CSP violations.
     */

    setBreakOnCSPViolation: async (opts: {
      /**
       * CSP Violations to stop upon.
       */
      violationTypes: DOMDebugger_CSPViolationType[];
    }): Promise<void> => {
      return await this.#sendReq("DOMDebugger.setBreakOnCSPViolation", opts);
    },

    /**
     * Sets breakpoint on particular operation with DOM.
     */

    setDOMBreakpoint: async (opts: {
      /**
       * Identifier of the node to set breakpoint on.
       */
      nodeId: DOM_NodeId;
      /**
       * Type of the operation to stop upon.
       */
      type: DOMDebugger_DOMBreakpointType;
    }): Promise<void> => {
      return await this.#sendReq("DOMDebugger.setDOMBreakpoint", opts);
    },

    /**
     * Sets breakpoint on particular DOM event.
     */

    setEventListenerBreakpoint: async (opts: {
      /**
       * DOM Event name to stop on (any DOM event will do).
       */
      eventName: string;
      /**
       * @experimental
       * EventTarget interface name to stop on. If equal to `"*"` or not provided, will stop on any
       * EventTarget.
       */
      targetName?: string;
    }): Promise<void> => {
      return await this.#sendReq(
        "DOMDebugger.setEventListenerBreakpoint",
        opts,
      );
    },

    /**
     * @experimental
     * @deprecated
     * Sets breakpoint on particular native event.
     */

    setInstrumentationBreakpoint: async (opts: {
      /**
       * Instrumentation name to stop on.
       */
      eventName: string;
    }): Promise<void> => {
      return await this.#sendReq(
        "DOMDebugger.setInstrumentationBreakpoint",
        opts,
      );
    },

    /**
     * Sets breakpoint on XMLHttpRequest.
     */

    setXHRBreakpoint: async (opts: {
      /**
       * Resource URL substring. All XHRs having this substring in the URL will get stopped upon.
       */
      url: string;
    }): Promise<void> => {
      return await this.#sendReq("DOMDebugger.setXHRBreakpoint", opts);
    },
  };

  /**
   * @experimental
   * EventBreakpoints permits setting JavaScript breakpoints on operations and events
   * occurring in native code invoked from JavaScript. Once breakpoint is hit, it is
   * reported through Debugger domain, similarly to regular breakpoints being hit.
   */
  EventBreakpoints = {
    /**
     * Sets breakpoint on particular native event.
     */

    setInstrumentationBreakpoint: async (opts: {
      /**
       * Instrumentation name to stop on.
       */
      eventName: string;
    }): Promise<void> => {
      return await this.#sendReq(
        "EventBreakpoints.setInstrumentationBreakpoint",
        opts,
      );
    },

    /**
     * Removes breakpoint on particular native event.
     */

    removeInstrumentationBreakpoint: async (opts: {
      /**
       * Instrumentation name to stop on.
       */
      eventName: string;
    }): Promise<void> => {
      return await this.#sendReq(
        "EventBreakpoints.removeInstrumentationBreakpoint",
        opts,
      );
    },

    /**
     * Removes all breakpoints
     */

    disable: async (): Promise<void> => {
      return await this.#sendReq("EventBreakpoints.disable");
    },
  };

  /**
   * @experimental
   * This domain facilitates obtaining document snapshots with DOM, layout, and style information.
   */
  DOMSnapshot = {
    /**
     * Disables DOM snapshot agent for the given page.
     */

    disable: async (): Promise<void> => {
      return await this.#sendReq("DOMSnapshot.disable");
    },

    /**
     * Enables DOM snapshot agent for the given page.
     */

    enable: async (): Promise<void> => {
      return await this.#sendReq("DOMSnapshot.enable");
    },

    /**
     * @deprecated
     * Returns a document snapshot, including the full DOM tree of the root node (including iframes,
     * template contents, and imported documents) in a flattened array, as well as layout and
     * white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is
     * flattened.
     */

    getSnapshot: async (opts: {
      /**
       * Whitelist of computed styles to return.
       */
      computedStyleWhitelist: string[];
      /**
       * Whether or not to retrieve details of DOM listeners (default false).
       */
      includeEventListeners?: boolean;
      /**
       * Whether to determine and include the paint order index of LayoutTreeNodes (default false).
       */
      includePaintOrder?: boolean;
      /**
       * Whether to include UA shadow tree in the snapshot (default false).
       */
      includeUserAgentShadowTree?: boolean;
    }): Promise<{
      /**
       * The nodes in the DOM tree. The DOMNode at index 0 corresponds to the root document.
       */
      domNodes: DOMSnapshot_DOMNode[];
      /**
       * The nodes in the layout tree.
       */
      layoutTreeNodes: DOMSnapshot_LayoutTreeNode[];
      /**
       * Whitelisted ComputedStyle properties for each node in the layout tree.
       */
      computedStyles: DOMSnapshot_ComputedStyle[];
    }> => {
      return await this.#sendReq("DOMSnapshot.getSnapshot", opts);
    },

    /**
     * Returns a document snapshot, including the full DOM tree of the root node (including iframes,
     * template contents, and imported documents) in a flattened array, as well as layout and
     * white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is
     * flattened.
     */

    captureSnapshot: async (opts: {
      /**
       * Whitelist of computed styles to return.
       */
      computedStyles: string[];
      /**
       * Whether to include layout object paint orders into the snapshot.
       */
      includePaintOrder?: boolean;
      /**
       * Whether to include DOM rectangles (offsetRects, clientRects, scrollRects) into the snapshot
       */
      includeDOMRects?: boolean;
      /**
       * @experimental
       * Whether to include blended background colors in the snapshot (default: false).
       * Blended background color is achieved by blending background colors of all elements
       * that overlap with the current element.
       */
      includeBlendedBackgroundColors?: boolean;
      /**
       * @experimental
       * Whether to include text color opacity in the snapshot (default: false).
       * An element might have the opacity property set that affects the text color of the element.
       * The final text color opacity is computed based on the opacity of all overlapping elements.
       */
      includeTextColorOpacities?: boolean;
    }): Promise<{
      /**
       * The nodes in the DOM tree. The DOMNode at index 0 corresponds to the root document.
       */
      documents: DOMSnapshot_DocumentSnapshot[];
      /**
       * Shared string table that all string properties refer to with indexes.
       */
      strings: string[];
    }> => {
      return await this.#sendReq("DOMSnapshot.captureSnapshot", opts);
    },
  };

  /**
   * @experimental
   * Query and modify DOM storage.
   */
  DOMStorage = {
    clear: async (opts: { storageId: DOMStorage_StorageId }): Promise<void> => {
      return await this.#sendReq("DOMStorage.clear", opts);
    },

    /**
     * Disables storage tracking, prevents storage events from being sent to the client.
     */

    disable: async (): Promise<void> => {
      return await this.#sendReq("DOMStorage.disable");
    },

    /**
     * Enables storage tracking, storage events will now be delivered to the client.
     */

    enable: async (): Promise<void> => {
      return await this.#sendReq("DOMStorage.enable");
    },

    getDOMStorageItems: async (
      opts: { storageId: DOMStorage_StorageId },
    ): Promise<{ entries: DOMStorage_Item[] }> => {
      return await this.#sendReq("DOMStorage.getDOMStorageItems", opts);
    },

    removeDOMStorageItem: async (
      opts: { storageId: DOMStorage_StorageId; key: string },
    ): Promise<void> => {
      return await this.#sendReq("DOMStorage.removeDOMStorageItem", opts);
    },

    setDOMStorageItem: async (
      opts: { storageId: DOMStorage_StorageId; key: string; value: string },
    ): Promise<void> => {
      return await this.#sendReq("DOMStorage.setDOMStorageItem", opts);
    },
  };

  /**
   * @experimental
   */
  Database = {
    /**
     * Disables database tracking, prevents database events from being sent to the client.
     */

    disable: async (): Promise<void> => {
      return await this.#sendReq("Database.disable");
    },

    /**
     * Enables database tracking, database events will now be delivered to the client.
     */

    enable: async (): Promise<void> => {
      return await this.#sendReq("Database.enable");
    },

    executeSQL: async (
      opts: { databaseId: Database_DatabaseId; query: string },
    ): Promise<
      { columnNames?: string[]; values?: any[]; sqlError?: Database_Error }
    > => {
      return await this.#sendReq("Database.executeSQL", opts);
    },

    getDatabaseTableNames: async (
      opts: { databaseId: Database_DatabaseId },
    ): Promise<{ tableNames: string[] }> => {
      return await this.#sendReq("Database.getDatabaseTableNames", opts);
    },
  };

  /**
   * @experimental
   */
  DeviceOrientation = {
    /**
     * Clears the overridden Device Orientation.
     */

    clearDeviceOrientationOverride: async (): Promise<void> => {
      return await this.#sendReq(
        "DeviceOrientation.clearDeviceOrientationOverride",
      );
    },

    /**
     * Overrides the Device Orientation.
     */

    setDeviceOrientationOverride: async (opts: {
      /**
       * Mock alpha
       */
      alpha: number;
      /**
       * Mock beta
       */
      beta: number;
      /**
       * Mock gamma
       */
      gamma: number;
    }): Promise<void> => {
      return await this.#sendReq(
        "DeviceOrientation.setDeviceOrientationOverride",
        opts,
      );
    },
  };

  /**
   * This domain emulates different environments for the page.
   */
  Emulation = {
    /**
     * @deprecated
     * Tells whether emulation is supported.
     */

    canEmulate: async (): Promise<{
      /**
       * True if emulation is supported.
       */
      result: boolean;
    }> => {
      return await this.#sendReq("Emulation.canEmulate");
    },

    /**
     * Clears the overridden device metrics.
     */

    clearDeviceMetricsOverride: async (): Promise<void> => {
      return await this.#sendReq("Emulation.clearDeviceMetricsOverride");
    },

    /**
     * Clears the overridden Geolocation Position and Error.
     */

    clearGeolocationOverride: async (): Promise<void> => {
      return await this.#sendReq("Emulation.clearGeolocationOverride");
    },

    /**
     * @experimental
     * Requests that page scale factor is reset to initial values.
     */

    resetPageScaleFactor: async (): Promise<void> => {
      return await this.#sendReq("Emulation.resetPageScaleFactor");
    },

    /**
     * @experimental
     * Enables or disables simulating a focused and active page.
     */

    setFocusEmulationEnabled: async (opts: {
      /**
       * Whether to enable to disable focus emulation.
       */
      enabled: boolean;
    }): Promise<void> => {
      return await this.#sendReq("Emulation.setFocusEmulationEnabled", opts);
    },

    /**
     * @experimental
     * Automatically render all web contents using a dark theme.
     */

    setAutoDarkModeOverride: async (opts: {
      /**
       * Whether to enable or disable automatic dark mode.
       * If not specified, any existing override will be cleared.
       */
      enabled?: boolean;
    }): Promise<void> => {
      return await this.#sendReq("Emulation.setAutoDarkModeOverride", opts);
    },

    /**
     * Enables CPU throttling to emulate slow CPUs.
     */

    setCPUThrottlingRate: async (opts: {
      /**
       * Throttling rate as a slowdown factor (1 is no throttle, 2 is 2x slowdown, etc).
       */
      rate: number;
    }): Promise<void> => {
      return await this.#sendReq("Emulation.setCPUThrottlingRate", opts);
    },

    /**
     * Sets or clears an override of the default background color of the frame. This override is used
     * if the content does not specify one.
     */

    setDefaultBackgroundColorOverride: async (opts: {
      /**
       * RGBA of the default background color. If not specified, any existing override will be
       * cleared.
       */
      color?: DOM_RGBA;
    }): Promise<void> => {
      return await this.#sendReq(
        "Emulation.setDefaultBackgroundColorOverride",
        opts,
      );
    },

    /**
     * Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
     * window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
     * query results).
     */

    setDeviceMetricsOverride: async (opts: {
      /**
       * Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
       */
      width: number;
      /**
       * Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
       */
      height: number;
      /**
       * Overriding device scale factor value. 0 disables the override.
       */
      deviceScaleFactor: number;
      /**
       * Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text
       * autosizing and more.
       */
      mobile: boolean;
      /**
       * @experimental
       * Scale to apply to resulting view image.
       */
      scale?: number;
      /**
       * @experimental
       * Overriding screen width value in pixels (minimum 0, maximum 10000000).
       */
      screenWidth?: number;
      /**
       * @experimental
       * Overriding screen height value in pixels (minimum 0, maximum 10000000).
       */
      screenHeight?: number;
      /**
       * @experimental
       * Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
       */
      positionX?: number;
      /**
       * @experimental
       * Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
       */
      positionY?: number;
      /**
       * @experimental
       * Do not set visible view size, rely upon explicit setVisibleSize call.
       */
      dontSetVisibleSize?: boolean;
      /**
       * Screen orientation override.
       */
      screenOrientation?: Emulation_ScreenOrientation;
      /**
       * @experimental
       * If set, the visible area of the page will be overridden to this viewport. This viewport
       * change is not observed by the page, e.g. viewport-relative elements do not change positions.
       */
      viewport?: Page_Viewport;
      /**
       * @experimental
       * If set, the display feature of a multi-segment screen. If not set, multi-segment support
       * is turned-off.
       */
      displayFeature?: Emulation_DisplayFeature;
      /**
       * @experimental
       * @deprecated
       * If set, the posture of a foldable device. If not set the posture is set
       * to continuous.
       * Deprecated, use Emulation.setDevicePostureOverride.
       */
      devicePosture?: Emulation_DevicePosture;
    }): Promise<void> => {
      return await this.#sendReq("Emulation.setDeviceMetricsOverride", opts);
    },

    /**
     * @experimental
     * Start reporting the given posture value to the Device Posture API.
     * This override can also be set in setDeviceMetricsOverride().
     */

    setDevicePostureOverride: async (
      opts: { posture: Emulation_DevicePosture },
    ): Promise<void> => {
      return await this.#sendReq("Emulation.setDevicePostureOverride", opts);
    },

    /**
     * @experimental
     * Clears a device posture override set with either setDeviceMetricsOverride()
     * or setDevicePostureOverride() and starts using posture information from the
     * platform again.
     * Does nothing if no override is set.
     */

    clearDevicePostureOverride: async (): Promise<void> => {
      return await this.#sendReq("Emulation.clearDevicePostureOverride");
    },

    /**
     * @experimental
     */

    setScrollbarsHidden: async (opts: {
      /**
       * Whether scrollbars should be always hidden.
       */
      hidden: boolean;
    }): Promise<void> => {
      return await this.#sendReq("Emulation.setScrollbarsHidden", opts);
    },

    /**
     * @experimental
     */

    setDocumentCookieDisabled: async (opts: {
      /**
       * Whether document.coookie API should be disabled.
       */
      disabled: boolean;
    }): Promise<void> => {
      return await this.#sendReq("Emulation.setDocumentCookieDisabled", opts);
    },

    /**
     * @experimental
     */

    setEmitTouchEventsForMouse: async (opts: {
      /**
       * Whether touch emulation based on mouse input should be enabled.
       */
      enabled: boolean;
      /**
       * Touch/gesture events configuration. Default: current platform.
       */
      configuration?: "mobile" | "desktop";
    }): Promise<void> => {
      return await this.#sendReq("Emulation.setEmitTouchEventsForMouse", opts);
    },

    /**
     * Emulates the given media type or media feature for CSS media queries.
     */

    setEmulatedMedia: async (opts: {
      /**
       * Media type to emulate. Empty string disables the override.
       */
      media?: string;
      /**
       * Media features to emulate.
       */
      features?: Emulation_MediaFeature[];
    }): Promise<void> => {
      return await this.#sendReq("Emulation.setEmulatedMedia", opts);
    },

    /**
     * Emulates the given vision deficiency.
     */

    setEmulatedVisionDeficiency: async (opts: {
      /**
       * Vision deficiency to emulate. Order: best-effort emulations come first, followed by any
       * physiologically accurate emulations for medically recognized color vision deficiencies.
       */
      type:
        | "none"
        | "blurredVision"
        | "reducedContrast"
        | "achromatopsia"
        | "deuteranopia"
        | "protanopia"
        | "tritanopia";
    }): Promise<void> => {
      return await this.#sendReq("Emulation.setEmulatedVisionDeficiency", opts);
    },

    /**
     * Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
     * unavailable.
     */

    setGeolocationOverride: async (opts: {
      /**
       * Mock latitude
       */
      latitude?: number;
      /**
       * Mock longitude
       */
      longitude?: number;
      /**
       * Mock accuracy
       */
      accuracy?: number;
    }): Promise<void> => {
      return await this.#sendReq("Emulation.setGeolocationOverride", opts);
    },

    /**
     * @experimental
     */

    getOverriddenSensorInformation: async (
      opts: { type: Emulation_SensorType },
    ): Promise<{ requestedSamplingFrequency: number }> => {
      return await this.#sendReq(
        "Emulation.getOverriddenSensorInformation",
        opts,
      );
    },

    /**
     * @experimental
     * Overrides a platform sensor of a given type. If |enabled| is true, calls to
     * Sensor.start() will use a virtual sensor as backend rather than fetching
     * data from a real hardware sensor. Otherwise, existing virtual
     * sensor-backend Sensor objects will fire an error event and new calls to
     * Sensor.start() will attempt to use a real sensor instead.
     */

    setSensorOverrideEnabled: async (
      opts: {
        enabled: boolean;
        type: Emulation_SensorType;
        metadata?: Emulation_SensorMetadata;
      },
    ): Promise<void> => {
      return await this.#sendReq("Emulation.setSensorOverrideEnabled", opts);
    },

    /**
     * @experimental
     * Updates the sensor readings reported by a sensor type previously overridden
     * by setSensorOverrideEnabled.
     */

    setSensorOverrideReadings: async (
      opts: { type: Emulation_SensorType; reading: Emulation_SensorReading },
    ): Promise<void> => {
      return await this.#sendReq("Emulation.setSensorOverrideReadings", opts);
    },

    /**
     * Overrides the Idle state.
     */

    setIdleOverride: async (opts: {
      /**
       * Mock isUserActive
       */
      isUserActive: boolean;
      /**
       * Mock isScreenUnlocked
       */
      isScreenUnlocked: boolean;
    }): Promise<void> => {
      return await this.#sendReq("Emulation.setIdleOverride", opts);
    },

    /**
     * Clears Idle state overrides.
     */

    clearIdleOverride: async (): Promise<void> => {
      return await this.#sendReq("Emulation.clearIdleOverride");
    },

    /**
     * @experimental
     * @deprecated
     * Overrides value returned by the javascript navigator object.
     */

    setNavigatorOverrides: async (opts: {
      /**
       * The platform navigator.platform should return.
       */
      platform: string;
    }): Promise<void> => {
      return await this.#sendReq("Emulation.setNavigatorOverrides", opts);
    },

    /**
     * @experimental
     * Sets a specified page scale factor.
     */

    setPageScaleFactor: async (opts: {
      /**
       * Page scale factor.
       */
      pageScaleFactor: number;
    }): Promise<void> => {
      return await this.#sendReq("Emulation.setPageScaleFactor", opts);
    },

    /**
     * Switches script execution in the page.
     */

    setScriptExecutionDisabled: async (opts: {
      /**
       * Whether script execution should be disabled in the page.
       */
      value: boolean;
    }): Promise<void> => {
      return await this.#sendReq("Emulation.setScriptExecutionDisabled", opts);
    },

    /**
     * Enables touch on platforms which do not support them.
     */

    setTouchEmulationEnabled: async (opts: {
      /**
       * Whether the touch event emulation should be enabled.
       */
      enabled: boolean;
      /**
       * Maximum touch points supported. Defaults to one.
       */
      maxTouchPoints?: number;
    }): Promise<void> => {
      return await this.#sendReq("Emulation.setTouchEmulationEnabled", opts);
    },

    /**
     * @experimental
     * Turns on virtual time for all frames (replacing real-time with a synthetic time source) and sets
     * the current virtual time policy.  Note this supersedes any previous time budget.
     */

    setVirtualTimePolicy: async (
      opts: {
        policy: Emulation_VirtualTimePolicy;
        /**
         * If set, after this many virtual milliseconds have elapsed virtual time will be paused and a
         * virtualTimeBudgetExpired event is sent.
         */
        budget?: number;
        /**
         * If set this specifies the maximum number of tasks that can be run before virtual is forced
         * forwards to prevent deadlock.
         */
        maxVirtualTimeTaskStarvationCount?: number;
        /**
         * If set, base::Time::Now will be overridden to initially return this value.
         */
        initialVirtualTime?: Network_TimeSinceEpoch;
      },
    ): Promise<{
      /**
       * Absolute timestamp at which virtual time was first enabled (up time in milliseconds).
       */
      virtualTimeTicksBase: number;
    }> => {
      return await this.#sendReq("Emulation.setVirtualTimePolicy", opts);
    },

    /**
     * @experimental
     * Overrides default host system locale with the specified one.
     */

    setLocaleOverride: async (opts: {
      /**
       * ICU style C locale (e.g. "en_US"). If not specified or empty, disables the override and
       * restores default host system locale.
       */
      locale?: string;
    }): Promise<void> => {
      return await this.#sendReq("Emulation.setLocaleOverride", opts);
    },

    /**
     * Overrides default host system timezone with the specified one.
     */

    setTimezoneOverride: async (opts: {
      /**
       * The timezone identifier. List of supported timezones:
       * https://source.chromium.org/chromium/chromium/deps/icu.git/+/faee8bc70570192d82d2978a71e2a615788597d1:source/data/misc/metaZones.txt
       * If empty, disables the override and restores default host system timezone.
       */
      timezoneId: string;
    }): Promise<void> => {
      return await this.#sendReq("Emulation.setTimezoneOverride", opts);
    },

    /**
     * @experimental
     * @deprecated
     * Resizes the frame/viewport of the page. Note that this does not affect the frame's container
     * (e.g. browser window). Can be used to produce screenshots of the specified size. Not supported
     * on Android.
     */

    setVisibleSize: async (opts: {
      /**
       * Frame width (DIP).
       */
      width: number;
      /**
       * Frame height (DIP).
       */
      height: number;
    }): Promise<void> => {
      return await this.#sendReq("Emulation.setVisibleSize", opts);
    },

    /**
     * @experimental
     */

    setDisabledImageTypes: async (opts: {
      /**
       * Image types to disable.
       */
      imageTypes: Emulation_DisabledImageType[];
    }): Promise<void> => {
      return await this.#sendReq("Emulation.setDisabledImageTypes", opts);
    },

    /**
     * @experimental
     */

    setHardwareConcurrencyOverride: async (opts: {
      /**
       * Hardware concurrency to report
       */
      hardwareConcurrency: number;
    }): Promise<void> => {
      return await this.#sendReq(
        "Emulation.setHardwareConcurrencyOverride",
        opts,
      );
    },

    /**
     * Allows overriding user agent with the given string.
     * `userAgentMetadata` must be set for Client Hint headers to be sent.
     */

    setUserAgentOverride: async (opts: {
      /**
       * User agent to use.
       */
      userAgent: string;
      /**
       * Browser language to emulate.
       */
      acceptLanguage?: string;
      /**
       * The platform navigator.platform should return.
       */
      platform?: string;
      /**
       * @experimental
       * To be sent in Sec-CH-UA-* headers and returned in navigator.userAgentData
       */
      userAgentMetadata?: Emulation_UserAgentMetadata;
    }): Promise<void> => {
      return await this.#sendReq("Emulation.setUserAgentOverride", opts);
    },

    /**
     * @experimental
     * Allows overriding the automation flag.
     */

    setAutomationOverride: async (opts: {
      /**
       * Whether the override should be enabled.
       */
      enabled: boolean;
    }): Promise<void> => {
      return await this.#sendReq("Emulation.setAutomationOverride", opts);
    },
  };

  /**
   * @experimental
   * This domain provides experimental commands only supported in headless mode.
   */
  HeadlessExperimental = {
    /**
     * Sends a BeginFrame to the target and returns when the frame was completed. Optionally captures a
     * screenshot from the resulting frame. Requires that the target was created with enabled
     * BeginFrameControl. Designed for use with --run-all-compositor-stages-before-draw, see also
     * https://goo.gle/chrome-headless-rendering for more background.
     */

    beginFrame: async (opts: {
      /**
       * Timestamp of this BeginFrame in Renderer TimeTicks (milliseconds of uptime). If not set,
       * the current time will be used.
       */
      frameTimeTicks?: number;
      /**
       * The interval between BeginFrames that is reported to the compositor, in milliseconds.
       * Defaults to a 60 frames/second interval, i.e. about 16.666 milliseconds.
       */
      interval?: number;
      /**
       * Whether updates should not be committed and drawn onto the display. False by default. If
       * true, only side effects of the BeginFrame will be run, such as layout and animations, but
       * any visual updates may not be visible on the display or in screenshots.
       */
      noDisplayUpdates?: boolean;
      /**
       * If set, a screenshot of the frame will be captured and returned in the response. Otherwise,
       * no screenshot will be captured. Note that capturing a screenshot can fail, for example,
       * during renderer initialization. In such a case, no screenshot data will be returned.
       */
      screenshot?: HeadlessExperimental_ScreenshotParams;
    }): Promise<{
      /**
       * Whether the BeginFrame resulted in damage and, thus, a new frame was committed to the
       * display. Reported for diagnostic uses, may be removed in the future.
       */
      hasDamage: boolean;
      /**
       * Base64-encoded image data of the screenshot, if one was requested and successfully taken.
       */
      screenshotData?: string;
    }> => {
      return await this.#sendReq("HeadlessExperimental.beginFrame", opts);
    },

    /**
     * @deprecated
     * Disables headless events for the target.
     */

    disable: async (): Promise<void> => {
      return await this.#sendReq("HeadlessExperimental.disable");
    },

    /**
     * @deprecated
     * Enables headless events for the target.
     */

    enable: async (): Promise<void> => {
      return await this.#sendReq("HeadlessExperimental.enable");
    },
  };

  /**
   * Input/Output operations for streams produced by DevTools.
   */
  IO = {
    /**
     * Close the stream, discard any temporary backing storage.
     */

    close: async (opts: {
      /**
       * Handle of the stream to close.
       */
      handle: IO_StreamHandle;
    }): Promise<void> => {
      return await this.#sendReq("IO.close", opts);
    },

    /**
     * Read a chunk of the stream
     */

    read: async (opts: {
      /**
       * Handle of the stream to read.
       */
      handle: IO_StreamHandle;
      /**
       * Seek to the specified offset before reading (if not specified, proceed with offset
       * following the last read). Some types of streams may only support sequential reads.
       */
      offset?: number;
      /**
       * Maximum number of bytes to read (left upon the agent discretion if not specified).
       */
      size?: number;
    }): Promise<{
      /**
       * Set if the data is base64-encoded
       */
      base64Encoded?: boolean;
      /**
       * Data that were read.
       */
      data: string;
      /**
       * Set if the end-of-file condition occurred while reading.
       */
      eof: boolean;
    }> => {
      return await this.#sendReq("IO.read", opts);
    },

    /**
     * Return UUID of Blob object specified by a remote object id.
     */

    resolveBlob: async (opts: {
      /**
       * Object id of a Blob object wrapper.
       */
      objectId: Runtime_RemoteObjectId;
    }): Promise<{
      /**
       * UUID of the specified Blob.
       */
      uuid: string;
    }> => {
      return await this.#sendReq("IO.resolveBlob", opts);
    },
  };

  /**
   * @experimental
   */
  IndexedDB = {
    /**
     * Clears all entries from an object store.
     */

    clearObjectStore: async (opts: {
      /**
       * At least and at most one of securityOrigin, storageKey, or storageBucket must be specified.
       * Security origin.
       */
      securityOrigin?: string;
      /**
       * Storage key.
       */
      storageKey?: string;
      /**
       * Storage bucket. If not specified, it uses the default bucket.
       */
      storageBucket?: Storage_StorageBucket;
      /**
       * Database name.
       */
      databaseName: string;
      /**
       * Object store name.
       */
      objectStoreName: string;
    }): Promise<void> => {
      return await this.#sendReq("IndexedDB.clearObjectStore", opts);
    },

    /**
     * Deletes a database.
     */

    deleteDatabase: async (opts: {
      /**
       * At least and at most one of securityOrigin, storageKey, or storageBucket must be specified.
       * Security origin.
       */
      securityOrigin?: string;
      /**
       * Storage key.
       */
      storageKey?: string;
      /**
       * Storage bucket. If not specified, it uses the default bucket.
       */
      storageBucket?: Storage_StorageBucket;
      /**
       * Database name.
       */
      databaseName: string;
    }): Promise<void> => {
      return await this.#sendReq("IndexedDB.deleteDatabase", opts);
    },

    /**
     * Delete a range of entries from an object store
     */

    deleteObjectStoreEntries: async (opts: {
      /**
       * At least and at most one of securityOrigin, storageKey, or storageBucket must be specified.
       * Security origin.
       */
      securityOrigin?: string;
      /**
       * Storage key.
       */
      storageKey?: string;
      /**
       * Storage bucket. If not specified, it uses the default bucket.
       */
      storageBucket?: Storage_StorageBucket;
      databaseName: string;
      objectStoreName: string;
      /**
       * Range of entry keys to delete
       */
      keyRange: IndexedDB_KeyRange;
    }): Promise<void> => {
      return await this.#sendReq("IndexedDB.deleteObjectStoreEntries", opts);
    },

    /**
     * Disables events from backend.
     */

    disable: async (): Promise<void> => {
      return await this.#sendReq("IndexedDB.disable");
    },

    /**
     * Enables events from backend.
     */

    enable: async (): Promise<void> => {
      return await this.#sendReq("IndexedDB.enable");
    },

    /**
     * Requests data from object store or index.
     */

    requestData: async (opts: {
      /**
       * At least and at most one of securityOrigin, storageKey, or storageBucket must be specified.
       * Security origin.
       */
      securityOrigin?: string;
      /**
       * Storage key.
       */
      storageKey?: string;
      /**
       * Storage bucket. If not specified, it uses the default bucket.
       */
      storageBucket?: Storage_StorageBucket;
      /**
       * Database name.
       */
      databaseName: string;
      /**
       * Object store name.
       */
      objectStoreName: string;
      /**
       * Index name, empty string for object store data requests.
       */
      indexName: string;
      /**
       * Number of records to skip.
       */
      skipCount: number;
      /**
       * Number of records to fetch.
       */
      pageSize: number;
      /**
       * Key range.
       */
      keyRange?: IndexedDB_KeyRange;
    }): Promise<{
      /**
       * Array of object store data entries.
       */
      objectStoreDataEntries: IndexedDB_DataEntry[];
      /**
       * If true, there are more entries to fetch in the given range.
       */
      hasMore: boolean;
    }> => {
      return await this.#sendReq("IndexedDB.requestData", opts);
    },

    /**
     * Gets metadata of an object store.
     */

    getMetadata: async (opts: {
      /**
       * At least and at most one of securityOrigin, storageKey, or storageBucket must be specified.
       * Security origin.
       */
      securityOrigin?: string;
      /**
       * Storage key.
       */
      storageKey?: string;
      /**
       * Storage bucket. If not specified, it uses the default bucket.
       */
      storageBucket?: Storage_StorageBucket;
      /**
       * Database name.
       */
      databaseName: string;
      /**
       * Object store name.
       */
      objectStoreName: string;
    }): Promise<{
      /**
       * the entries count
       */
      entriesCount: number;
      /**
       * the current value of key generator, to become the next inserted
       * key into the object store. Valid if objectStore.autoIncrement
       * is true.
       */
      keyGeneratorValue: number;
    }> => {
      return await this.#sendReq("IndexedDB.getMetadata", opts);
    },

    /**
     * Requests database with given name in given frame.
     */

    requestDatabase: async (opts: {
      /**
       * At least and at most one of securityOrigin, storageKey, or storageBucket must be specified.
       * Security origin.
       */
      securityOrigin?: string;
      /**
       * Storage key.
       */
      storageKey?: string;
      /**
       * Storage bucket. If not specified, it uses the default bucket.
       */
      storageBucket?: Storage_StorageBucket;
      /**
       * Database name.
       */
      databaseName: string;
    }): Promise<{
      /**
       * Database with an array of object stores.
       */
      databaseWithObjectStores: IndexedDB_DatabaseWithObjectStores;
    }> => {
      return await this.#sendReq("IndexedDB.requestDatabase", opts);
    },

    /**
     * Requests database names for given security origin.
     */

    requestDatabaseNames: async (opts: {
      /**
       * At least and at most one of securityOrigin, storageKey, or storageBucket must be specified.
       * Security origin.
       */
      securityOrigin?: string;
      /**
       * Storage key.
       */
      storageKey?: string;
      /**
       * Storage bucket. If not specified, it uses the default bucket.
       */
      storageBucket?: Storage_StorageBucket;
    }): Promise<{
      /**
       * Database names for origin.
       */
      databaseNames: string[];
    }> => {
      return await this.#sendReq("IndexedDB.requestDatabaseNames", opts);
    },
  };

  Input = {
    /**
     * @experimental
     * Dispatches a drag event into the page.
     */

    dispatchDragEvent: async (opts: {
      /**
       * Type of the drag event.
       */
      type: "dragEnter" | "dragOver" | "drop" | "dragCancel";
      /**
       * X coordinate of the event relative to the main frame's viewport in CSS pixels.
       */
      x: number;
      /**
       * Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to
       * the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
       */
      y: number;
      data: Input_DragData;
      /**
       * Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
       * (default: 0).
       */
      modifiers?: number;
    }): Promise<void> => {
      return await this.#sendReq("Input.dispatchDragEvent", opts);
    },

    /**
     * Dispatches a key event to the page.
     */

    dispatchKeyEvent: async (opts: {
      /**
       * Type of the key event.
       */
      type: "keyDown" | "keyUp" | "rawKeyDown" | "char";
      /**
       * Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
       * (default: 0).
       */
      modifiers?: number;
      /**
       * Time at which the event occurred.
       */
      timestamp?: Input_TimeSinceEpoch;
      /**
       * Text as generated by processing a virtual key code with a keyboard layout. Not needed for
       * for `keyUp` and `rawKeyDown` events (default: "")
       */
      text?: string;
      /**
       * Text that would have been generated by the keyboard if no modifiers were pressed (except for
       * shift). Useful for shortcut (accelerator) key handling (default: "").
       */
      unmodifiedText?: string;
      /**
       * Unique key identifier (e.g., 'U+0041') (default: "").
       */
      keyIdentifier?: string;
      /**
       * Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
       */
      code?: string;
      /**
       * Unique DOM defined string value describing the meaning of the key in the context of active
       * modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
       */
      key?: string;
      /**
       * Windows virtual key code (default: 0).
       */
      windowsVirtualKeyCode?: number;
      /**
       * Native virtual key code (default: 0).
       */
      nativeVirtualKeyCode?: number;
      /**
       * Whether the event was generated from auto repeat (default: false).
       */
      autoRepeat?: boolean;
      /**
       * Whether the event was generated from the keypad (default: false).
       */
      isKeypad?: boolean;
      /**
       * Whether the event was a system key event (default: false).
       */
      isSystemKey?: boolean;
      /**
       * Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default:
       * 0).
       */
      location?: number;
      /**
       * @experimental
       * Editing commands to send with the key event (e.g., 'selectAll') (default: []).
       * These are related to but not equal the command names used in `document.execCommand` and NSStandardKeyBindingResponding.
       * See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
       */
      commands?: string[];
    }): Promise<void> => {
      return await this.#sendReq("Input.dispatchKeyEvent", opts);
    },

    /**
     * @experimental
     * This method emulates inserting text that doesn't come from a key press,
     * for example an emoji keyboard or an IME.
     */

    insertText: async (opts: {
      /**
       * The text to insert.
       */
      text: string;
    }): Promise<void> => {
      return await this.#sendReq("Input.insertText", opts);
    },

    /**
     * @experimental
     * This method sets the current candidate text for IME.
     * Use imeCommitComposition to commit the final text.
     * Use imeSetComposition with empty string as text to cancel composition.
     */

    imeSetComposition: async (opts: {
      /**
       * The text to insert
       */
      text: string;
      /**
       * selection start
       */
      selectionStart: number;
      /**
       * selection end
       */
      selectionEnd: number;
      /**
       * replacement start
       */
      replacementStart?: number;
      /**
       * replacement end
       */
      replacementEnd?: number;
    }): Promise<void> => {
      return await this.#sendReq("Input.imeSetComposition", opts);
    },

    /**
     * Dispatches a mouse event to the page.
     */

    dispatchMouseEvent: async (opts: {
      /**
       * Type of the mouse event.
       */
      type: "mousePressed" | "mouseReleased" | "mouseMoved" | "mouseWheel";
      /**
       * X coordinate of the event relative to the main frame's viewport in CSS pixels.
       */
      x: number;
      /**
       * Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to
       * the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
       */
      y: number;
      /**
       * Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
       * (default: 0).
       */
      modifiers?: number;
      /**
       * Time at which the event occurred.
       */
      timestamp?: Input_TimeSinceEpoch;
      /**
       * Mouse button (default: "none").
       */
      button?: Input_MouseButton;
      /**
       * A number indicating which buttons are pressed on the mouse when a mouse event is triggered.
       * Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
       */
      buttons?: number;
      /**
       * Number of times the mouse button was clicked (default: 0).
       */
      clickCount?: number;
      /**
       * @experimental
       * The normalized pressure, which has a range of [0,1] (default: 0).
       */
      force?: number;
      /**
       * @experimental
       * The normalized tangential pressure, which has a range of [-1,1] (default: 0).
       */
      tangentialPressure?: number;
      /**
       * The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
       */
      tiltX?: number;
      /**
       * The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
       */
      tiltY?: number;
      /**
       * @experimental
       * The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
       */
      twist?: number;
      /**
       * X delta in CSS pixels for mouse wheel event (default: 0).
       */
      deltaX?: number;
      /**
       * Y delta in CSS pixels for mouse wheel event (default: 0).
       */
      deltaY?: number;
      /**
       * Pointer type (default: "mouse").
       */
      pointerType?: "mouse" | "pen";
    }): Promise<void> => {
      return await this.#sendReq("Input.dispatchMouseEvent", opts);
    },

    /**
     * Dispatches a touch event to the page.
     */

    dispatchTouchEvent: async (opts: {
      /**
       * Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while
       * TouchStart and TouchMove must contains at least one.
       */
      type: "touchStart" | "touchEnd" | "touchMove" | "touchCancel";
      /**
       * Active touch points on the touch device. One event per any changed point (compared to
       * previous touch event in a sequence) is generated, emulating pressing/moving/releasing points
       * one by one.
       */
      touchPoints: Input_TouchPoint[];
      /**
       * Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
       * (default: 0).
       */
      modifiers?: number;
      /**
       * Time at which the event occurred.
       */
      timestamp?: Input_TimeSinceEpoch;
    }): Promise<void> => {
      return await this.#sendReq("Input.dispatchTouchEvent", opts);
    },

    /**
     * Cancels any active dragging in the page.
     */

    cancelDragging: async (): Promise<void> => {
      return await this.#sendReq("Input.cancelDragging");
    },

    /**
     * @experimental
     * Emulates touch event from the mouse event parameters.
     */

    emulateTouchFromMouseEvent: async (opts: {
      /**
       * Type of the mouse event.
       */
      type: "mousePressed" | "mouseReleased" | "mouseMoved" | "mouseWheel";
      /**
       * X coordinate of the mouse pointer in DIP.
       */
      x: number;
      /**
       * Y coordinate of the mouse pointer in DIP.
       */
      y: number;
      /**
       * Mouse button. Only "none", "left", "right" are supported.
       */
      button: Input_MouseButton;
      /**
       * Time at which the event occurred (default: current time).
       */
      timestamp?: Input_TimeSinceEpoch;
      /**
       * X delta in DIP for mouse wheel event (default: 0).
       */
      deltaX?: number;
      /**
       * Y delta in DIP for mouse wheel event (default: 0).
       */
      deltaY?: number;
      /**
       * Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
       * (default: 0).
       */
      modifiers?: number;
      /**
       * Number of times the mouse button was clicked (default: 0).
       */
      clickCount?: number;
    }): Promise<void> => {
      return await this.#sendReq("Input.emulateTouchFromMouseEvent", opts);
    },

    /**
     * Ignores input events (useful while auditing page).
     */

    setIgnoreInputEvents: async (opts: {
      /**
       * Ignores input events processing when set to true.
       */
      ignore: boolean;
    }): Promise<void> => {
      return await this.#sendReq("Input.setIgnoreInputEvents", opts);
    },

    /**
     * @experimental
     * Prevents default drag and drop behavior and instead emits `Input.dragIntercepted` events.
     * Drag and drop behavior can be directly controlled via `Input.dispatchDragEvent`.
     */

    setInterceptDrags: async (opts: { enabled: boolean }): Promise<void> => {
      return await this.#sendReq("Input.setInterceptDrags", opts);
    },

    /**
     * @experimental
     * Synthesizes a pinch gesture over a time period by issuing appropriate touch events.
     */

    synthesizePinchGesture: async (opts: {
      /**
       * X coordinate of the start of the gesture in CSS pixels.
       */
      x: number;
      /**
       * Y coordinate of the start of the gesture in CSS pixels.
       */
      y: number;
      /**
       * Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
       */
      scaleFactor: number;
      /**
       * Relative pointer speed in pixels per second (default: 800).
       */
      relativeSpeed?: number;
      /**
       * Which type of input events to be generated (default: 'default', which queries the platform
       * for the preferred input type).
       */
      gestureSourceType?: Input_GestureSourceType;
    }): Promise<void> => {
      return await this.#sendReq("Input.synthesizePinchGesture", opts);
    },

    /**
     * @experimental
     * Synthesizes a scroll gesture over a time period by issuing appropriate touch events.
     */

    synthesizeScrollGesture: async (opts: {
      /**
       * X coordinate of the start of the gesture in CSS pixels.
       */
      x: number;
      /**
       * Y coordinate of the start of the gesture in CSS pixels.
       */
      y: number;
      /**
       * The distance to scroll along the X axis (positive to scroll left).
       */
      xDistance?: number;
      /**
       * The distance to scroll along the Y axis (positive to scroll up).
       */
      yDistance?: number;
      /**
       * The number of additional pixels to scroll back along the X axis, in addition to the given
       * distance.
       */
      xOverscroll?: number;
      /**
       * The number of additional pixels to scroll back along the Y axis, in addition to the given
       * distance.
       */
      yOverscroll?: number;
      /**
       * Prevent fling (default: true).
       */
      preventFling?: boolean;
      /**
       * Swipe speed in pixels per second (default: 800).
       */
      speed?: number;
      /**
       * Which type of input events to be generated (default: 'default', which queries the platform
       * for the preferred input type).
       */
      gestureSourceType?: Input_GestureSourceType;
      /**
       * The number of times to repeat the gesture (default: 0).
       */
      repeatCount?: number;
      /**
       * The number of milliseconds delay between each repeat. (default: 250).
       */
      repeatDelayMs?: number;
      /**
       * The name of the interaction markers to generate, if not empty (default: "").
       */
      interactionMarkerName?: string;
    }): Promise<void> => {
      return await this.#sendReq("Input.synthesizeScrollGesture", opts);
    },

    /**
     * @experimental
     * Synthesizes a tap gesture over a time period by issuing appropriate touch events.
     */

    synthesizeTapGesture: async (opts: {
      /**
       * X coordinate of the start of the gesture in CSS pixels.
       */
      x: number;
      /**
       * Y coordinate of the start of the gesture in CSS pixels.
       */
      y: number;
      /**
       * Duration between touchdown and touchup events in ms (default: 50).
       */
      duration?: number;
      /**
       * Number of times to perform the tap (e.g. 2 for double tap, default: 1).
       */
      tapCount?: number;
      /**
       * Which type of input events to be generated (default: 'default', which queries the platform
       * for the preferred input type).
       */
      gestureSourceType?: Input_GestureSourceType;
    }): Promise<void> => {
      return await this.#sendReq("Input.synthesizeTapGesture", opts);
    },
  };

  /**
   * @experimental
   */
  Inspector = {
    /**
     * Disables inspector domain notifications.
     */

    disable: async (): Promise<void> => {
      return await this.#sendReq("Inspector.disable");
    },

    /**
     * Enables inspector domain notifications.
     */

    enable: async (): Promise<void> => {
      return await this.#sendReq("Inspector.enable");
    },
  };

  /**
   * @experimental
   */
  LayerTree = {
    /**
     * Provides the reasons why the given layer was composited.
     */

    compositingReasons: async (opts: {
      /**
       * The id of the layer for which we want to get the reasons it was composited.
       */
      layerId: LayerTree_LayerId;
    }): Promise<{
      /**
       * A list of strings specifying reasons for the given layer to become composited.
       */
      compositingReasons: string[];
      /**
       * A list of strings specifying reason IDs for the given layer to become composited.
       */
      compositingReasonIds: string[];
    }> => {
      return await this.#sendReq("LayerTree.compositingReasons", opts);
    },

    /**
     * Disables compositing tree inspection.
     */

    disable: async (): Promise<void> => {
      return await this.#sendReq("LayerTree.disable");
    },

    /**
     * Enables compositing tree inspection.
     */

    enable: async (): Promise<void> => {
      return await this.#sendReq("LayerTree.enable");
    },

    /**
     * Returns the snapshot identifier.
     */

    loadSnapshot: async (opts: {
      /**
       * An array of tiles composing the snapshot.
       */
      tiles: LayerTree_PictureTile[];
    }): Promise<{
      /**
       * The id of the snapshot.
       */
      snapshotId: LayerTree_SnapshotId;
    }> => {
      return await this.#sendReq("LayerTree.loadSnapshot", opts);
    },

    /**
     * Returns the layer snapshot identifier.
     */

    makeSnapshot: async (opts: {
      /**
       * The id of the layer.
       */
      layerId: LayerTree_LayerId;
    }): Promise<{
      /**
       * The id of the layer snapshot.
       */
      snapshotId: LayerTree_SnapshotId;
    }> => {
      return await this.#sendReq("LayerTree.makeSnapshot", opts);
    },

    profileSnapshot: async (opts: {
      /**
       * The id of the layer snapshot.
       */
      snapshotId: LayerTree_SnapshotId;
      /**
       * The maximum number of times to replay the snapshot (1, if not specified).
       */
      minRepeatCount?: number;
      /**
       * The minimum duration (in seconds) to replay the snapshot.
       */
      minDuration?: number;
      /**
       * The clip rectangle to apply when replaying the snapshot.
       */
      clipRect?: DOM_Rect;
    }): Promise<{
      /**
       * The array of paint profiles, one per run.
       */
      timings: LayerTree_PaintProfile[];
    }> => {
      return await this.#sendReq("LayerTree.profileSnapshot", opts);
    },

    /**
     * Releases layer snapshot captured by the back-end.
     */

    releaseSnapshot: async (opts: {
      /**
       * The id of the layer snapshot.
       */
      snapshotId: LayerTree_SnapshotId;
    }): Promise<void> => {
      return await this.#sendReq("LayerTree.releaseSnapshot", opts);
    },

    /**
     * Replays the layer snapshot and returns the resulting bitmap.
     */

    replaySnapshot: async (opts: {
      /**
       * The id of the layer snapshot.
       */
      snapshotId: LayerTree_SnapshotId;
      /**
       * The first step to replay from (replay from the very start if not specified).
       */
      fromStep?: number;
      /**
       * The last step to replay to (replay till the end if not specified).
       */
      toStep?: number;
      /**
       * The scale to apply while replaying (defaults to 1).
       */
      scale?: number;
    }): Promise<{
      /**
       * A data: URL for resulting image.
       */
      dataURL: string;
    }> => {
      return await this.#sendReq("LayerTree.replaySnapshot", opts);
    },

    /**
     * Replays the layer snapshot and returns canvas log.
     */

    snapshotCommandLog: async (opts: {
      /**
       * The id of the layer snapshot.
       */
      snapshotId: LayerTree_SnapshotId;
    }): Promise<{
      /**
       * The array of canvas function calls.
       */
      commandLog: object[];
    }> => {
      return await this.#sendReq("LayerTree.snapshotCommandLog", opts);
    },
  };

  /**
   * Provides access to log entries.
   */
  Log = {
    /**
     * Clears the log.
     */

    clear: async (): Promise<void> => {
      return await this.#sendReq("Log.clear");
    },

    /**
     * Disables log domain, prevents further log entries from being reported to the client.
     */

    disable: async (): Promise<void> => {
      return await this.#sendReq("Log.disable");
    },

    /**
     * Enables log domain, sends the entries collected so far to the client by means of the
     * `entryAdded` notification.
     */

    enable: async (): Promise<void> => {
      return await this.#sendReq("Log.enable");
    },

    /**
     * start violation reporting.
     */

    startViolationsReport: async (opts: {
      /**
       * Configuration for violations.
       */
      config: Log_ViolationSetting[];
    }): Promise<void> => {
      return await this.#sendReq("Log.startViolationsReport", opts);
    },

    /**
     * Stop violation reporting.
     */

    stopViolationsReport: async (): Promise<void> => {
      return await this.#sendReq("Log.stopViolationsReport");
    },
  };

  /**
   * @experimental
   */
  Memory = {
    getDOMCounters: async (): Promise<
      { documents: number; nodes: number; jsEventListeners: number }
    > => {
      return await this.#sendReq("Memory.getDOMCounters");
    },

    prepareForLeakDetection: async (): Promise<void> => {
      return await this.#sendReq("Memory.prepareForLeakDetection");
    },

    /**
     * Simulate OomIntervention by purging V8 memory.
     */

    forciblyPurgeJavaScriptMemory: async (): Promise<void> => {
      return await this.#sendReq("Memory.forciblyPurgeJavaScriptMemory");
    },

    /**
     * Enable/disable suppressing memory pressure notifications in all processes.
     */

    setPressureNotificationsSuppressed: async (opts: {
      /**
       * If true, memory pressure notifications will be suppressed.
       */
      suppressed: boolean;
    }): Promise<void> => {
      return await this.#sendReq(
        "Memory.setPressureNotificationsSuppressed",
        opts,
      );
    },

    /**
     * Simulate a memory pressure notification in all processes.
     */

    simulatePressureNotification: async (opts: {
      /**
       * Memory pressure level of the notification.
       */
      level: Memory_PressureLevel;
    }): Promise<void> => {
      return await this.#sendReq("Memory.simulatePressureNotification", opts);
    },

    /**
     * Start collecting native memory profile.
     */

    startSampling: async (opts: {
      /**
       * Average number of bytes between samples.
       */
      samplingInterval?: number;
      /**
       * Do not randomize intervals between samples.
       */
      suppressRandomness?: boolean;
    }): Promise<void> => {
      return await this.#sendReq("Memory.startSampling", opts);
    },

    /**
     * Stop collecting native memory profile.
     */

    stopSampling: async (): Promise<void> => {
      return await this.#sendReq("Memory.stopSampling");
    },

    /**
     * Retrieve native memory allocations profile
     * collected since renderer process startup.
     */

    getAllTimeSamplingProfile: async (): Promise<
      { profile: Memory_SamplingProfile }
    > => {
      return await this.#sendReq("Memory.getAllTimeSamplingProfile");
    },

    /**
     * Retrieve native memory allocations profile
     * collected since browser process startup.
     */

    getBrowserSamplingProfile: async (): Promise<
      { profile: Memory_SamplingProfile }
    > => {
      return await this.#sendReq("Memory.getBrowserSamplingProfile");
    },

    /**
     * Retrieve native memory allocations profile collected since last
     * `startSampling` call.
     */

    getSamplingProfile: async (): Promise<
      { profile: Memory_SamplingProfile }
    > => {
      return await this.#sendReq("Memory.getSamplingProfile");
    },
  };

  /**
   * Network domain allows tracking network activities of the page. It exposes information about http,
   * file, data and other requests and responses, their headers, bodies, timing, etc.
   */
  Network = {
    /**
     * @experimental
     * Sets a list of content encodings that will be accepted. Empty list means no encoding is accepted.
     */

    setAcceptedEncodings: async (opts: {
      /**
       * List of accepted content encodings.
       */
      encodings: Network_ContentEncoding[];
    }): Promise<void> => {
      return await this.#sendReq("Network.setAcceptedEncodings", opts);
    },

    /**
     * @experimental
     * Clears accepted encodings set by setAcceptedEncodings
     */

    clearAcceptedEncodingsOverride: async (): Promise<void> => {
      return await this.#sendReq("Network.clearAcceptedEncodingsOverride");
    },

    /**
     * @deprecated
     * Tells whether clearing browser cache is supported.
     */

    canClearBrowserCache: async (): Promise<{
      /**
       * True if browser cache can be cleared.
       */
      result: boolean;
    }> => {
      return await this.#sendReq("Network.canClearBrowserCache");
    },

    /**
     * @deprecated
     * Tells whether clearing browser cookies is supported.
     */

    canClearBrowserCookies: async (): Promise<{
      /**
       * True if browser cookies can be cleared.
       */
      result: boolean;
    }> => {
      return await this.#sendReq("Network.canClearBrowserCookies");
    },

    /**
     * @deprecated
     * Tells whether emulation of network conditions is supported.
     */

    canEmulateNetworkConditions: async (): Promise<{
      /**
       * True if emulation of network conditions is supported.
       */
      result: boolean;
    }> => {
      return await this.#sendReq("Network.canEmulateNetworkConditions");
    },

    /**
     * Clears browser cache.
     */

    clearBrowserCache: async (): Promise<void> => {
      return await this.#sendReq("Network.clearBrowserCache");
    },

    /**
     * Clears browser cookies.
     */

    clearBrowserCookies: async (): Promise<void> => {
      return await this.#sendReq("Network.clearBrowserCookies");
    },

    /**
     * @experimental
     * @deprecated
     * Response to Network.requestIntercepted which either modifies the request to continue with any
     * modifications, or blocks it, or completes it with the provided response bytes. If a network
     * fetch occurs as a result which encounters a redirect an additional Network.requestIntercepted
     * event will be sent with the same InterceptionId.
     * Deprecated, use Fetch.continueRequest, Fetch.fulfillRequest and Fetch.failRequest instead.
     */

    continueInterceptedRequest: async (
      opts: {
        interceptionId: Network_InterceptionId;
        /**
         * If set this causes the request to fail with the given reason. Passing `Aborted` for requests
         * marked with `isNavigationRequest` also cancels the navigation. Must not be set in response
         * to an authChallenge.
         */
        errorReason?: Network_ErrorReason;
        /**
         * If set the requests completes using with the provided base64 encoded raw response, including
         * HTTP status line and headers etc... Must not be set in response to an authChallenge.
         */
        rawResponse?: string;
        /**
         * If set the request url will be modified in a way that's not observable by page. Must not be
         * set in response to an authChallenge.
         */
        url?: string;
        /**
         * If set this allows the request method to be overridden. Must not be set in response to an
         * authChallenge.
         */
        method?: string;
        /**
         * If set this allows postData to be set. Must not be set in response to an authChallenge.
         */
        postData?: string;
        /**
         * If set this allows the request headers to be changed. Must not be set in response to an
         * authChallenge.
         */
        headers?: Network_Headers;
        /**
         * Response to a requestIntercepted with an authChallenge. Must not be set otherwise.
         */
        authChallengeResponse?: Network_AuthChallengeResponse;
      },
    ): Promise<void> => {
      return await this.#sendReq("Network.continueInterceptedRequest", opts);
    },

    /**
     * Deletes browser cookies with matching name and url or domain/path/partitionKey pair.
     */

    deleteCookies: async (opts: {
      /**
       * Name of the cookies to remove.
       */
      name: string;
      /**
       * If specified, deletes all the cookies with the given name where domain and path match
       * provided URL.
       */
      url?: string;
      /**
       * If specified, deletes only cookies with the exact domain.
       */
      domain?: string;
      /**
       * If specified, deletes only cookies with the exact path.
       */
      path?: string;
      /**
       * If specified, deletes only cookies with the the given name and partitionKey where domain
       * matches provided URL.
       */
      partitionKey?: string;
    }): Promise<void> => {
      return await this.#sendReq("Network.deleteCookies", opts);
    },

    /**
     * Disables network tracking, prevents network events from being sent to the client.
     */

    disable: async (): Promise<void> => {
      return await this.#sendReq("Network.disable");
    },

    /**
     * Activates emulation of network conditions.
     */

    emulateNetworkConditions: async (opts: {
      /**
       * True to emulate internet disconnection.
       */
      offline: boolean;
      /**
       * Minimum latency from request sent to response headers received (ms).
       */
      latency: number;
      /**
       * Maximal aggregated download throughput (bytes/sec). -1 disables download throttling.
       */
      downloadThroughput: number;
      /**
       * Maximal aggregated upload throughput (bytes/sec).  -1 disables upload throttling.
       */
      uploadThroughput: number;
      /**
       * Connection type if known.
       */
      connectionType?: Network_ConnectionType;
      /**
       * @experimental
       * WebRTC packet loss (percent, 0-100). 0 disables packet loss emulation, 100 drops all the packets.
       */
      packetLoss?: number;
      /**
       * @experimental
       * WebRTC packet queue length (packet). 0 removes any queue length limitations.
       */
      packetQueueLength?: number;
      /**
       * @experimental
       * WebRTC packetReordering feature.
       */
      packetReordering?: boolean;
    }): Promise<void> => {
      return await this.#sendReq("Network.emulateNetworkConditions", opts);
    },

    /**
     * Enables network tracking, network events will now be delivered to the client.
     */

    enable: async (opts: {
      /**
       * @experimental
       * Buffer size in bytes to use when preserving network payloads (XHRs, etc).
       */
      maxTotalBufferSize?: number;
      /**
       * @experimental
       * Per-resource buffer size in bytes to use when preserving network payloads (XHRs, etc).
       */
      maxResourceBufferSize?: number;
      /**
       * Longest post body size (in bytes) that would be included in requestWillBeSent notification
       */
      maxPostDataSize?: number;
    }): Promise<void> => {
      return await this.#sendReq("Network.enable", opts);
    },

    /**
     * @deprecated
     * Returns all browser cookies. Depending on the backend support, will return detailed cookie
     * information in the `cookies` field.
     * Deprecated. Use Storage.getCookies instead.
     */

    getAllCookies: async (): Promise<{
      /**
       * Array of cookie objects.
       */
      cookies: Network_Cookie[];
    }> => {
      return await this.#sendReq("Network.getAllCookies");
    },

    /**
     * @experimental
     * Returns the DER-encoded certificate.
     */

    getCertificate: async (opts: {
      /**
       * Origin to get certificate for.
       */
      origin: string;
    }): Promise<{ tableNames: string[] }> => {
      return await this.#sendReq("Network.getCertificate", opts);
    },

    /**
     * Returns all browser cookies for the current URL. Depending on the backend support, will return
     * detailed cookie information in the `cookies` field.
     */

    getCookies: async (opts: {
      /**
       * The list of URLs for which applicable cookies will be fetched.
       * If not specified, it's assumed to be set to the list containing
       * the URLs of the page and all of its subframes.
       */
      urls?: string[];
    }): Promise<{
      /**
       * Array of cookie objects.
       */
      cookies: Network_Cookie[];
    }> => {
      return await this.#sendReq("Network.getCookies", opts);
    },

    /**
     * Returns content served for the given request.
     */

    getResponseBody: async (opts: {
      /**
       * Identifier of the network request to get content for.
       */
      requestId: Network_RequestId;
    }): Promise<{
      /**
       * Response body.
       */
      body: string;
      /**
       * True, if content was sent as base64.
       */
      base64Encoded: boolean;
    }> => {
      return await this.#sendReq("Network.getResponseBody", opts);
    },

    /**
     * Returns post data sent with the request. Returns an error when no data was sent with the request.
     */

    getRequestPostData: async (opts: {
      /**
       * Identifier of the network request to get content for.
       */
      requestId: Network_RequestId;
    }): Promise<{
      /**
       * Request body string, omitting files from multipart requests
       */
      postData: string;
    }> => {
      return await this.#sendReq("Network.getRequestPostData", opts);
    },

    /**
     * @experimental
     * Returns content served for the given currently intercepted request.
     */

    getResponseBodyForInterception: async (opts: {
      /**
       * Identifier for the intercepted request to get body for.
       */
      interceptionId: Network_InterceptionId;
    }): Promise<{
      /**
       * Response body.
       */
      body: string;
      /**
       * True, if content was sent as base64.
       */
      base64Encoded: boolean;
    }> => {
      return await this.#sendReq(
        "Network.getResponseBodyForInterception",
        opts,
      );
    },

    /**
     * @experimental
     * Returns a handle to the stream representing the response body. Note that after this command,
     * the intercepted request can't be continued as is -- you either need to cancel it or to provide
     * the response body. The stream only supports sequential read, IO.read will fail if the position
     * is specified.
     */

    takeResponseBodyForInterceptionAsStream: async (
      opts: { interceptionId: Network_InterceptionId },
    ): Promise<{ stream: IO_StreamHandle }> => {
      return await this.#sendReq(
        "Network.takeResponseBodyForInterceptionAsStream",
        opts,
      );
    },

    /**
     * @experimental
     * This method sends a new XMLHttpRequest which is identical to the original one. The following
     * parameters should be identical: method, url, async, request body, extra headers, withCredentials
     * attribute, user, password.
     */

    replayXHR: async (opts: {
      /**
       * Identifier of XHR to replay.
       */
      requestId: Network_RequestId;
    }): Promise<void> => {
      return await this.#sendReq("Network.replayXHR", opts);
    },

    /**
     * @experimental
     * Searches for given string in response content.
     */

    searchInResponseBody: async (opts: {
      /**
       * Identifier of the network response to search.
       */
      requestId: Network_RequestId;
      /**
       * String to search for.
       */
      query: string;
      /**
       * If true, search is case sensitive.
       */
      caseSensitive?: boolean;
      /**
       * If true, treats string parameter as regex.
       */
      isRegex?: boolean;
    }): Promise<{
      /**
       * List of search matches.
       */
      result: Debugger_SearchMatch[];
    }> => {
      return await this.#sendReq("Network.searchInResponseBody", opts);
    },

    /**
     * @experimental
     * Blocks URLs from loading.
     */

    setBlockedURLs: async (opts: {
      /**
       * URL patterns to block. Wildcards ('*') are allowed.
       */
      urls: string[];
    }): Promise<void> => {
      return await this.#sendReq("Network.setBlockedURLs", opts);
    },

    /**
     * Toggles ignoring of service worker for each request.
     */

    setBypassServiceWorker: async (opts: {
      /**
       * Bypass service worker and load from network.
       */
      bypass: boolean;
    }): Promise<void> => {
      return await this.#sendReq("Network.setBypassServiceWorker", opts);
    },

    /**
     * Toggles ignoring cache for each request. If `true`, cache will not be used.
     */

    setCacheDisabled: async (opts: {
      /**
       * Cache disabled state.
       */
      cacheDisabled: boolean;
    }): Promise<void> => {
      return await this.#sendReq("Network.setCacheDisabled", opts);
    },

    /**
     * Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist.
     */

    setCookie: async (opts: {
      /**
       * Cookie name.
       */
      name: string;
      /**
       * Cookie value.
       */
      value: string;
      /**
       * The request-URI to associate with the setting of the cookie. This value can affect the
       * default domain, path, source port, and source scheme values of the created cookie.
       */
      url?: string;
      /**
       * Cookie domain.
       */
      domain?: string;
      /**
       * Cookie path.
       */
      path?: string;
      /**
       * True if cookie is secure.
       */
      secure?: boolean;
      /**
       * True if cookie is http-only.
       */
      httpOnly?: boolean;
      /**
       * Cookie SameSite type.
       */
      sameSite?: Network_CookieSameSite;
      /**
       * Cookie expiration date, session cookie if not set
       */
      expires?: Network_TimeSinceEpoch;
      /**
       * @experimental
       * Cookie Priority type.
       */
      priority?: Network_CookiePriority;
      /**
       * @experimental
       * True if cookie is SameParty.
       */
      sameParty?: boolean;
      /**
       * @experimental
       * Cookie source scheme type.
       */
      sourceScheme?: Network_CookieSourceScheme;
      /**
       * @experimental
       * Cookie source port. Valid values are {-1, [1, 65535]}, -1 indicates an unspecified port.
       * An unspecified port value allows protocol clients to emulate legacy cookie scope for the port.
       * This is a temporary ability and it will be removed in the future.
       */
      sourcePort?: number;
      /**
       * @experimental
       * Cookie partition key. The site of the top-level URL the browser was visiting at the start
       * of the request to the endpoint that set the cookie.
       * If not set, the cookie will be set as not partitioned.
       */
      partitionKey?: string;
    }): Promise<{
      /**
       * @deprecated
       * Always set to true. If an error occurs, the response indicates protocol error.
       */
      success: boolean;
    }> => {
      return await this.#sendReq("Network.setCookie", opts);
    },

    /**
     * Sets given cookies.
     */

    setCookies: async (opts: {
      /**
       * Cookies to be set.
       */
      cookies: Network_CookieParam[];
    }): Promise<void> => {
      return await this.#sendReq("Network.setCookies", opts);
    },

    /**
     * Specifies whether to always send extra HTTP headers with the requests from this page.
     */

    setExtraHTTPHeaders: async (opts: {
      /**
       * Map with extra HTTP headers.
       */
      headers: Network_Headers;
    }): Promise<void> => {
      return await this.#sendReq("Network.setExtraHTTPHeaders", opts);
    },

    /**
     * @experimental
     * Specifies whether to attach a page script stack id in requests
     */

    setAttachDebugStack: async (opts: {
      /**
       * Whether to attach a page script stack for debugging purpose.
       */
      enabled: boolean;
    }): Promise<void> => {
      return await this.#sendReq("Network.setAttachDebugStack", opts);
    },

    /**
     * @experimental
     * @deprecated
     * Sets the requests to intercept that match the provided patterns and optionally resource types.
     * Deprecated, please use Fetch.enable instead.
     */

    setRequestInterception: async (opts: {
      /**
       * Requests matching any of these patterns will be forwarded and wait for the corresponding
       * continueInterceptedRequest call.
       */
      patterns: Network_RequestPattern[];
    }): Promise<void> => {
      return await this.#sendReq("Network.setRequestInterception", opts);
    },

    /**
     * Allows overriding user agent with the given string.
     */

    setUserAgentOverride: async (opts: {
      /**
       * User agent to use.
       */
      userAgent: string;
      /**
       * Browser language to emulate.
       */
      acceptLanguage?: string;
      /**
       * The platform navigator.platform should return.
       */
      platform?: string;
      /**
       * @experimental
       * To be sent in Sec-CH-UA-* headers and returned in navigator.userAgentData
       */
      userAgentMetadata?: Emulation_UserAgentMetadata;
    }): Promise<void> => {
      return await this.#sendReq("Network.setUserAgentOverride", opts);
    },

    /**
     * @experimental
     * Enables streaming of the response for the given requestId.
     * If enabled, the dataReceived event contains the data that was received during streaming.
     */

    streamResourceContent: async (opts: {
      /**
       * Identifier of the request to stream.
       */
      requestId: Network_RequestId;
    }): Promise<{
      /**
       * Data that has been buffered until streaming is enabled.
       */
      bufferedData: string;
    }> => {
      return await this.#sendReq("Network.streamResourceContent", opts);
    },

    /**
     * @experimental
     * Returns information about the COEP/COOP isolation status.
     */

    getSecurityIsolationStatus: async (opts: {
      /**
       * If no frameId is provided, the status of the target is provided.
       */
      frameId?: Page_FrameId;
    }): Promise<{ status: Network_SecurityIsolationStatus }> => {
      return await this.#sendReq("Network.getSecurityIsolationStatus", opts);
    },

    /**
     * @experimental
     * Enables tracking for the Reporting API, events generated by the Reporting API will now be delivered to the client.
     * Enabling triggers 'reportingApiReportAdded' for all existing reports.
     */

    enableReportingApi: async (opts: {
      /**
       * Whether to enable or disable events for the Reporting API
       */
      enable: boolean;
    }): Promise<void> => {
      return await this.#sendReq("Network.enableReportingApi", opts);
    },

    /**
     * @experimental
     * Fetches the resource and returns the content.
     */

    loadNetworkResource: async (opts: {
      /**
       * Frame id to get the resource for. Mandatory for frame targets, and
       * should be omitted for worker targets.
       */
      frameId?: Page_FrameId;
      /**
       * URL of the resource to get content for.
       */
      url: string;
      /**
       * Options for the request.
       */
      options: Network_LoadNetworkResourceOptions;
    }): Promise<{ resource: Network_LoadNetworkResourcePageResult }> => {
      return await this.#sendReq("Network.loadNetworkResource", opts);
    },
  };

  /**
   * @experimental
   * This domain provides various functionality related to drawing atop the inspected page.
   */
  Overlay = {
    /**
     * Disables domain notifications.
     */

    disable: async (): Promise<void> => {
      return await this.#sendReq("Overlay.disable");
    },

    /**
     * Enables domain notifications.
     */

    enable: async (): Promise<void> => {
      return await this.#sendReq("Overlay.enable");
    },

    /**
     * For testing.
     */

    getHighlightObjectForTest: async (opts: {
      /**
       * Id of the node to get highlight object for.
       */
      nodeId: DOM_NodeId;
      /**
       * Whether to include distance info.
       */
      includeDistance?: boolean;
      /**
       * Whether to include style info.
       */
      includeStyle?: boolean;
      /**
       * The color format to get config with (default: hex).
       */
      colorFormat?: Overlay_ColorFormat;
      /**
       * Whether to show accessibility info (default: true).
       */
      showAccessibilityInfo?: boolean;
    }): Promise<{
      /**
       * Highlight data for the node.
       */
      highlight: object;
    }> => {
      return await this.#sendReq("Overlay.getHighlightObjectForTest", opts);
    },

    /**
     * For Persistent Grid testing.
     */

    getGridHighlightObjectsForTest: async (opts: {
      /**
       * Ids of the node to get highlight object for.
       */
      nodeIds: DOM_NodeId[];
    }): Promise<{
      /**
       * Grid Highlight data for the node ids provided.
       */
      highlights: object;
    }> => {
      return await this.#sendReq(
        "Overlay.getGridHighlightObjectsForTest",
        opts,
      );
    },

    /**
     * For Source Order Viewer testing.
     */

    getSourceOrderHighlightObjectForTest: async (opts: {
      /**
       * Id of the node to highlight.
       */
      nodeId: DOM_NodeId;
    }): Promise<{
      /**
       * Source order highlight data for the node id provided.
       */
      highlight: object;
    }> => {
      return await this.#sendReq(
        "Overlay.getSourceOrderHighlightObjectForTest",
        opts,
      );
    },

    /**
     * Hides any highlight.
     */

    hideHighlight: async (): Promise<void> => {
      return await this.#sendReq("Overlay.hideHighlight");
    },

    /**
     * @deprecated
     * Highlights owner element of the frame with given id.
     * Deprecated: Doesn't work reliably and cannot be fixed due to process
     * separation (the owner node might be in a different process). Determine
     * the owner node in the client and use highlightNode.
     */

    highlightFrame: async (opts: {
      /**
       * Identifier of the frame to highlight.
       */
      frameId: Page_FrameId;
      /**
       * The content box highlight fill color (default: transparent).
       */
      contentColor?: DOM_RGBA;
      /**
       * The content box highlight outline color (default: transparent).
       */
      contentOutlineColor?: DOM_RGBA;
    }): Promise<void> => {
      return await this.#sendReq("Overlay.highlightFrame", opts);
    },

    /**
     * Highlights DOM node with given id or with the given JavaScript object wrapper. Either nodeId or
     * objectId must be specified.
     */

    highlightNode: async (opts: {
      /**
       * A descriptor for the highlight appearance.
       */
      highlightConfig: Overlay_HighlightConfig;
      /**
       * Identifier of the node to highlight.
       */
      nodeId?: DOM_NodeId;
      /**
       * Identifier of the backend node to highlight.
       */
      backendNodeId?: DOM_BackendNodeId;
      /**
       * JavaScript object id of the node to be highlighted.
       */
      objectId?: Runtime_RemoteObjectId;
      /**
       * Selectors to highlight relevant nodes.
       */
      selector?: string;
    }): Promise<void> => {
      return await this.#sendReq("Overlay.highlightNode", opts);
    },

    /**
     * Highlights given quad. Coordinates are absolute with respect to the main frame viewport.
     */

    highlightQuad: async (opts: {
      /**
       * Quad to highlight
       */
      quad: DOM_Quad;
      /**
       * The highlight fill color (default: transparent).
       */
      color?: DOM_RGBA;
      /**
       * The highlight outline color (default: transparent).
       */
      outlineColor?: DOM_RGBA;
    }): Promise<void> => {
      return await this.#sendReq("Overlay.highlightQuad", opts);
    },

    /**
     * Highlights given rectangle. Coordinates are absolute with respect to the main frame viewport.
     */

    highlightRect: async (opts: {
      /**
       * X coordinate
       */
      x: number;
      /**
       * Y coordinate
       */
      y: number;
      /**
       * Rectangle width
       */
      width: number;
      /**
       * Rectangle height
       */
      height: number;
      /**
       * The highlight fill color (default: transparent).
       */
      color?: DOM_RGBA;
      /**
       * The highlight outline color (default: transparent).
       */
      outlineColor?: DOM_RGBA;
    }): Promise<void> => {
      return await this.#sendReq("Overlay.highlightRect", opts);
    },

    /**
     * Highlights the source order of the children of the DOM node with given id or with the given
     * JavaScript object wrapper. Either nodeId or objectId must be specified.
     */

    highlightSourceOrder: async (opts: {
      /**
       * A descriptor for the appearance of the overlay drawing.
       */
      sourceOrderConfig: Overlay_SourceOrderConfig;
      /**
       * Identifier of the node to highlight.
       */
      nodeId?: DOM_NodeId;
      /**
       * Identifier of the backend node to highlight.
       */
      backendNodeId?: DOM_BackendNodeId;
      /**
       * JavaScript object id of the node to be highlighted.
       */
      objectId?: Runtime_RemoteObjectId;
    }): Promise<void> => {
      return await this.#sendReq("Overlay.highlightSourceOrder", opts);
    },

    /**
     * Enters the 'inspect' mode. In this mode, elements that user is hovering over are highlighted.
     * Backend then generates 'inspectNodeRequested' event upon element selection.
     */

    setInspectMode: async (opts: {
      /**
       * Set an inspection mode.
       */
      mode: Overlay_InspectMode;
      /**
       * A descriptor for the highlight appearance of hovered-over nodes. May be omitted if `enabled
       * == false`.
       */
      highlightConfig?: Overlay_HighlightConfig;
    }): Promise<void> => {
      return await this.#sendReq("Overlay.setInspectMode", opts);
    },

    /**
     * Highlights owner element of all frames detected to be ads.
     */

    setShowAdHighlights: async (opts: {
      /**
       * True for showing ad highlights
       */
      show: boolean;
    }): Promise<void> => {
      return await this.#sendReq("Overlay.setShowAdHighlights", opts);
    },

    setPausedInDebuggerMessage: async (opts: {
      /**
       * The message to display, also triggers resume and step over controls.
       */
      message?: string;
    }): Promise<void> => {
      return await this.#sendReq("Overlay.setPausedInDebuggerMessage", opts);
    },

    /**
     * Requests that backend shows debug borders on layers
     */

    setShowDebugBorders: async (opts: {
      /**
       * True for showing debug borders
       */
      show: boolean;
    }): Promise<void> => {
      return await this.#sendReq("Overlay.setShowDebugBorders", opts);
    },

    /**
     * Requests that backend shows the FPS counter
     */

    setShowFPSCounter: async (opts: {
      /**
       * True for showing the FPS counter
       */
      show: boolean;
    }): Promise<void> => {
      return await this.#sendReq("Overlay.setShowFPSCounter", opts);
    },

    /**
     * Highlight multiple elements with the CSS Grid overlay.
     */

    setShowGridOverlays: async (opts: {
      /**
       * An array of node identifiers and descriptors for the highlight appearance.
       */
      gridNodeHighlightConfigs: Overlay_GridNodeHighlightConfig[];
    }): Promise<void> => {
      return await this.#sendReq("Overlay.setShowGridOverlays", opts);
    },

    setShowFlexOverlays: async (opts: {
      /**
       * An array of node identifiers and descriptors for the highlight appearance.
       */
      flexNodeHighlightConfigs: Overlay_FlexNodeHighlightConfig[];
    }): Promise<void> => {
      return await this.#sendReq("Overlay.setShowFlexOverlays", opts);
    },

    setShowScrollSnapOverlays: async (opts: {
      /**
       * An array of node identifiers and descriptors for the highlight appearance.
       */
      scrollSnapHighlightConfigs: Overlay_ScrollSnapHighlightConfig[];
    }): Promise<void> => {
      return await this.#sendReq("Overlay.setShowScrollSnapOverlays", opts);
    },

    setShowContainerQueryOverlays: async (opts: {
      /**
       * An array of node identifiers and descriptors for the highlight appearance.
       */
      containerQueryHighlightConfigs: Overlay_ContainerQueryHighlightConfig[];
    }): Promise<void> => {
      return await this.#sendReq("Overlay.setShowContainerQueryOverlays", opts);
    },

    /**
     * Requests that backend shows paint rectangles
     */

    setShowPaintRects: async (opts: {
      /**
       * True for showing paint rectangles
       */
      result: boolean;
    }): Promise<void> => {
      return await this.#sendReq("Overlay.setShowPaintRects", opts);
    },

    /**
     * Requests that backend shows layout shift regions
     */

    setShowLayoutShiftRegions: async (opts: {
      /**
       * True for showing layout shift regions
       */
      result: boolean;
    }): Promise<void> => {
      return await this.#sendReq("Overlay.setShowLayoutShiftRegions", opts);
    },

    /**
     * Requests that backend shows scroll bottleneck rects
     */

    setShowScrollBottleneckRects: async (opts: {
      /**
       * True for showing scroll bottleneck rects
       */
      show: boolean;
    }): Promise<void> => {
      return await this.#sendReq("Overlay.setShowScrollBottleneckRects", opts);
    },

    /**
     * @deprecated
     * Deprecated, no longer has any effect.
     */

    setShowHitTestBorders: async (opts: {
      /**
       * True for showing hit-test borders
       */
      show: boolean;
    }): Promise<void> => {
      return await this.#sendReq("Overlay.setShowHitTestBorders", opts);
    },

    /**
     * Request that backend shows an overlay with web vital metrics.
     */

    setShowWebVitals: async (opts: { show: boolean }): Promise<void> => {
      return await this.#sendReq("Overlay.setShowWebVitals", opts);
    },

    /**
     * Paints viewport size upon main frame resize.
     */

    setShowViewportSizeOnResize: async (opts: {
      /**
       * Whether to paint size or not.
       */
      show: boolean;
    }): Promise<void> => {
      return await this.#sendReq("Overlay.setShowViewportSizeOnResize", opts);
    },

    /**
     * Add a dual screen device hinge
     */

    setShowHinge: async (opts: {
      /**
       * hinge data, null means hideHinge
       */
      hingeConfig?: Overlay_HingeConfig;
    }): Promise<void> => {
      return await this.#sendReq("Overlay.setShowHinge", opts);
    },

    /**
     * Show elements in isolation mode with overlays.
     */

    setShowIsolatedElements: async (opts: {
      /**
       * An array of node identifiers and descriptors for the highlight appearance.
       */
      isolatedElementHighlightConfigs: Overlay_IsolatedElementHighlightConfig[];
    }): Promise<void> => {
      return await this.#sendReq("Overlay.setShowIsolatedElements", opts);
    },

    /**
     * Show Window Controls Overlay for PWA
     */

    setShowWindowControlsOverlay: async (opts: {
      /**
       * Window Controls Overlay data, null means hide Window Controls Overlay
       */
      windowControlsOverlayConfig?: Overlay_WindowControlsOverlayConfig;
    }): Promise<void> => {
      return await this.#sendReq("Overlay.setShowWindowControlsOverlay", opts);
    },
  };

  /**
   * Actions and events related to the inspected page belong to the page domain.
   */
  Page = {
    /**
     * @experimental
     * @deprecated
     * Deprecated, please use addScriptToEvaluateOnNewDocument instead.
     */

    addScriptToEvaluateOnLoad: async (opts: { scriptSource: string }): Promise<{
      /**
       * Identifier of the added script.
       */
      identifier: Page_ScriptIdentifier;
    }> => {
      return await this.#sendReq("Page.addScriptToEvaluateOnLoad", opts);
    },

    /**
     * Evaluates given script in every frame upon creation (before loading frame's scripts).
     */

    addScriptToEvaluateOnNewDocument: async (opts: {
      source: string;
      /**
       * @experimental
       * If specified, creates an isolated world with the given name and evaluates given script in it.
       * This world name will be used as the ExecutionContextDescription::name when the corresponding
       * event is emitted.
       */
      worldName?: string;
      /**
       * @experimental
       * Specifies whether command line API should be available to the script, defaults
       * to false.
       */
      includeCommandLineAPI?: boolean;
      /**
       * @experimental
       * If true, runs the script immediately on existing execution contexts or worlds.
       * Default: false.
       */
      runImmediately?: boolean;
    }): Promise<{
      /**
       * Identifier of the added script.
       */
      identifier: Page_ScriptIdentifier;
    }> => {
      return await this.#sendReq("Page.addScriptToEvaluateOnNewDocument", opts);
    },

    /**
     * Brings page to front (activates tab).
     */

    bringToFront: async (): Promise<void> => {
      return await this.#sendReq("Page.bringToFront");
    },

    /**
     * Capture page screenshot.
     */

    captureScreenshot: async (opts: {
      /**
       * Image compression format (defaults to png).
       */
      format?: "jpeg" | "png" | "webp";
      /**
       * Compression quality from range [0..100] (jpeg only).
       */
      quality?: number;
      /**
       * Capture the screenshot of a given region only.
       */
      clip?: Page_Viewport;
      /**
       * @experimental
       * Capture the screenshot from the surface, rather than the view. Defaults to true.
       */
      fromSurface?: boolean;
      /**
       * @experimental
       * Capture the screenshot beyond the viewport. Defaults to false.
       */
      captureBeyondViewport?: boolean;
      /**
       * @experimental
       * Optimize image encoding for speed, not for resulting size (defaults to false)
       */
      optimizeForSpeed?: boolean;
    }): Promise<{
      /**
       * Base64-encoded image data.
       */
      data: string;
    }> => {
      return await this.#sendReq("Page.captureScreenshot", opts);
    },

    /**
     * @experimental
     * Returns a snapshot of the page as a string. For MHTML format, the serialization includes
     * iframes, shadow DOM, external resources, and element-inline styles.
     */

    captureSnapshot: async (opts: {
      /**
       * Format (defaults to mhtml).
       */
      format?: "mhtml";
    }): Promise<{
      /**
       * Serialized page data.
       */
      data: string;
    }> => {
      return await this.#sendReq("Page.captureSnapshot", opts);
    },

    /**
     * @experimental
     * @deprecated
     * Clears the overridden device metrics.
     */

    clearDeviceMetricsOverride: async (): Promise<void> => {
      return await this.#sendReq("Page.clearDeviceMetricsOverride");
    },

    /**
     * @experimental
     * @deprecated
     * Clears the overridden Device Orientation.
     */

    clearDeviceOrientationOverride: async (): Promise<void> => {
      return await this.#sendReq("Page.clearDeviceOrientationOverride");
    },

    /**
     * @deprecated
     * Clears the overridden Geolocation Position and Error.
     */

    clearGeolocationOverride: async (): Promise<void> => {
      return await this.#sendReq("Page.clearGeolocationOverride");
    },

    /**
     * Creates an isolated world for the given frame.
     */

    createIsolatedWorld: async (opts: {
      /**
       * Id of the frame in which the isolated world should be created.
       */
      frameId: Page_FrameId;
      /**
       * An optional name which is reported in the Execution Context.
       */
      worldName?: string;
      /**
       * Whether or not universal access should be granted to the isolated world. This is a powerful
       * option, use with caution.
       */
      grantUniveralAccess?: boolean;
    }): Promise<{
      /**
       * Execution context of the isolated world.
       */
      executionContextId: Runtime_ExecutionContextId;
    }> => {
      return await this.#sendReq("Page.createIsolatedWorld", opts);
    },

    /**
     * @experimental
     * @deprecated
     * Deletes browser cookie with given name, domain and path.
     */

    deleteCookie: async (opts: {
      /**
       * Name of the cookie to remove.
       */
      cookieName: string;
      /**
       * URL to match cooke domain and path.
       */
      url: string;
    }): Promise<void> => {
      return await this.#sendReq("Page.deleteCookie", opts);
    },

    /**
     * Disables page domain notifications.
     */

    disable: async (): Promise<void> => {
      return await this.#sendReq("Page.disable");
    },

    /**
     * Enables page domain notifications.
     */

    enable: async (): Promise<void> => {
      return await this.#sendReq("Page.enable");
    },

    getAppManifest: async (): Promise<{
      /**
       * Manifest location.
       */
      url: string;
      errors: Page_AppManifestError[];
      /**
       * Manifest content.
       */
      data?: string;
      /**
       * @experimental
       * Parsed manifest properties
       */
      parsed?: Page_AppManifestParsedProperties;
    }> => {
      return await this.#sendReq("Page.getAppManifest");
    },

    /**
     * @experimental
     */

    getInstallabilityErrors: async (): Promise<
      { installabilityErrors: Page_InstallabilityError[] }
    > => {
      return await this.#sendReq("Page.getInstallabilityErrors");
    },

    /**
     * @experimental
     * @deprecated
     * Deprecated because it's not guaranteed that the returned icon is in fact the one used for PWA installation.
     */

    getManifestIcons: async (): Promise<{ primaryIcon?: string }> => {
      return await this.#sendReq("Page.getManifestIcons");
    },

    /**
     * @experimental
     * Returns the unique (PWA) app id.
     * Only returns values if the feature flag 'WebAppEnableManifestId' is enabled
     */

    getAppId: async (): Promise<{
      /**
       * App id, either from manifest's id attribute or computed from start_url
       */
      appId?: string;
      /**
       * Recommendation for manifest's id attribute to match current id computed from start_url
       */
      recommendedId?: string;
    }> => {
      return await this.#sendReq("Page.getAppId");
    },

    /**
     * @experimental
     */

    getAdScriptId: async (opts: { frameId: Page_FrameId }): Promise<{
      /**
       * Identifies the bottom-most script which caused the frame to be labelled
       * as an ad. Only sent if frame is labelled as an ad and id is available.
       */
      adScriptId?: Page_AdScriptId;
    }> => {
      return await this.#sendReq("Page.getAdScriptId", opts);
    },

    /**
     * Returns present frame tree structure.
     */

    getFrameTree: async (): Promise<{
      /**
       * Present frame tree structure.
       */
      frameTree: Page_FrameTree;
    }> => {
      return await this.#sendReq("Page.getFrameTree");
    },

    /**
     * Returns metrics relating to the layouting of the page, such as viewport bounds/scale.
     */

    getLayoutMetrics: async (): Promise<{
      /**
       * @deprecated
       * Deprecated metrics relating to the layout viewport. Is in device pixels. Use `cssLayoutViewport` instead.
       */
      layoutViewport: Page_LayoutViewport;
      /**
       * @deprecated
       * Deprecated metrics relating to the visual viewport. Is in device pixels. Use `cssVisualViewport` instead.
       */
      visualViewport: Page_VisualViewport;
      /**
       * @deprecated
       * Deprecated size of scrollable area. Is in DP. Use `cssContentSize` instead.
       */
      contentSize: DOM_Rect;
      /**
       * Metrics relating to the layout viewport in CSS pixels.
       */
      cssLayoutViewport: Page_LayoutViewport;
      /**
       * Metrics relating to the visual viewport in CSS pixels.
       */
      cssVisualViewport: Page_VisualViewport;
      /**
       * Size of scrollable area in CSS pixels.
       */
      cssContentSize: DOM_Rect;
    }> => {
      return await this.#sendReq("Page.getLayoutMetrics");
    },

    /**
     * Returns navigation history for the current page.
     */

    getNavigationHistory: async (): Promise<{
      /**
       * Index of the current navigation history entry.
       */
      currentIndex: number;
      /**
       * Array of navigation history entries.
       */
      entries: Page_NavigationEntry[];
    }> => {
      return await this.#sendReq("Page.getNavigationHistory");
    },

    /**
     * Resets navigation history for the current page.
     */

    resetNavigationHistory: async (): Promise<void> => {
      return await this.#sendReq("Page.resetNavigationHistory");
    },

    /**
     * @experimental
     * Returns content of the given resource.
     */

    getResourceContent: async (opts: {
      /**
       * Frame id to get resource for.
       */
      frameId: Page_FrameId;
      /**
       * URL of the resource to get content for.
       */
      url: string;
    }): Promise<{
      /**
       * Resource content.
       */
      content: string;
      /**
       * True, if content was served as base64.
       */
      base64Encoded: boolean;
    }> => {
      return await this.#sendReq("Page.getResourceContent", opts);
    },

    /**
     * @experimental
     * Returns present frame / resource tree structure.
     */

    getResourceTree: async (): Promise<{
      /**
       * Present frame / resource tree structure.
       */
      frameTree: Page_FrameResourceTree;
    }> => {
      return await this.#sendReq("Page.getResourceTree");
    },

    /**
     * Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).
     */

    handleJavaScriptDialog: async (opts: {
      /**
       * Whether to accept or dismiss the dialog.
       */
      accept: boolean;
      /**
       * The text to enter into the dialog prompt before accepting. Used only if this is a prompt
       * dialog.
       */
      promptText?: string;
    }): Promise<void> => {
      return await this.#sendReq("Page.handleJavaScriptDialog", opts);
    },

    /**
     * Navigates current page to the given URL.
     */

    navigate: async (opts: {
      /**
       * URL to navigate the page to.
       */
      url: string;
      /**
       * Referrer URL.
       */
      referrer?: string;
      /**
       * Intended transition type.
       */
      transitionType?: Page_TransitionType;
      /**
       * Frame id to navigate, if not specified navigates the top frame.
       */
      frameId?: Page_FrameId;
      /**
       * @experimental
       * Referrer-policy used for the navigation.
       */
      referrerPolicy?: Page_ReferrerPolicy;
    }): Promise<{
      /**
       * Frame id that has navigated (or failed to navigate)
       */
      frameId: Page_FrameId;
      /**
       * Loader identifier. This is omitted in case of same-document navigation,
       * as the previously committed loaderId would not change.
       */
      loaderId?: Network_LoaderId;
      /**
       * User friendly error message, present if and only if navigation has failed.
       */
      errorText?: string;
    }> => {
      return await this.#sendReq("Page.navigate", opts);
    },

    /**
     * Navigates current page to the given history entry.
     */

    navigateToHistoryEntry: async (opts: {
      /**
       * Unique id of the entry to navigate to.
       */
      entryId: number;
    }): Promise<void> => {
      return await this.#sendReq("Page.navigateToHistoryEntry", opts);
    },

    /**
     * Print page as PDF.
     */

    printToPDF: async (opts: {
      /**
       * Paper orientation. Defaults to false.
       */
      landscape?: boolean;
      /**
       * Display header and footer. Defaults to false.
       */
      displayHeaderFooter?: boolean;
      /**
       * Print background graphics. Defaults to false.
       */
      printBackground?: boolean;
      /**
       * Scale of the webpage rendering. Defaults to 1.
       */
      scale?: number;
      /**
       * Paper width in inches. Defaults to 8.5 inches.
       */
      paperWidth?: number;
      /**
       * Paper height in inches. Defaults to 11 inches.
       */
      paperHeight?: number;
      /**
       * Top margin in inches. Defaults to 1cm (~0.4 inches).
       */
      marginTop?: number;
      /**
       * Bottom margin in inches. Defaults to 1cm (~0.4 inches).
       */
      marginBottom?: number;
      /**
       * Left margin in inches. Defaults to 1cm (~0.4 inches).
       */
      marginLeft?: number;
      /**
       * Right margin in inches. Defaults to 1cm (~0.4 inches).
       */
      marginRight?: number;
      /**
       * Paper ranges to print, one based, e.g., '1-5, 8, 11-13'. Pages are
       * printed in the document order, not in the order specified, and no
       * more than once.
       * Defaults to empty string, which implies the entire document is printed.
       * The page numbers are quietly capped to actual page count of the
       * document, and ranges beyond the end of the document are ignored.
       * If this results in no pages to print, an error is reported.
       * It is an error to specify a range with start greater than end.
       */
      pageRanges?: string;
      /**
       * HTML template for the print header. Should be valid HTML markup with following
       * classes used to inject printing values into them:
       * - `date`: formatted print date
       * - `title`: document title
       * - `url`: document location
       * - `pageNumber`: current page number
       * - `totalPages`: total pages in the document
       *
       * For example, `<span class=title></span>` would generate span containing the title.
       */
      headerTemplate?: string;
      /**
       * HTML template for the print footer. Should use the same format as the `headerTemplate`.
       */
      footerTemplate?: string;
      /**
       * Whether or not to prefer page size as defined by css. Defaults to false,
       * in which case the content will be scaled to fit the paper size.
       */
      preferCSSPageSize?: boolean;
      /**
       * @experimental
       * return as stream
       */
      transferMode?: "ReturnAsBase64" | "ReturnAsStream";
      /**
       * @experimental
       * Whether or not to generate tagged (accessible) PDF. Defaults to embedder choice.
       */
      generateTaggedPDF?: boolean;
      /**
       * @experimental
       * Whether or not to embed the document outline into the PDF.
       */
      generateDocumentOutline?: boolean;
    }): Promise<{
      /**
       * Base64-encoded pdf data. Empty if |returnAsStream| is specified.
       */
      data: string;
      /**
       * @experimental
       * A handle of the stream that holds resulting PDF data.
       */
      stream?: IO_StreamHandle;
    }> => {
      return await this.#sendReq("Page.printToPDF", opts);
    },

    /**
     * Reloads given page optionally ignoring the cache.
     */

    reload: async (opts: {
      /**
       * If true, browser cache is ignored (as if the user pressed Shift+refresh).
       */
      ignoreCache?: boolean;
      /**
       * If set, the script will be injected into all frames of the inspected page after reload.
       * Argument will be ignored if reloading dataURL origin.
       */
      scriptToEvaluateOnLoad?: string;
    }): Promise<void> => {
      return await this.#sendReq("Page.reload", opts);
    },

    /**
     * @experimental
     * @deprecated
     * Deprecated, please use removeScriptToEvaluateOnNewDocument instead.
     */

    removeScriptToEvaluateOnLoad: async (
      opts: { identifier: Page_ScriptIdentifier },
    ): Promise<void> => {
      return await this.#sendReq("Page.removeScriptToEvaluateOnLoad", opts);
    },

    /**
     * Removes given script from the list.
     */

    removeScriptToEvaluateOnNewDocument: async (
      opts: { identifier: Page_ScriptIdentifier },
    ): Promise<void> => {
      return await this.#sendReq(
        "Page.removeScriptToEvaluateOnNewDocument",
        opts,
      );
    },

    /**
     * @experimental
     * Acknowledges that a screencast frame has been received by the frontend.
     */

    screencastFrameAck: async (opts: {
      /**
       * Frame number.
       */
      sessionId: number;
    }): Promise<void> => {
      return await this.#sendReq("Page.screencastFrameAck", opts);
    },

    /**
     * @experimental
     * Searches for given string in resource content.
     */

    searchInResource: async (opts: {
      /**
       * Frame id for resource to search in.
       */
      frameId: Page_FrameId;
      /**
       * URL of the resource to search in.
       */
      url: string;
      /**
       * String to search for.
       */
      query: string;
      /**
       * If true, search is case sensitive.
       */
      caseSensitive?: boolean;
      /**
       * If true, treats string parameter as regex.
       */
      isRegex?: boolean;
    }): Promise<{
      /**
       * List of search matches.
       */
      result: Debugger_SearchMatch[];
    }> => {
      return await this.#sendReq("Page.searchInResource", opts);
    },

    /**
     * @experimental
     * Enable Chrome's experimental ad filter on all sites.
     */

    setAdBlockingEnabled: async (opts: {
      /**
       * Whether to block ads.
       */
      enabled: boolean;
    }): Promise<void> => {
      return await this.#sendReq("Page.setAdBlockingEnabled", opts);
    },

    /**
     * Enable page Content Security Policy by-passing.
     */

    setBypassCSP: async (opts: {
      /**
       * Whether to bypass page CSP.
       */
      enabled: boolean;
    }): Promise<void> => {
      return await this.#sendReq("Page.setBypassCSP", opts);
    },

    /**
     * @experimental
     * Get Permissions Policy state on given frame.
     */

    getPermissionsPolicyState: async (
      opts: { frameId: Page_FrameId },
    ): Promise<{ states: Page_PermissionsPolicyFeatureState[] }> => {
      return await this.#sendReq("Page.getPermissionsPolicyState", opts);
    },

    /**
     * @experimental
     * Get Origin Trials on given frame.
     */

    getOriginTrials: async (
      opts: { frameId: Page_FrameId },
    ): Promise<{ originTrials: Page_OriginTrial[] }> => {
      return await this.#sendReq("Page.getOriginTrials", opts);
    },

    /**
     * @experimental
     * @deprecated
     * Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
     * window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
     * query results).
     */

    setDeviceMetricsOverride: async (opts: {
      /**
       * Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
       */
      width: number;
      /**
       * Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
       */
      height: number;
      /**
       * Overriding device scale factor value. 0 disables the override.
       */
      deviceScaleFactor: number;
      /**
       * Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text
       * autosizing and more.
       */
      mobile: boolean;
      /**
       * Scale to apply to resulting view image.
       */
      scale?: number;
      /**
       * Overriding screen width value in pixels (minimum 0, maximum 10000000).
       */
      screenWidth?: number;
      /**
       * Overriding screen height value in pixels (minimum 0, maximum 10000000).
       */
      screenHeight?: number;
      /**
       * Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
       */
      positionX?: number;
      /**
       * Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
       */
      positionY?: number;
      /**
       * Do not set visible view size, rely upon explicit setVisibleSize call.
       */
      dontSetVisibleSize?: boolean;
      /**
       * Screen orientation override.
       */
      screenOrientation?: Emulation_ScreenOrientation;
      /**
       * The viewport dimensions and scale. If not set, the override is cleared.
       */
      viewport?: Page_Viewport;
    }): Promise<void> => {
      return await this.#sendReq("Page.setDeviceMetricsOverride", opts);
    },

    /**
     * @experimental
     * @deprecated
     * Overrides the Device Orientation.
     */

    setDeviceOrientationOverride: async (opts: {
      /**
       * Mock alpha
       */
      alpha: number;
      /**
       * Mock beta
       */
      beta: number;
      /**
       * Mock gamma
       */
      gamma: number;
    }): Promise<void> => {
      return await this.#sendReq("Page.setDeviceOrientationOverride", opts);
    },

    /**
     * @experimental
     * Set generic font families.
     */

    setFontFamilies: async (opts: {
      /**
       * Specifies font families to set. If a font family is not specified, it won't be changed.
       */
      fontFamilies: Page_FontFamilies;
      /**
       * Specifies font families to set for individual scripts.
       */
      forScripts?: Page_ScriptFontFamilies[];
    }): Promise<void> => {
      return await this.#sendReq("Page.setFontFamilies", opts);
    },

    /**
     * @experimental
     * Set default font sizes.
     */

    setFontSizes: async (opts: {
      /**
       * Specifies font sizes to set. If a font size is not specified, it won't be changed.
       */
      fontSizes: Page_FontSizes;
    }): Promise<void> => {
      return await this.#sendReq("Page.setFontSizes", opts);
    },

    /**
     * Sets given markup as the document's HTML.
     */

    setDocumentContent: async (opts: {
      /**
       * Frame id to set HTML for.
       */
      frameId: Page_FrameId;
      /**
       * HTML content to set.
       */
      html: string;
    }): Promise<void> => {
      return await this.#sendReq("Page.setDocumentContent", opts);
    },

    /**
     * @experimental
     * @deprecated
     * Set the behavior when downloading a file.
     */

    setDownloadBehavior: async (opts: {
      /**
       * Whether to allow all or deny all download requests, or use default Chrome behavior if
       * available (otherwise deny).
       */
      behavior: "deny" | "allow" | "default";
      /**
       * The default path to save downloaded files to. This is required if behavior is set to 'allow'
       */
      downloadPath?: string;
    }): Promise<void> => {
      return await this.#sendReq("Page.setDownloadBehavior", opts);
    },

    /**
     * @deprecated
     * Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
     * unavailable.
     */

    setGeolocationOverride: async (opts: {
      /**
       * Mock latitude
       */
      latitude?: number;
      /**
       * Mock longitude
       */
      longitude?: number;
      /**
       * Mock accuracy
       */
      accuracy?: number;
    }): Promise<void> => {
      return await this.#sendReq("Page.setGeolocationOverride", opts);
    },

    /**
     * Controls whether page will emit lifecycle events.
     */

    setLifecycleEventsEnabled: async (opts: {
      /**
       * If true, starts emitting lifecycle events.
       */
      enabled: boolean;
    }): Promise<void> => {
      return await this.#sendReq("Page.setLifecycleEventsEnabled", opts);
    },

    /**
     * @experimental
     * @deprecated
     * Toggles mouse event-based touch event emulation.
     */

    setTouchEmulationEnabled: async (opts: {
      /**
       * Whether the touch event emulation should be enabled.
       */
      enabled: boolean;
      /**
       * Touch/gesture events configuration. Default: current platform.
       */
      configuration?: "mobile" | "desktop";
    }): Promise<void> => {
      return await this.#sendReq("Page.setTouchEmulationEnabled", opts);
    },

    /**
     * @experimental
     * Starts sending each frame using the `screencastFrame` event.
     */

    startScreencast: async (opts: {
      /**
       * Image compression format.
       */
      format?: "jpeg" | "png";
      /**
       * Compression quality from range [0..100].
       */
      quality?: number;
      /**
       * Maximum screenshot width.
       */
      maxWidth?: number;
      /**
       * Maximum screenshot height.
       */
      maxHeight?: number;
      /**
       * Send every n-th frame.
       */
      everyNthFrame?: number;
    }): Promise<void> => {
      return await this.#sendReq("Page.startScreencast", opts);
    },

    /**
     * Force the page stop all navigations and pending resource fetches.
     */

    stopLoading: async (): Promise<void> => {
      return await this.#sendReq("Page.stopLoading");
    },

    /**
     * @experimental
     * Crashes renderer on the IO thread, generates minidumps.
     */

    crash: async (): Promise<void> => {
      return await this.#sendReq("Page.crash");
    },

    /**
     * Tries to close page, running its beforeunload hooks, if any.
     */

    close: async (): Promise<void> => {
      return await this.#sendReq("Page.close");
    },

    /**
     * @experimental
     * Tries to update the web lifecycle state of the page.
     * It will transition the page to the given state according to:
     * https://github.com/WICG/web-lifecycle/
     */

    setWebLifecycleState: async (opts: {
      /**
       * Target lifecycle state
       */
      state: "frozen" | "active";
    }): Promise<void> => {
      return await this.#sendReq("Page.setWebLifecycleState", opts);
    },

    /**
     * @experimental
     * Stops sending each frame in the `screencastFrame`.
     */

    stopScreencast: async (): Promise<void> => {
      return await this.#sendReq("Page.stopScreencast");
    },

    /**
     * @experimental
     * Requests backend to produce compilation cache for the specified scripts.
     * `scripts` are appended to the list of scripts for which the cache
     * would be produced. The list may be reset during page navigation.
     * When script with a matching URL is encountered, the cache is optionally
     * produced upon backend discretion, based on internal heuristics.
     * See also: `Page.compilationCacheProduced`.
     */

    produceCompilationCache: async (
      opts: { scripts: Page_CompilationCacheParams[] },
    ): Promise<void> => {
      return await this.#sendReq("Page.produceCompilationCache", opts);
    },

    /**
     * @experimental
     * Seeds compilation cache for given url. Compilation cache does not survive
     * cross-process navigation.
     */

    addCompilationCache: async (opts: {
      url: string;
      /**
       * Base64-encoded data
       */
      data: string;
    }): Promise<void> => {
      return await this.#sendReq("Page.addCompilationCache", opts);
    },

    /**
     * @experimental
     * Clears seeded compilation cache.
     */

    clearCompilationCache: async (): Promise<void> => {
      return await this.#sendReq("Page.clearCompilationCache");
    },

    /**
     * @experimental
     * Sets the Secure Payment Confirmation transaction mode.
     * https://w3c.github.io/secure-payment-confirmation/#sctn-automation-set-spc-transaction-mode
     */

    setSPCTransactionMode: async (
      opts: { mode: Page_AutoResponseMode },
    ): Promise<void> => {
      return await this.#sendReq("Page.setSPCTransactionMode", opts);
    },

    /**
     * @experimental
     * Extensions for Custom Handlers API:
     * https://html.spec.whatwg.org/multipage/system-state.html#rph-automation
     */

    setRPHRegistrationMode: async (
      opts: { mode: Page_AutoResponseMode },
    ): Promise<void> => {
      return await this.#sendReq("Page.setRPHRegistrationMode", opts);
    },

    /**
     * @experimental
     * Generates a report for testing.
     */

    generateTestReport: async (opts: {
      /**
       * Message to be displayed in the report.
       */
      message: string;
      /**
       * Specifies the endpoint group to deliver the report to.
       */
      group?: string;
    }): Promise<void> => {
      return await this.#sendReq("Page.generateTestReport", opts);
    },

    /**
     * @experimental
     * Pauses page execution. Can be resumed using generic Runtime.runIfWaitingForDebugger.
     */

    waitForDebugger: async (): Promise<void> => {
      return await this.#sendReq("Page.waitForDebugger");
    },

    /**
     * Intercept file chooser requests and transfer control to protocol clients.
     * When file chooser interception is enabled, native file chooser dialog is not shown.
     * Instead, a protocol event `Page.fileChooserOpened` is emitted.
     */

    setInterceptFileChooserDialog: async (
      opts: { enabled: boolean },
    ): Promise<void> => {
      return await this.#sendReq("Page.setInterceptFileChooserDialog", opts);
    },

    /**
     * @experimental
     * Enable/disable prerendering manually.
     *
     * This command is a short-term solution for https://crbug.com/1440085.
     * See https://docs.google.com/document/d/12HVmFxYj5Jc-eJr5OmWsa2bqTJsbgGLKI6ZIyx0_wpA
     * for more details.
     *
     * TODO(https://crbug.com/1440085): Remove this once Puppeteer supports tab targets.
     */

    setPrerenderingAllowed: async (
      opts: { isAllowed: boolean },
    ): Promise<void> => {
      return await this.#sendReq("Page.setPrerenderingAllowed", opts);
    },
  };

  Performance = {
    /**
     * Disable collecting and reporting metrics.
     */

    disable: async (): Promise<void> => {
      return await this.#sendReq("Performance.disable");
    },

    /**
     * Enable collecting and reporting metrics.
     */

    enable: async (opts: {
      /**
       * Time domain to use for collecting and reporting duration metrics.
       */
      timeDomain?: "timeTicks" | "threadTicks";
    }): Promise<void> => {
      return await this.#sendReq("Performance.enable", opts);
    },

    /**
     * @experimental
     * @deprecated
     * Sets time domain to use for collecting and reporting duration metrics.
     * Note that this must be called before enabling metrics collection. Calling
     * this method while metrics collection is enabled returns an error.
     */

    setTimeDomain: async (opts: {
      /**
       * Time domain
       */
      timeDomain: "timeTicks" | "threadTicks";
    }): Promise<void> => {
      return await this.#sendReq("Performance.setTimeDomain", opts);
    },

    /**
     * Retrieve current values of run-time metrics.
     */

    getMetrics: async (): Promise<{
      /**
       * Current values for run-time metrics.
       */
      metrics: Performance_Metric[];
    }> => {
      return await this.#sendReq("Performance.getMetrics");
    },
  };

  /**
   * @experimental
   * Reporting of performance timeline events, as specified in
   * https://w3c.github.io/performance-timeline/#dom-performanceobserver.
   */
  PerformanceTimeline = {
    /**
     * Previously buffered events would be reported before method returns.
     * See also: timelineEventAdded
     */

    enable: async (opts: {
      /**
       * The types of event to report, as specified in
       * https://w3c.github.io/performance-timeline/#dom-performanceentry-entrytype
       * The specified filter overrides any previous filters, passing empty
       * filter disables recording.
       * Note that not all types exposed to the web platform are currently supported.
       */
      eventTypes: string[];
    }): Promise<void> => {
      return await this.#sendReq("PerformanceTimeline.enable", opts);
    },
  };

  /**
   * Security
   */
  Security = {
    /**
     * Disables tracking security state changes.
     */

    disable: async (): Promise<void> => {
      return await this.#sendReq("Security.disable");
    },

    /**
     * Enables tracking security state changes.
     */

    enable: async (): Promise<void> => {
      return await this.#sendReq("Security.enable");
    },

    /**
     * Enable/disable whether all certificate errors should be ignored.
     */

    setIgnoreCertificateErrors: async (opts: {
      /**
       * If true, all certificate errors will be ignored.
       */
      ignore: boolean;
    }): Promise<void> => {
      return await this.#sendReq("Security.setIgnoreCertificateErrors", opts);
    },

    /**
     * @deprecated
     * Handles a certificate error that fired a certificateError event.
     */

    handleCertificateError: async (opts: {
      /**
       * The ID of the event.
       */
      eventId: number;
      /**
       * The action to take on the certificate error.
       */
      action: Security_CertificateErrorAction;
    }): Promise<void> => {
      return await this.#sendReq("Security.handleCertificateError", opts);
    },

    /**
     * @deprecated
     * Enable/disable overriding certificate errors. If enabled, all certificate error events need to
     * be handled by the DevTools client and should be answered with `handleCertificateError` commands.
     */

    setOverrideCertificateErrors: async (opts: {
      /**
       * If true, certificate errors will be overridden.
       */
      override: boolean;
    }): Promise<void> => {
      return await this.#sendReq("Security.setOverrideCertificateErrors", opts);
    },
  };

  /**
   * @experimental
   */
  ServiceWorker = {
    deliverPushMessage: async (
      opts: {
        origin: string;
        registrationId: ServiceWorker_RegistrationID;
        data: string;
      },
    ): Promise<void> => {
      return await this.#sendReq("ServiceWorker.deliverPushMessage", opts);
    },

    disable: async (): Promise<void> => {
      return await this.#sendReq("ServiceWorker.disable");
    },

    dispatchSyncEvent: async (
      opts: {
        origin: string;
        registrationId: ServiceWorker_RegistrationID;
        tag: string;
        lastChance: boolean;
      },
    ): Promise<void> => {
      return await this.#sendReq("ServiceWorker.dispatchSyncEvent", opts);
    },

    dispatchPeriodicSyncEvent: async (
      opts: {
        origin: string;
        registrationId: ServiceWorker_RegistrationID;
        tag: string;
      },
    ): Promise<void> => {
      return await this.#sendReq(
        "ServiceWorker.dispatchPeriodicSyncEvent",
        opts,
      );
    },

    enable: async (): Promise<void> => {
      return await this.#sendReq("ServiceWorker.enable");
    },

    inspectWorker: async (opts: { versionId: string }): Promise<void> => {
      return await this.#sendReq("ServiceWorker.inspectWorker", opts);
    },

    setForceUpdateOnPageLoad: async (
      opts: { forceUpdateOnPageLoad: boolean },
    ): Promise<void> => {
      return await this.#sendReq(
        "ServiceWorker.setForceUpdateOnPageLoad",
        opts,
      );
    },

    skipWaiting: async (opts: { scopeURL: string }): Promise<void> => {
      return await this.#sendReq("ServiceWorker.skipWaiting", opts);
    },

    startWorker: async (opts: { scopeURL: string }): Promise<void> => {
      return await this.#sendReq("ServiceWorker.startWorker", opts);
    },

    stopAllWorkers: async (): Promise<void> => {
      return await this.#sendReq("ServiceWorker.stopAllWorkers");
    },

    stopWorker: async (opts: { versionId: string }): Promise<void> => {
      return await this.#sendReq("ServiceWorker.stopWorker", opts);
    },

    unregister: async (opts: { scopeURL: string }): Promise<void> => {
      return await this.#sendReq("ServiceWorker.unregister", opts);
    },

    updateRegistration: async (opts: { scopeURL: string }): Promise<void> => {
      return await this.#sendReq("ServiceWorker.updateRegistration", opts);
    },
  };

  /**
   * @experimental
   */
  Storage = {
    /**
     * Returns a storage key given a frame id.
     */

    getStorageKeyForFrame: async (
      opts: { frameId: Page_FrameId },
    ): Promise<{ storageKey: Storage_SerializedStorageKey }> => {
      return await this.#sendReq("Storage.getStorageKeyForFrame", opts);
    },

    /**
     * Clears storage for origin.
     */

    clearDataForOrigin: async (opts: {
      /**
       * Security origin.
       */
      origin: string;
      /**
       * Comma separated list of StorageType to clear.
       */
      storageTypes: string;
    }): Promise<void> => {
      return await this.#sendReq("Storage.clearDataForOrigin", opts);
    },

    /**
     * Clears storage for storage key.
     */

    clearDataForStorageKey: async (opts: {
      /**
       * Storage key.
       */
      storageKey: string;
      /**
       * Comma separated list of StorageType to clear.
       */
      storageTypes: string;
    }): Promise<void> => {
      return await this.#sendReq("Storage.clearDataForStorageKey", opts);
    },

    /**
     * Returns all browser cookies.
     */

    getCookies: async (opts: {
      /**
       * Browser context to use when called on the browser endpoint.
       */
      browserContextId?: Browser_BrowserContextID;
    }): Promise<{
      /**
       * Array of cookie objects.
       */
      cookies: Network_Cookie[];
    }> => {
      return await this.#sendReq("Storage.getCookies", opts);
    },

    /**
     * Sets given cookies.
     */

    setCookies: async (opts: {
      /**
       * Cookies to be set.
       */
      cookies: Network_CookieParam[];
      /**
       * Browser context to use when called on the browser endpoint.
       */
      browserContextId?: Browser_BrowserContextID;
    }): Promise<void> => {
      return await this.#sendReq("Storage.setCookies", opts);
    },

    /**
     * Clears cookies.
     */

    clearCookies: async (opts: {
      /**
       * Browser context to use when called on the browser endpoint.
       */
      browserContextId?: Browser_BrowserContextID;
    }): Promise<void> => {
      return await this.#sendReq("Storage.clearCookies", opts);
    },

    /**
     * Returns usage and quota in bytes.
     */

    getUsageAndQuota: async (opts: {
      /**
       * Security origin.
       */
      origin: string;
    }): Promise<{
      /**
       * Storage usage (bytes).
       */
      usage: number;
      /**
       * Storage quota (bytes).
       */
      quota: number;
      /**
       * Whether or not the origin has an active storage quota override
       */
      overrideActive: boolean;
      /**
       * Storage usage per type (bytes).
       */
      usageBreakdown: Storage_UsageForType[];
    }> => {
      return await this.#sendReq("Storage.getUsageAndQuota", opts);
    },

    /**
     * @experimental
     * Override quota for the specified origin
     */

    overrideQuotaForOrigin: async (opts: {
      /**
       * Security origin.
       */
      origin: string;
      /**
       * The quota size (in bytes) to override the original quota with.
       * If this is called multiple times, the overridden quota will be equal to
       * the quotaSize provided in the final call. If this is called without
       * specifying a quotaSize, the quota will be reset to the default value for
       * the specified origin. If this is called multiple times with different
       * origins, the override will be maintained for each origin until it is
       * disabled (called without a quotaSize).
       */
      quotaSize?: number;
    }): Promise<void> => {
      return await this.#sendReq("Storage.overrideQuotaForOrigin", opts);
    },

    /**
     * Registers origin to be notified when an update occurs to its cache storage list.
     */

    trackCacheStorageForOrigin: async (opts: {
      /**
       * Security origin.
       */
      origin: string;
    }): Promise<void> => {
      return await this.#sendReq("Storage.trackCacheStorageForOrigin", opts);
    },

    /**
     * Registers storage key to be notified when an update occurs to its cache storage list.
     */

    trackCacheStorageForStorageKey: async (opts: {
      /**
       * Storage key.
       */
      storageKey: string;
    }): Promise<void> => {
      return await this.#sendReq(
        "Storage.trackCacheStorageForStorageKey",
        opts,
      );
    },

    /**
     * Registers origin to be notified when an update occurs to its IndexedDB.
     */

    trackIndexedDBForOrigin: async (opts: {
      /**
       * Security origin.
       */
      origin: string;
    }): Promise<void> => {
      return await this.#sendReq("Storage.trackIndexedDBForOrigin", opts);
    },

    /**
     * Registers storage key to be notified when an update occurs to its IndexedDB.
     */

    trackIndexedDBForStorageKey: async (opts: {
      /**
       * Storage key.
       */
      storageKey: string;
    }): Promise<void> => {
      return await this.#sendReq("Storage.trackIndexedDBForStorageKey", opts);
    },

    /**
     * Unregisters origin from receiving notifications for cache storage.
     */

    untrackCacheStorageForOrigin: async (opts: {
      /**
       * Security origin.
       */
      origin: string;
    }): Promise<void> => {
      return await this.#sendReq("Storage.untrackCacheStorageForOrigin", opts);
    },

    /**
     * Unregisters storage key from receiving notifications for cache storage.
     */

    untrackCacheStorageForStorageKey: async (opts: {
      /**
       * Storage key.
       */
      storageKey: string;
    }): Promise<void> => {
      return await this.#sendReq(
        "Storage.untrackCacheStorageForStorageKey",
        opts,
      );
    },

    /**
     * Unregisters origin from receiving notifications for IndexedDB.
     */

    untrackIndexedDBForOrigin: async (opts: {
      /**
       * Security origin.
       */
      origin: string;
    }): Promise<void> => {
      return await this.#sendReq("Storage.untrackIndexedDBForOrigin", opts);
    },

    /**
     * Unregisters storage key from receiving notifications for IndexedDB.
     */

    untrackIndexedDBForStorageKey: async (opts: {
      /**
       * Storage key.
       */
      storageKey: string;
    }): Promise<void> => {
      return await this.#sendReq("Storage.untrackIndexedDBForStorageKey", opts);
    },

    /**
     * @experimental
     * Returns the number of stored Trust Tokens per issuer for the
     * current browsing context.
     */

    getTrustTokens: async (): Promise<{ tokens: Storage_TrustTokens[] }> => {
      return await this.#sendReq("Storage.getTrustTokens");
    },

    /**
     * @experimental
     * Removes all Trust Tokens issued by the provided issuerOrigin.
     * Leaves other stored data, including the issuer's Redemption Records, intact.
     */

    clearTrustTokens: async (opts: { issuerOrigin: string }): Promise<{
      /**
       * True if any tokens were deleted, false otherwise.
       */
      didDeleteTokens: boolean;
    }> => {
      return await this.#sendReq("Storage.clearTrustTokens", opts);
    },

    /**
     * @experimental
     * Gets details for a named interest group.
     */

    getInterestGroupDetails: async (
      opts: { ownerOrigin: string; name: string },
    ): Promise<{
      /**
       * This largely corresponds to:
       * https://wicg.github.io/turtledove/#dictdef-generatebidinterestgroup
       * but has absolute expirationTime instead of relative lifetimeMs and
       * also adds joiningOrigin.
       */
      details: object;
    }> => {
      return await this.#sendReq("Storage.getInterestGroupDetails", opts);
    },

    /**
     * @experimental
     * Enables/Disables issuing of interestGroupAccessed events.
     */

    setInterestGroupTracking: async (
      opts: { enable: boolean },
    ): Promise<void> => {
      return await this.#sendReq("Storage.setInterestGroupTracking", opts);
    },

    /**
     * @experimental
     * Enables/Disables issuing of interestGroupAuctionEventOccurred and
     * interestGroupAuctionNetworkRequestCreated.
     */

    setInterestGroupAuctionTracking: async (
      opts: { enable: boolean },
    ): Promise<void> => {
      return await this.#sendReq(
        "Storage.setInterestGroupAuctionTracking",
        opts,
      );
    },

    /**
     * @experimental
     * Gets metadata for an origin's shared storage.
     */

    getSharedStorageMetadata: async (
      opts: { ownerOrigin: string },
    ): Promise<{ metadata: Storage_SharedStorageMetadata }> => {
      return await this.#sendReq("Storage.getSharedStorageMetadata", opts);
    },

    /**
     * @experimental
     * Gets the entries in an given origin's shared storage.
     */

    getSharedStorageEntries: async (
      opts: { ownerOrigin: string },
    ): Promise<{ entries: Storage_SharedStorageEntry[] }> => {
      return await this.#sendReq("Storage.getSharedStorageEntries", opts);
    },

    /**
     * @experimental
     * Sets entry with `key` and `value` for a given origin's shared storage.
     */

    setSharedStorageEntry: async (
      opts: {
        ownerOrigin: string;
        key: string;
        value: string;
        /**
         * If `ignoreIfPresent` is included and true, then only sets the entry if
         * `key` doesn't already exist.
         */
        ignoreIfPresent?: boolean;
      },
    ): Promise<void> => {
      return await this.#sendReq("Storage.setSharedStorageEntry", opts);
    },

    /**
     * @experimental
     * Deletes entry for `key` (if it exists) for a given origin's shared storage.
     */

    deleteSharedStorageEntry: async (
      opts: { ownerOrigin: string; key: string },
    ): Promise<void> => {
      return await this.#sendReq("Storage.deleteSharedStorageEntry", opts);
    },

    /**
     * @experimental
     * Clears all entries for a given origin's shared storage.
     */

    clearSharedStorageEntries: async (
      opts: { ownerOrigin: string },
    ): Promise<void> => {
      return await this.#sendReq("Storage.clearSharedStorageEntries", opts);
    },

    /**
     * @experimental
     * Resets the budget for `ownerOrigin` by clearing all budget withdrawals.
     */

    resetSharedStorageBudget: async (
      opts: { ownerOrigin: string },
    ): Promise<void> => {
      return await this.#sendReq("Storage.resetSharedStorageBudget", opts);
    },

    /**
     * @experimental
     * Enables/disables issuing of sharedStorageAccessed events.
     */

    setSharedStorageTracking: async (
      opts: { enable: boolean },
    ): Promise<void> => {
      return await this.#sendReq("Storage.setSharedStorageTracking", opts);
    },

    /**
     * @experimental
     * Set tracking for a storage key's buckets.
     */

    setStorageBucketTracking: async (
      opts: { storageKey: string; enable: boolean },
    ): Promise<void> => {
      return await this.#sendReq("Storage.setStorageBucketTracking", opts);
    },

    /**
     * @experimental
     * Deletes the Storage Bucket with the given storage key and bucket name.
     */

    deleteStorageBucket: async (
      opts: { bucket: Storage_StorageBucket },
    ): Promise<void> => {
      return await this.#sendReq("Storage.deleteStorageBucket", opts);
    },

    /**
     * @experimental
     * Deletes state for sites identified as potential bounce trackers, immediately.
     */

    runBounceTrackingMitigations: async (): Promise<
      { deletedSites: string[] }
    > => {
      return await this.#sendReq("Storage.runBounceTrackingMitigations");
    },

    /**
     * @experimental
     * https://wicg.github.io/attribution-reporting-api/
     */

    setAttributionReportingLocalTestingMode: async (opts: {
      /**
       * If enabled, noise is suppressed and reports are sent immediately.
       */
      enabled: boolean;
    }): Promise<void> => {
      return await this.#sendReq(
        "Storage.setAttributionReportingLocalTestingMode",
        opts,
      );
    },

    /**
     * @experimental
     * Enables/disables issuing of Attribution Reporting events.
     */

    setAttributionReportingTracking: async (
      opts: { enable: boolean },
    ): Promise<void> => {
      return await this.#sendReq(
        "Storage.setAttributionReportingTracking",
        opts,
      );
    },

    /**
     * @experimental
     * Sends all pending Attribution Reports immediately, regardless of their
     * scheduled report time.
     */

    sendPendingAttributionReports: async (): Promise<{
      /**
       * The number of reports that were sent.
       */
      numSent: number;
    }> => {
      return await this.#sendReq("Storage.sendPendingAttributionReports");
    },

    /**
     * @experimental
     * Returns the effective Related Website Sets in use by this profile for the browser
     * session. The effective Related Website Sets will not change during a browser session.
     */

    getRelatedWebsiteSets: async (): Promise<
      { sets: Storage_RelatedWebsiteSet[] }
    > => {
      return await this.#sendReq("Storage.getRelatedWebsiteSets");
    },
  };

  /**
   * @experimental
   * The SystemInfo domain defines methods and events for querying low-level system information.
   */
  SystemInfo = {
    /**
     * Returns information about the system.
     */

    getInfo: async (): Promise<{
      /**
       * Information about the GPUs on the system.
       */
      gpu: SystemInfo_GPUInfo;
      /**
       * A platform-dependent description of the model of the machine. On Mac OS, this is, for
       * example, 'MacBookPro'. Will be the empty string if not supported.
       */
      modelName: string;
      /**
       * A platform-dependent description of the version of the machine. On Mac OS, this is, for
       * example, '10.1'. Will be the empty string if not supported.
       */
      modelVersion: string;
      /**
       * The command line string used to launch the browser. Will be the empty string if not
       * supported.
       */
      commandLine: string;
    }> => {
      return await this.#sendReq("SystemInfo.getInfo");
    },

    /**
     * Returns information about the feature state.
     */

    getFeatureState: async (
      opts: { featureState: string },
    ): Promise<{ featureEnabled: boolean }> => {
      return await this.#sendReq("SystemInfo.getFeatureState", opts);
    },

    /**
     * Returns information about all running processes.
     */

    getProcessInfo: async (): Promise<{
      /**
       * An array of process info blocks.
       */
      processInfo: SystemInfo_ProcessInfo[];
    }> => {
      return await this.#sendReq("SystemInfo.getProcessInfo");
    },
  };

  /**
   * Supports additional targets discovery and allows to attach to them.
   */
  Target = {
    /**
     * Activates (focuses) the target.
     */

    activateTarget: async (
      opts: { targetId: Target_TargetID },
    ): Promise<void> => {
      return await this.#sendReq("Target.activateTarget", opts);
    },

    /**
     * Attaches to the target with given id.
     */

    attachToTarget: async (opts: {
      targetId: Target_TargetID;
      /**
       * Enables "flat" access to the session via specifying sessionId attribute in the commands.
       * We plan to make this the default, deprecate non-flattened mode,
       * and eventually retire it. See crbug.com/991325.
       */
      flatten?: boolean;
    }): Promise<{
      /**
       * Id assigned to the session.
       */
      sessionId: Target_SessionID;
    }> => {
      return await this.#sendReq("Target.attachToTarget", opts);
    },

    /**
     * @experimental
     * Attaches to the browser target, only uses flat sessionId mode.
     */

    attachToBrowserTarget: async (): Promise<{
      /**
       * Id assigned to the session.
       */
      sessionId: Target_SessionID;
    }> => {
      return await this.#sendReq("Target.attachToBrowserTarget");
    },

    /**
     * Closes the target. If the target is a page that gets closed too.
     */

    closeTarget: async (opts: { targetId: Target_TargetID }): Promise<{
      /**
       * @deprecated
       * Always set to true. If an error occurs, the response indicates protocol error.
       */
      success: boolean;
    }> => {
      return await this.#sendReq("Target.closeTarget", opts);
    },

    /**
     * @experimental
     * Inject object to the target's main frame that provides a communication
     * channel with browser target.
     *
     * Injected object will be available as `window[bindingName]`.
     *
     * The object has the following API:
     * - `binding.send(json)` - a method to send messages over the remote debugging protocol
     * - `binding.onmessage = json => handleMessage(json)` - a callback that will be called for the protocol notifications and command responses.
     */

    exposeDevToolsProtocol: async (opts: {
      targetId: Target_TargetID;
      /**
       * Binding name, 'cdp' if not specified.
       */
      bindingName?: string;
    }): Promise<void> => {
      return await this.#sendReq("Target.exposeDevToolsProtocol", opts);
    },

    /**
     * Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
     * one.
     */

    createBrowserContext: async (opts: {
      /**
       * @experimental
       * If specified, disposes this context when debugging session disconnects.
       */
      disposeOnDetach?: boolean;
      /**
       * @experimental
       * Proxy server, similar to the one passed to --proxy-server
       */
      proxyServer?: string;
      /**
       * @experimental
       * Proxy bypass list, similar to the one passed to --proxy-bypass-list
       */
      proxyBypassList?: string;
      /**
       * @experimental
       * An optional list of origins to grant unlimited cross-origin access to.
       * Parts of the URL other than those constituting origin are ignored.
       */
      originsWithUniversalNetworkAccess?: string[];
    }): Promise<{
      /**
       * The id of the context created.
       */
      browserContextId: Browser_BrowserContextID;
    }> => {
      return await this.#sendReq("Target.createBrowserContext", opts);
    },

    /**
     * Returns all browser contexts created with `Target.createBrowserContext` method.
     */

    getBrowserContexts: async (): Promise<{
      /**
       * An array of browser context ids.
       */
      browserContextIds: Browser_BrowserContextID[];
    }> => {
      return await this.#sendReq("Target.getBrowserContexts");
    },

    /**
     * Creates a new page.
     */

    createTarget: async (opts: {
      /**
       * The initial URL the page will be navigated to. An empty string indicates about:blank.
       */
      url: string;
      /**
       * Frame width in DIP (headless chrome only).
       */
      width?: number;
      /**
       * Frame height in DIP (headless chrome only).
       */
      height?: number;
      /**
       * @experimental
       * The browser context to create the page in.
       */
      browserContextId?: Browser_BrowserContextID;
      /**
       * @experimental
       * Whether BeginFrames for this target will be controlled via DevTools (headless chrome only,
       * not supported on MacOS yet, false by default).
       */
      enableBeginFrameControl?: boolean;
      /**
       * Whether to create a new Window or Tab (chrome-only, false by default).
       */
      newWindow?: boolean;
      /**
       * Whether to create the target in background or foreground (chrome-only,
       * false by default).
       */
      background?: boolean;
      /**
       * @experimental
       * Whether to create the target of type "tab".
       */
      forTab?: boolean;
    }): Promise<{
      /**
       * The id of the page opened.
       */
      targetId: Target_TargetID;
    }> => {
      return await this.#sendReq("Target.createTarget", opts);
    },

    /**
     * Detaches session with given id.
     */

    detachFromTarget: async (opts: {
      /**
       * Session to detach.
       */
      sessionId?: Target_SessionID;
      /**
       * @deprecated
       * Deprecated.
       */
      targetId?: Target_TargetID;
    }): Promise<void> => {
      return await this.#sendReq("Target.detachFromTarget", opts);
    },

    /**
     * Deletes a BrowserContext. All the belonging pages will be closed without calling their
     * beforeunload hooks.
     */

    disposeBrowserContext: async (
      opts: { browserContextId: Browser_BrowserContextID },
    ): Promise<void> => {
      return await this.#sendReq("Target.disposeBrowserContext", opts);
    },

    /**
     * @experimental
     * Returns information about a target.
     */

    getTargetInfo: async (
      opts: { targetId?: Target_TargetID },
    ): Promise<{ targetInfo: Target_TargetInfo }> => {
      return await this.#sendReq("Target.getTargetInfo", opts);
    },

    /**
     * Retrieves a list of available targets.
     */

    getTargets: async (opts: {
      /**
       * @experimental
       * Only targets matching filter will be reported. If filter is not specified
       * and target discovery is currently enabled, a filter used for target discovery
       * is used for consistency.
       */
      filter?: Target_TargetFilter;
    }): Promise<{
      /**
       * The list of targets.
       */
      targetInfos: Target_TargetInfo[];
    }> => {
      return await this.#sendReq("Target.getTargets", opts);
    },

    /**
     * @deprecated
     * Sends protocol message over session with given id.
     * Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
     * and crbug.com/991325.
     */

    sendMessageToTarget: async (opts: {
      message: string;
      /**
       * Identifier of the session.
       */
      sessionId?: Target_SessionID;
      /**
       * @deprecated
       * Deprecated.
       */
      targetId?: Target_TargetID;
    }): Promise<void> => {
      return await this.#sendReq("Target.sendMessageToTarget", opts);
    },

    /**
     * Controls whether to automatically attach to new targets which are considered to be related to
     * this one. When turned on, attaches to all existing related targets as well. When turned off,
     * automatically detaches from all currently attached targets.
     * This also clears all targets added by `autoAttachRelated` from the list of targets to watch
     * for creation of related targets.
     */

    setAutoAttach: async (opts: {
      /**
       * Whether to auto-attach to related targets.
       */
      autoAttach: boolean;
      /**
       * Whether to pause new targets when attaching to them. Use `Runtime.runIfWaitingForDebugger`
       * to run paused targets.
       */
      waitForDebuggerOnStart: boolean;
      /**
       * @experimental
       * Enables "flat" access to the session via specifying sessionId attribute in the commands.
       * We plan to make this the default, deprecate non-flattened mode,
       * and eventually retire it. See crbug.com/991325.
       */
      flatten?: boolean;
      /**
       * @experimental
       * Only targets matching filter will be attached.
       */
      filter?: Target_TargetFilter;
    }): Promise<void> => {
      return await this.#sendReq("Target.setAutoAttach", opts);
    },

    /**
     * @experimental
     * Adds the specified target to the list of targets that will be monitored for any related target
     * creation (such as child frames, child workers and new versions of service worker) and reported
     * through `attachedToTarget`. The specified target is also auto-attached.
     * This cancels the effect of any previous `setAutoAttach` and is also cancelled by subsequent
     * `setAutoAttach`. Only available at the Browser target.
     */

    autoAttachRelated: async (opts: {
      targetId: Target_TargetID;
      /**
       * Whether to pause new targets when attaching to them. Use `Runtime.runIfWaitingForDebugger`
       * to run paused targets.
       */
      waitForDebuggerOnStart: boolean;
      /**
       * @experimental
       * Only targets matching filter will be attached.
       */
      filter?: Target_TargetFilter;
    }): Promise<void> => {
      return await this.#sendReq("Target.autoAttachRelated", opts);
    },

    /**
     * Controls whether to discover available targets and notify via
     * `targetCreated/targetInfoChanged/targetDestroyed` events.
     */

    setDiscoverTargets: async (opts: {
      /**
       * Whether to discover available targets.
       */
      discover: boolean;
      /**
       * @experimental
       * Only targets matching filter will be attached. If `discover` is false,
       * `filter` must be omitted or empty.
       */
      filter?: Target_TargetFilter;
    }): Promise<void> => {
      return await this.#sendReq("Target.setDiscoverTargets", opts);
    },

    /**
     * @experimental
     * Enables target discovery for the specified locations, when `setDiscoverTargets` was set to
     * `true`.
     */

    setRemoteLocations: async (opts: {
      /**
       * List of remote locations.
       */
      locations: Target_RemoteLocation[];
    }): Promise<void> => {
      return await this.#sendReq("Target.setRemoteLocations", opts);
    },
  };

  /**
   * @experimental
   * The Tethering domain defines methods and events for browser port binding.
   */
  Tethering = {
    /**
     * Request browser port binding.
     */

    bind: async (opts: {
      /**
       * Port number to bind.
       */
      port: number;
    }): Promise<void> => {
      return await this.#sendReq("Tethering.bind", opts);
    },

    /**
     * Request browser port unbinding.
     */

    unbind: async (opts: {
      /**
       * Port number to unbind.
       */
      port: number;
    }): Promise<void> => {
      return await this.#sendReq("Tethering.unbind", opts);
    },
  };

  Tracing = {
    /**
     * Stop trace events collection.
     */

    end: async (): Promise<void> => {
      return await this.#sendReq("Tracing.end");
    },

    /**
     * @experimental
     * Gets supported tracing categories.
     */

    getCategories: async (): Promise<{
      /**
       * A list of supported tracing categories.
       */
      categories: string[];
    }> => {
      return await this.#sendReq("Tracing.getCategories");
    },

    /**
     * @experimental
     * Record a clock sync marker in the trace.
     */

    recordClockSyncMarker: async (opts: {
      /**
       * The ID of this clock sync marker
       */
      syncId: string;
    }): Promise<void> => {
      return await this.#sendReq("Tracing.recordClockSyncMarker", opts);
    },

    /**
     * @experimental
     * Request a global memory dump.
     */

    requestMemoryDump: async (opts: {
      /**
       * Enables more deterministic results by forcing garbage collection
       */
      deterministic?: boolean;
      /**
       * Specifies level of details in memory dump. Defaults to "detailed".
       */
      levelOfDetail?: Tracing_MemoryDumpLevelOfDetail;
    }): Promise<{
      /**
       * GUID of the resulting global memory dump.
       */
      dumpGuid: string;
      /**
       * True iff the global memory dump succeeded.
       */
      success: boolean;
    }> => {
      return await this.#sendReq("Tracing.requestMemoryDump", opts);
    },

    /**
     * Start trace events collection.
     */

    start: async (opts: {
      /**
       * @experimental
       * @deprecated
       * Category/tag filter
       */
      categories?: string;
      /**
       * @experimental
       * @deprecated
       * Tracing options
       */
      options?: string;
      /**
       * @experimental
       * If set, the agent will issue bufferUsage events at this interval, specified in milliseconds
       */
      bufferUsageReportingInterval?: number;
      /**
       * Whether to report trace events as series of dataCollected events or to save trace to a
       * stream (defaults to `ReportEvents`).
       */
      transferMode?: "ReportEvents" | "ReturnAsStream";
      /**
       * Trace data format to use. This only applies when using `ReturnAsStream`
       * transfer mode (defaults to `json`).
       */
      streamFormat?: Tracing_StreamFormat;
      /**
       * @experimental
       * Compression format to use. This only applies when using `ReturnAsStream`
       * transfer mode (defaults to `none`)
       */
      streamCompression?: Tracing_StreamCompression;
      traceConfig?: Tracing_TraceConfig;
      /**
       * @experimental
       * Base64-encoded serialized perfetto.protos.TraceConfig protobuf message
       * When specified, the parameters `categories`, `options`, `traceConfig`
       * are ignored.
       */
      perfettoConfig?: string;
      /**
       * @experimental
       * Backend type (defaults to `auto`)
       */
      tracingBackend?: Tracing_TracingBackend;
    }): Promise<void> => {
      return await this.#sendReq("Tracing.start", opts);
    },
  };

  /**
   * A domain for letting clients substitute browser's network layer with client code.
   */
  Fetch = {
    /**
     * Disables the fetch domain.
     */

    disable: async (): Promise<void> => {
      return await this.#sendReq("Fetch.disable");
    },

    /**
     * Enables issuing of requestPaused events. A request will be paused until client
     * calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.
     */

    enable: async (opts: {
      /**
       * If specified, only requests matching any of these patterns will produce
       * fetchRequested event and will be paused until clients response. If not set,
       * all requests will be affected.
       */
      patterns?: Fetch_RequestPattern[];
      /**
       * If true, authRequired events will be issued and requests will be paused
       * expecting a call to continueWithAuth.
       */
      handleAuthRequests?: boolean;
    }): Promise<void> => {
      return await this.#sendReq("Fetch.enable", opts);
    },

    /**
     * Causes the request to fail with specified reason.
     */

    failRequest: async (opts: {
      /**
       * An id the client received in requestPaused event.
       */
      requestId: Fetch_RequestId;
      /**
       * Causes the request to fail with the given reason.
       */
      errorReason: Network_ErrorReason;
    }): Promise<void> => {
      return await this.#sendReq("Fetch.failRequest", opts);
    },

    /**
     * Provides response to the request.
     */

    fulfillRequest: async (opts: {
      /**
       * An id the client received in requestPaused event.
       */
      requestId: Fetch_RequestId;
      /**
       * An HTTP response code.
       */
      responseCode: number;
      /**
       * Response headers.
       */
      responseHeaders?: Fetch_HeaderEntry[];
      /**
       * Alternative way of specifying response headers as a \0-separated
       * series of name: value pairs. Prefer the above method unless you
       * need to represent some non-UTF8 values that can't be transmitted
       * over the protocol as text.
       */
      binaryResponseHeaders?: string;
      /**
       * A response body. If absent, original response body will be used if
       * the request is intercepted at the response stage and empty body
       * will be used if the request is intercepted at the request stage.
       */
      body?: string;
      /**
       * A textual representation of responseCode.
       * If absent, a standard phrase matching responseCode is used.
       */
      responsePhrase?: string;
    }): Promise<void> => {
      return await this.#sendReq("Fetch.fulfillRequest", opts);
    },

    /**
     * Continues the request, optionally modifying some of its parameters.
     */

    continueRequest: async (opts: {
      /**
       * An id the client received in requestPaused event.
       */
      requestId: Fetch_RequestId;
      /**
       * If set, the request url will be modified in a way that's not observable by page.
       */
      url?: string;
      /**
       * If set, the request method is overridden.
       */
      method?: string;
      /**
       * If set, overrides the post data in the request.
       */
      postData?: string;
      /**
       * If set, overrides the request headers. Note that the overrides do not
       * extend to subsequent redirect hops, if a redirect happens. Another override
       * may be applied to a different request produced by a redirect.
       */
      headers?: Fetch_HeaderEntry[];
      /**
       * @experimental
       * If set, overrides response interception behavior for this request.
       */
      interceptResponse?: boolean;
    }): Promise<void> => {
      return await this.#sendReq("Fetch.continueRequest", opts);
    },

    /**
     * Continues a request supplying authChallengeResponse following authRequired event.
     */

    continueWithAuth: async (opts: {
      /**
       * An id the client received in authRequired event.
       */
      requestId: Fetch_RequestId;
      /**
       * Response to  with an authChallenge.
       */
      authChallengeResponse: Fetch_AuthChallengeResponse;
    }): Promise<void> => {
      return await this.#sendReq("Fetch.continueWithAuth", opts);
    },

    /**
     * @experimental
     * Continues loading of the paused response, optionally modifying the
     * response headers. If either responseCode or headers are modified, all of them
     * must be present.
     */

    continueResponse: async (opts: {
      /**
       * An id the client received in requestPaused event.
       */
      requestId: Fetch_RequestId;
      /**
       * An HTTP response code. If absent, original response code will be used.
       */
      responseCode?: number;
      /**
       * A textual representation of responseCode.
       * If absent, a standard phrase matching responseCode is used.
       */
      responsePhrase?: string;
      /**
       * Response headers. If absent, original response headers will be used.
       */
      responseHeaders?: Fetch_HeaderEntry[];
      /**
       * Alternative way of specifying response headers as a \0-separated
       * series of name: value pairs. Prefer the above method unless you
       * need to represent some non-UTF8 values that can't be transmitted
       * over the protocol as text.
       */
      binaryResponseHeaders?: string;
    }): Promise<void> => {
      return await this.#sendReq("Fetch.continueResponse", opts);
    },

    /**
     * Causes the body of the response to be received from the server and
     * returned as a single string. May only be issued for a request that
     * is paused in the Response stage and is mutually exclusive with
     * takeResponseBodyForInterceptionAsStream. Calling other methods that
     * affect the request or disabling fetch domain before body is received
     * results in an undefined behavior.
     * Note that the response body is not available for redirects. Requests
     * paused in the _redirect received_ state may be differentiated by
     * `responseCode` and presence of `location` response header, see
     * comments to `requestPaused` for details.
     */

    getResponseBody: async (opts: {
      /**
       * Identifier for the intercepted request to get body for.
       */
      requestId: Fetch_RequestId;
    }): Promise<{
      /**
       * Response body.
       */
      body: string;
      /**
       * True, if content was sent as base64.
       */
      base64Encoded: boolean;
    }> => {
      return await this.#sendReq("Fetch.getResponseBody", opts);
    },

    /**
     * Returns a handle to the stream representing the response body.
     * The request must be paused in the HeadersReceived stage.
     * Note that after this command the request can't be continued
     * as is -- client either needs to cancel it or to provide the
     * response body.
     * The stream only supports sequential read, IO.read will fail if the position
     * is specified.
     * This method is mutually exclusive with getResponseBody.
     * Calling other methods that affect the request or disabling fetch
     * domain before body is received results in an undefined behavior.
     */

    takeResponseBodyAsStream: async (
      opts: { requestId: Fetch_RequestId },
    ): Promise<{ stream: IO_StreamHandle }> => {
      return await this.#sendReq("Fetch.takeResponseBodyAsStream", opts);
    },
  };

  /**
   * @experimental
   * This domain allows inspection of Web Audio API.
   * https://webaudio.github.io/web-audio-api/
   */
  WebAudio = {
    /**
     * Enables the WebAudio domain and starts sending context lifetime events.
     */

    enable: async (): Promise<void> => {
      return await this.#sendReq("WebAudio.enable");
    },

    /**
     * Disables the WebAudio domain.
     */

    disable: async (): Promise<void> => {
      return await this.#sendReq("WebAudio.disable");
    },

    /**
     * Fetch the realtime data from the registered contexts.
     */

    getRealtimeData: async (
      opts: { contextId: WebAudio_GraphObjectId },
    ): Promise<{ realtimeData: WebAudio_ContextRealtimeData }> => {
      return await this.#sendReq("WebAudio.getRealtimeData", opts);
    },
  };

  /**
   * @experimental
   * This domain allows configuring virtual authenticators to test the WebAuthn
   * API.
   */
  WebAuthn = {
    /**
     * Enable the WebAuthn domain and start intercepting credential storage and
     * retrieval with a virtual authenticator.
     */

    enable: async (opts: {
      /**
       * Whether to enable the WebAuthn user interface. Enabling the UI is
       * recommended for debugging and demo purposes, as it is closer to the real
       * experience. Disabling the UI is recommended for automated testing.
       * Supported at the embedder's discretion if UI is available.
       * Defaults to false.
       */
      enableUI?: boolean;
    }): Promise<void> => {
      return await this.#sendReq("WebAuthn.enable", opts);
    },

    /**
     * Disable the WebAuthn domain.
     */

    disable: async (): Promise<void> => {
      return await this.#sendReq("WebAuthn.disable");
    },

    /**
     * Creates and adds a virtual authenticator.
     */

    addVirtualAuthenticator: async (
      opts: { options: WebAuthn_VirtualAuthenticatorOptions },
    ): Promise<{ authenticatorId: WebAuthn_AuthenticatorId }> => {
      return await this.#sendReq("WebAuthn.addVirtualAuthenticator", opts);
    },

    /**
     * Resets parameters isBogusSignature, isBadUV, isBadUP to false if they are not present.
     */

    setResponseOverrideBits: async (
      opts: {
        authenticatorId: WebAuthn_AuthenticatorId;
        /**
         * If isBogusSignature is set, overrides the signature in the authenticator response to be zero.
         * Defaults to false.
         */
        isBogusSignature?: boolean;
        /**
         * If isBadUV is set, overrides the UV bit in the flags in the authenticator response to
         * be zero. Defaults to false.
         */
        isBadUV?: boolean;
        /**
         * If isBadUP is set, overrides the UP bit in the flags in the authenticator response to
         * be zero. Defaults to false.
         */
        isBadUP?: boolean;
      },
    ): Promise<void> => {
      return await this.#sendReq("WebAuthn.setResponseOverrideBits", opts);
    },

    /**
     * Removes the given authenticator.
     */

    removeVirtualAuthenticator: async (
      opts: { authenticatorId: WebAuthn_AuthenticatorId },
    ): Promise<void> => {
      return await this.#sendReq("WebAuthn.removeVirtualAuthenticator", opts);
    },

    /**
     * Adds the credential to the specified authenticator.
     */

    addCredential: async (
      opts: {
        authenticatorId: WebAuthn_AuthenticatorId;
        credential: WebAuthn_Credential;
      },
    ): Promise<void> => {
      return await this.#sendReq("WebAuthn.addCredential", opts);
    },

    /**
     * Returns a single credential stored in the given virtual authenticator that
     * matches the credential ID.
     */

    getCredential: async (
      opts: { authenticatorId: WebAuthn_AuthenticatorId; credentialId: string },
    ): Promise<{ credential: WebAuthn_Credential }> => {
      return await this.#sendReq("WebAuthn.getCredential", opts);
    },

    /**
     * Returns all the credentials stored in the given virtual authenticator.
     */

    getCredentials: async (
      opts: { authenticatorId: WebAuthn_AuthenticatorId },
    ): Promise<{ credentials: WebAuthn_Credential[] }> => {
      return await this.#sendReq("WebAuthn.getCredentials", opts);
    },

    /**
     * Removes a credential from the authenticator.
     */

    removeCredential: async (
      opts: { authenticatorId: WebAuthn_AuthenticatorId; credentialId: string },
    ): Promise<void> => {
      return await this.#sendReq("WebAuthn.removeCredential", opts);
    },

    /**
     * Clears all the credentials from the specified device.
     */

    clearCredentials: async (
      opts: { authenticatorId: WebAuthn_AuthenticatorId },
    ): Promise<void> => {
      return await this.#sendReq("WebAuthn.clearCredentials", opts);
    },

    /**
     * Sets whether User Verification succeeds or fails for an authenticator.
     * The default is true.
     */

    setUserVerified: async (
      opts: {
        authenticatorId: WebAuthn_AuthenticatorId;
        isUserVerified: boolean;
      },
    ): Promise<void> => {
      return await this.#sendReq("WebAuthn.setUserVerified", opts);
    },

    /**
     * Sets whether tests of user presence will succeed immediately (if true) or fail to resolve (if false) for an authenticator.
     * The default is true.
     */

    setAutomaticPresenceSimulation: async (
      opts: { authenticatorId: WebAuthn_AuthenticatorId; enabled: boolean },
    ): Promise<void> => {
      return await this.#sendReq(
        "WebAuthn.setAutomaticPresenceSimulation",
        opts,
      );
    },

    /**
     * Allows setting credential properties.
     * https://w3c.github.io/webauthn/#sctn-automation-set-credential-properties
     */

    setCredentialProperties: async (
      opts: {
        authenticatorId: WebAuthn_AuthenticatorId;
        credentialId: string;
        backupEligibility?: boolean;
        backupState?: boolean;
      },
    ): Promise<void> => {
      return await this.#sendReq("WebAuthn.setCredentialProperties", opts);
    },
  };

  /**
   * @experimental
   * This domain allows detailed inspection of media elements
   */
  Media = {
    /**
     * Enables the Media domain
     */

    enable: async (): Promise<void> => {
      return await this.#sendReq("Media.enable");
    },

    /**
     * Disables the Media domain.
     */

    disable: async (): Promise<void> => {
      return await this.#sendReq("Media.disable");
    },
  };

  /**
   * @experimental
   */
  DeviceAccess = {
    /**
     * Enable events in this domain.
     */

    enable: async (): Promise<void> => {
      return await this.#sendReq("DeviceAccess.enable");
    },

    /**
     * Disable events in this domain.
     */

    disable: async (): Promise<void> => {
      return await this.#sendReq("DeviceAccess.disable");
    },

    /**
     * Select a device in response to a DeviceAccess.deviceRequestPrompted event.
     */

    selectPrompt: async (
      opts: { id: DeviceAccess_RequestId; deviceId: DeviceAccess_DeviceId },
    ): Promise<void> => {
      return await this.#sendReq("DeviceAccess.selectPrompt", opts);
    },

    /**
     * Cancel a prompt in response to a DeviceAccess.deviceRequestPrompted event.
     */

    cancelPrompt: async (
      opts: { id: DeviceAccess_RequestId },
    ): Promise<void> => {
      return await this.#sendReq("DeviceAccess.cancelPrompt", opts);
    },
  };

  /**
   * @experimental
   */
  Preload = {
    enable: async (): Promise<void> => {
      return await this.#sendReq("Preload.enable");
    },

    disable: async (): Promise<void> => {
      return await this.#sendReq("Preload.disable");
    },
  };

  /**
   * @experimental
   * This domain allows interacting with the FedCM dialog.
   */
  FedCm = {
    enable: async (opts: {
      /**
       * Allows callers to disable the promise rejection delay that would
       * normally happen, if this is unimportant to what's being tested.
       * (step 4 of https://fedidcg.github.io/FedCM/#browser-api-rp-sign-in)
       */
      disableRejectionDelay?: boolean;
    }): Promise<void> => {
      return await this.#sendReq("FedCm.enable", opts);
    },

    disable: async (): Promise<void> => {
      return await this.#sendReq("FedCm.disable");
    },

    selectAccount: async (
      opts: { dialogId: string; accountIndex: number },
    ): Promise<void> => {
      return await this.#sendReq("FedCm.selectAccount", opts);
    },

    clickDialogButton: async (
      opts: { dialogId: string; dialogButton: FedCm_DialogButton },
    ): Promise<void> => {
      return await this.#sendReq("FedCm.clickDialogButton", opts);
    },

    openUrl: async (
      opts: {
        dialogId: string;
        accountIndex: number;
        accountUrlType: FedCm_AccountUrlType;
      },
    ): Promise<void> => {
      return await this.#sendReq("FedCm.openUrl", opts);
    },

    dismissDialog: async (
      opts: { dialogId: string; triggerCooldown?: boolean },
    ): Promise<void> => {
      return await this.#sendReq("FedCm.dismissDialog", opts);
    },

    /**
     * Resets the cooldown time, if any, to allow the next FedCM call to show
     * a dialog even if one was recently dismissed by the user.
     */

    resetCooldown: async (): Promise<void> => {
      return await this.#sendReq("FedCm.resetCooldown");
    },
  };

  /**
   * @experimental
   * This domain allows interacting with the browser to control PWAs.
   */
  PWA = {
    /**
     * Returns the following OS state for the given manifest id.
     */

    getOsAppState: async (opts: {
      /**
       * The id from the webapp's manifest file, commonly it's the url of the
       * site installing the webapp. See
       * https://web.dev/learn/pwa/web-app-manifest.
       */
      manifestId: string;
    }): Promise<{ badgeCount: number; fileHandlers: PWA_FileHandler[] }> => {
      return await this.#sendReq("PWA.getOsAppState", opts);
    },
  };

  /**
   * @deprecated
   * This domain is deprecated - use Runtime or Log instead.
   */
  Console = {
    /**
     * Does nothing.
     */

    clearMessages: async (): Promise<void> => {
      return await this.#sendReq("Console.clearMessages");
    },

    /**
     * Disables console domain, prevents further console messages from being reported to the client.
     */

    disable: async (): Promise<void> => {
      return await this.#sendReq("Console.disable");
    },

    /**
     * Enables console domain, sends the messages collected so far to the client by means of the
     * `messageAdded` notification.
     */

    enable: async (): Promise<void> => {
      return await this.#sendReq("Console.enable");
    },
  };

  /**
   * Debugger domain exposes JavaScript debugging capabilities. It allows setting and removing
   * breakpoints, stepping through execution, exploring stack traces, etc.
   */
  Debugger = {
    /**
     * Continues execution until specific location is reached.
     */

    continueToLocation: async (opts: {
      /**
       * Location to continue to.
       */
      location: Debugger_Location;
      targetCallFrames?: "any" | "current";
    }): Promise<void> => {
      return await this.#sendReq("Debugger.continueToLocation", opts);
    },

    /**
     * Disables debugger for given page.
     */

    disable: async (): Promise<void> => {
      return await this.#sendReq("Debugger.disable");
    },

    /**
     * Enables debugger for the given page. Clients should not assume that the debugging has been
     * enabled until the result for this command is received.
     */

    enable: async (opts: {
      /**
       * @experimental
       * The maximum size in bytes of collected scripts (not referenced by other heap objects)
       * the debugger can hold. Puts no limit if parameter is omitted.
       */
      maxScriptsCacheSize?: number;
    }): Promise<{
      /**
       * @experimental
       * Unique identifier of the debugger.
       */
      debuggerId: Runtime_UniqueDebuggerId;
    }> => {
      return await this.#sendReq("Debugger.enable", opts);
    },

    /**
     * Evaluates expression on a given call frame.
     */

    evaluateOnCallFrame: async (opts: {
      /**
       * Call frame identifier to evaluate on.
       */
      callFrameId: Debugger_CallFrameId;
      /**
       * Expression to evaluate.
       */
      expression: string;
      /**
       * String object group name to put result into (allows rapid releasing resulting object handles
       * using `releaseObjectGroup`).
       */
      objectGroup?: string;
      /**
       * Specifies whether command line API should be available to the evaluated expression, defaults
       * to false.
       */
      includeCommandLineAPI?: boolean;
      /**
       * In silent mode exceptions thrown during evaluation are not reported and do not pause
       * execution. Overrides `setPauseOnException` state.
       */
      silent?: boolean;
      /**
       * Whether the result is expected to be a JSON object that should be sent by value.
       */
      returnByValue?: boolean;
      /**
       * @experimental
       * Whether preview should be generated for the result.
       */
      generatePreview?: boolean;
      /**
       * Whether to throw an exception if side effect cannot be ruled out during evaluation.
       */
      throwOnSideEffect?: boolean;
      /**
       * @experimental
       * Terminate execution after timing out (number of milliseconds).
       */
      timeout?: Runtime_TimeDelta;
    }): Promise<{
      /**
       * Object wrapper for the evaluation result.
       */
      result: Runtime_RemoteObject;
      /**
       * Exception details.
       */
      exceptionDetails?: Runtime_ExceptionDetails;
    }> => {
      return await this.#sendReq("Debugger.evaluateOnCallFrame", opts);
    },

    /**
     * Returns possible locations for breakpoint. scriptId in start and end range locations should be
     * the same.
     */

    getPossibleBreakpoints: async (opts: {
      /**
       * Start of range to search possible breakpoint locations in.
       */
      start: Debugger_Location;
      /**
       * End of range to search possible breakpoint locations in (excluding). When not specified, end
       * of scripts is used as end of range.
       */
      end?: Debugger_Location;
      /**
       * Only consider locations which are in the same (non-nested) function as start.
       */
      restrictToFunction?: boolean;
    }): Promise<{
      /**
       * List of the possible breakpoint locations.
       */
      locations: Debugger_BreakLocation[];
    }> => {
      return await this.#sendReq("Debugger.getPossibleBreakpoints", opts);
    },

    /**
     * Returns source for the script with given id.
     */

    getScriptSource: async (opts: {
      /**
       * Id of the script to get source for.
       */
      scriptId: Runtime_ScriptId;
    }): Promise<{
      /**
       * Script source (empty in case of Wasm bytecode).
       */
      scriptSource: string;
      /**
       * Wasm bytecode.
       */
      bytecode?: string;
    }> => {
      return await this.#sendReq("Debugger.getScriptSource", opts);
    },

    /**
     * @experimental
     */

    disassembleWasmModule: async (opts: {
      /**
       * Id of the script to disassemble
       */
      scriptId: Runtime_ScriptId;
    }): Promise<{
      /**
       * For large modules, return a stream from which additional chunks of
       * disassembly can be read successively.
       */
      streamId?: string;
      /**
       * The total number of lines in the disassembly text.
       */
      totalNumberOfLines: number;
      /**
       * The offsets of all function bodies, in the format [start1, end1,
       * start2, end2, ...] where all ends are exclusive.
       */
      functionBodyOffsets: number[];
      /**
       * The first chunk of disassembly.
       */
      chunk: Debugger_WasmDisassemblyChunk;
    }> => {
      return await this.#sendReq("Debugger.disassembleWasmModule", opts);
    },

    /**
     * @experimental
     * Disassemble the next chunk of lines for the module corresponding to the
     * stream. If disassembly is complete, this API will invalidate the streamId
     * and return an empty chunk. Any subsequent calls for the now invalid stream
     * will return errors.
     */

    nextWasmDisassemblyChunk: async (opts: { streamId: string }): Promise<{
      /**
       * The next chunk of disassembly.
       */
      chunk: Debugger_WasmDisassemblyChunk;
    }> => {
      return await this.#sendReq("Debugger.nextWasmDisassemblyChunk", opts);
    },

    /**
     * @deprecated
     * This command is deprecated. Use getScriptSource instead.
     */

    getWasmBytecode: async (opts: {
      /**
       * Id of the Wasm script to get source for.
       */
      scriptId: Runtime_ScriptId;
    }): Promise<{
      /**
       * Script source.
       */
      bytecode: string;
    }> => {
      return await this.#sendReq("Debugger.getWasmBytecode", opts);
    },

    /**
     * @experimental
     * Returns stack trace with given `stackTraceId`.
     */

    getStackTrace: async (
      opts: { stackTraceId: Runtime_StackTraceId },
    ): Promise<{ stackTrace: Runtime_StackTrace }> => {
      return await this.#sendReq("Debugger.getStackTrace", opts);
    },

    /**
     * Stops on the next JavaScript statement.
     */

    pause: async (): Promise<void> => {
      return await this.#sendReq("Debugger.pause");
    },

    /**
     * @experimental
     * @deprecated
     */

    pauseOnAsyncCall: async (opts: {
      /**
       * Debugger will pause when async call with given stack trace is started.
       */
      parentStackTraceId: Runtime_StackTraceId;
    }): Promise<void> => {
      return await this.#sendReq("Debugger.pauseOnAsyncCall", opts);
    },

    /**
     * Removes JavaScript breakpoint.
     */

    removeBreakpoint: async (
      opts: { breakpointId: Debugger_BreakpointId },
    ): Promise<void> => {
      return await this.#sendReq("Debugger.removeBreakpoint", opts);
    },

    /**
     * Restarts particular call frame from the beginning. The old, deprecated
     * behavior of `restartFrame` is to stay paused and allow further CDP commands
     * after a restart was scheduled. This can cause problems with restarting, so
     * we now continue execution immediatly after it has been scheduled until we
     * reach the beginning of the restarted frame.
     *
     * To stay back-wards compatible, `restartFrame` now expects a `mode`
     * parameter to be present. If the `mode` parameter is missing, `restartFrame`
     * errors out.
     *
     * The various return values are deprecated and `callFrames` is always empty.
     * Use the call frames from the `Debugger#paused` events instead, that fires
     * once V8 pauses at the beginning of the restarted function.
     */

    restartFrame: async (opts: {
      /**
       * Call frame identifier to evaluate on.
       */
      callFrameId: Debugger_CallFrameId;
      /**
       * @experimental
       * The `mode` parameter must be present and set to 'StepInto', otherwise
       * `restartFrame` will error out.
       */
      mode?: "StepInto";
    }): Promise<{
      /**
       * @deprecated
       * New stack trace.
       */
      callFrames: Debugger_CallFrame[];
      /**
       * @deprecated
       * Async stack trace, if any.
       */
      asyncStackTrace?: Runtime_StackTrace;
      /**
       * @deprecated
       * Async stack trace, if any.
       */
      asyncStackTraceId?: Runtime_StackTraceId;
    }> => {
      return await this.#sendReq("Debugger.restartFrame", opts);
    },

    /**
     * Resumes JavaScript execution.
     */

    resume: async (opts: {
      /**
       * Set to true to terminate execution upon resuming execution. In contrast
       * to Runtime.terminateExecution, this will allows to execute further
       * JavaScript (i.e. via evaluation) until execution of the paused code
       * is actually resumed, at which point termination is triggered.
       * If execution is currently not paused, this parameter has no effect.
       */
      terminateOnResume?: boolean;
    }): Promise<void> => {
      return await this.#sendReq("Debugger.resume", opts);
    },

    /**
     * Searches for given string in script content.
     */

    searchInContent: async (opts: {
      /**
       * Id of the script to search in.
       */
      scriptId: Runtime_ScriptId;
      /**
       * String to search for.
       */
      query: string;
      /**
       * If true, search is case sensitive.
       */
      caseSensitive?: boolean;
      /**
       * If true, treats string parameter as regex.
       */
      isRegex?: boolean;
    }): Promise<{
      /**
       * List of search matches.
       */
      result: Debugger_SearchMatch[];
    }> => {
      return await this.#sendReq("Debugger.searchInContent", opts);
    },

    /**
     * Enables or disables async call stacks tracking.
     */

    setAsyncCallStackDepth: async (opts: {
      /**
       * Maximum depth of async call stacks. Setting to `0` will effectively disable collecting async
       * call stacks (default).
       */
      maxDepth: number;
    }): Promise<void> => {
      return await this.#sendReq("Debugger.setAsyncCallStackDepth", opts);
    },

    /**
     * @experimental
     * Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
     * scripts with url matching one of the patterns. VM will try to leave blackboxed script by
     * performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
     */

    setBlackboxPatterns: async (opts: {
      /**
       * Array of regexps that will be used to check script url for blackbox state.
       */
      patterns: string[];
    }): Promise<void> => {
      return await this.#sendReq("Debugger.setBlackboxPatterns", opts);
    },

    /**
     * @experimental
     * Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
     * scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
     * Positions array contains positions where blackbox state is changed. First interval isn't
     * blackboxed. Array should be sorted.
     */

    setBlackboxedRanges: async (opts: {
      /**
       * Id of the script.
       */
      scriptId: Runtime_ScriptId;
      positions: Debugger_ScriptPosition[];
    }): Promise<void> => {
      return await this.#sendReq("Debugger.setBlackboxedRanges", opts);
    },

    /**
     * Sets JavaScript breakpoint at a given location.
     */

    setBreakpoint: async (opts: {
      /**
       * Location to set breakpoint in.
       */
      location: Debugger_Location;
      /**
       * Expression to use as a breakpoint condition. When specified, debugger will only stop on the
       * breakpoint if this expression evaluates to true.
       */
      condition?: string;
    }): Promise<{
      /**
       * Id of the created breakpoint for further reference.
       */
      breakpointId: Debugger_BreakpointId;
      /**
       * Location this breakpoint resolved into.
       */
      actualLocation: Debugger_Location;
    }> => {
      return await this.#sendReq("Debugger.setBreakpoint", opts);
    },

    /**
     * Sets instrumentation breakpoint.
     */

    setInstrumentationBreakpoint: async (opts: {
      /**
       * Instrumentation name.
       */
      instrumentation:
        | "beforeScriptExecution"
        | "beforeScriptWithSourceMapExecution";
    }): Promise<{
      /**
       * Id of the created breakpoint for further reference.
       */
      breakpointId: Debugger_BreakpointId;
    }> => {
      return await this.#sendReq("Debugger.setInstrumentationBreakpoint", opts);
    },

    /**
     * Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
     * command is issued, all existing parsed scripts will have breakpoints resolved and returned in
     * `locations` property. Further matching script parsing will result in subsequent
     * `breakpointResolved` events issued. This logical breakpoint will survive page reloads.
     */

    setBreakpointByUrl: async (opts: {
      /**
       * Line number to set breakpoint at.
       */
      lineNumber: number;
      /**
       * URL of the resources to set breakpoint on.
       */
      url?: string;
      /**
       * Regex pattern for the URLs of the resources to set breakpoints on. Either `url` or
       * `urlRegex` must be specified.
       */
      urlRegex?: string;
      /**
       * Script hash of the resources to set breakpoint on.
       */
      scriptHash?: string;
      /**
       * Offset in the line to set breakpoint at.
       */
      columnNumber?: number;
      /**
       * Expression to use as a breakpoint condition. When specified, debugger will only stop on the
       * breakpoint if this expression evaluates to true.
       */
      condition?: string;
    }): Promise<{
      /**
       * Id of the created breakpoint for further reference.
       */
      breakpointId: Debugger_BreakpointId;
      /**
       * List of the locations this breakpoint resolved into upon addition.
       */
      locations: Debugger_Location[];
    }> => {
      return await this.#sendReq("Debugger.setBreakpointByUrl", opts);
    },

    /**
     * @experimental
     * Sets JavaScript breakpoint before each call to the given function.
     * If another function was created from the same source as a given one,
     * calling it will also trigger the breakpoint.
     */

    setBreakpointOnFunctionCall: async (opts: {
      /**
       * Function object id.
       */
      objectId: Runtime_RemoteObjectId;
      /**
       * Expression to use as a breakpoint condition. When specified, debugger will
       * stop on the breakpoint if this expression evaluates to true.
       */
      condition?: string;
    }): Promise<{
      /**
       * Id of the created breakpoint for further reference.
       */
      breakpointId: Debugger_BreakpointId;
    }> => {
      return await this.#sendReq("Debugger.setBreakpointOnFunctionCall", opts);
    },

    /**
     * Activates / deactivates all breakpoints on the page.
     */

    setBreakpointsActive: async (opts: {
      /**
       * New value for breakpoints active state.
       */
      active: boolean;
    }): Promise<void> => {
      return await this.#sendReq("Debugger.setBreakpointsActive", opts);
    },

    /**
     * Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions,
     * or caught exceptions, no exceptions. Initial pause on exceptions state is `none`.
     */

    setPauseOnExceptions: async (opts: {
      /**
       * Pause on exceptions mode.
       */
      state: "none" | "caught" | "uncaught" | "all";
    }): Promise<void> => {
      return await this.#sendReq("Debugger.setPauseOnExceptions", opts);
    },

    /**
     * @experimental
     * Changes return value in top frame. Available only at return break position.
     */

    setReturnValue: async (opts: {
      /**
       * New return value.
       */
      newValue: Runtime_CallArgument;
    }): Promise<void> => {
      return await this.#sendReq("Debugger.setReturnValue", opts);
    },

    /**
     * Edits JavaScript source live.
     *
     * In general, functions that are currently on the stack can not be edited with
     * a single exception: If the edited function is the top-most stack frame and
     * that is the only activation of that function on the stack. In this case
     * the live edit will be successful and a `Debugger.restartFrame` for the
     * top-most function is automatically triggered.
     */

    setScriptSource: async (opts: {
      /**
       * Id of the script to edit.
       */
      scriptId: Runtime_ScriptId;
      /**
       * New content of the script.
       */
      scriptSource: string;
      /**
       * If true the change will not actually be applied. Dry run may be used to get result
       * description without actually modifying the code.
       */
      dryRun?: boolean;
      /**
       * @experimental
       * If true, then `scriptSource` is allowed to change the function on top of the stack
       * as long as the top-most stack frame is the only activation of that function.
       */
      allowTopFrameEditing?: boolean;
    }): Promise<{
      /**
       * @deprecated
       * New stack trace in case editing has happened while VM was stopped.
       */
      callFrames?: Debugger_CallFrame[];
      /**
       * @deprecated
       * Whether current call stack  was modified after applying the changes.
       */
      stackChanged?: boolean;
      /**
       * @deprecated
       * Async stack trace, if any.
       */
      asyncStackTrace?: Runtime_StackTrace;
      /**
       * @deprecated
       * Async stack trace, if any.
       */
      asyncStackTraceId?: Runtime_StackTraceId;
      /**
       * @experimental
       * Whether the operation was successful or not. Only `Ok` denotes a
       * successful live edit while the other enum variants denote why
       * the live edit failed.
       */
      status:
        | "Ok"
        | "CompileError"
        | "BlockedByActiveGenerator"
        | "BlockedByActiveFunction"
        | "BlockedByTopLevelEsModuleChange";
      /**
       * Exception details if any. Only present when `status` is `CompileError`.
       */
      exceptionDetails?: Runtime_ExceptionDetails;
    }> => {
      return await this.#sendReq("Debugger.setScriptSource", opts);
    },

    /**
     * Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
     */

    setSkipAllPauses: async (opts: {
      /**
       * New value for skip pauses state.
       */
      skip: boolean;
    }): Promise<void> => {
      return await this.#sendReq("Debugger.setSkipAllPauses", opts);
    },

    /**
     * Changes value of variable in a callframe. Object-based scopes are not supported and must be
     * mutated manually.
     */

    setVariableValue: async (opts: {
      /**
       * 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch'
       * scope types are allowed. Other scopes could be manipulated manually.
       */
      scopeNumber: number;
      /**
       * Variable name.
       */
      variableName: string;
      /**
       * New variable value.
       */
      newValue: Runtime_CallArgument;
      /**
       * Id of callframe that holds variable.
       */
      callFrameId: Debugger_CallFrameId;
    }): Promise<void> => {
      return await this.#sendReq("Debugger.setVariableValue", opts);
    },

    /**
     * Steps into the function call.
     */

    stepInto: async (opts: {
      /**
       * @experimental
       * Debugger will pause on the execution of the first async task which was scheduled
       * before next pause.
       */
      breakOnAsyncCall?: boolean;
      /**
       * @experimental
       * The skipList specifies location ranges that should be skipped on step into.
       */
      skipList?: Debugger_LocationRange[];
    }): Promise<void> => {
      return await this.#sendReq("Debugger.stepInto", opts);
    },

    /**
     * Steps out of the function call.
     */

    stepOut: async (): Promise<void> => {
      return await this.#sendReq("Debugger.stepOut");
    },

    /**
     * Steps over the statement.
     */

    stepOver: async (opts: {
      /**
       * @experimental
       * The skipList specifies location ranges that should be skipped on step over.
       */
      skipList?: Debugger_LocationRange[];
    }): Promise<void> => {
      return await this.#sendReq("Debugger.stepOver", opts);
    },
  };

  /**
   * @experimental
   */
  HeapProfiler = {
    /**
     * Enables console to refer to the node with given id via $x (see Command Line API for more details
     * $x functions).
     */

    addInspectedHeapObject: async (opts: {
      /**
       * Heap snapshot object id to be accessible by means of $x command line API.
       */
      heapObjectId: HeapProfiler_HeapSnapshotObjectId;
    }): Promise<void> => {
      return await this.#sendReq("HeapProfiler.addInspectedHeapObject", opts);
    },

    collectGarbage: async (): Promise<void> => {
      return await this.#sendReq("HeapProfiler.collectGarbage");
    },

    disable: async (): Promise<void> => {
      return await this.#sendReq("HeapProfiler.disable");
    },

    enable: async (): Promise<void> => {
      return await this.#sendReq("HeapProfiler.enable");
    },

    getHeapObjectId: async (opts: {
      /**
       * Identifier of the object to get heap object id for.
       */
      objectId: Runtime_RemoteObjectId;
    }): Promise<{
      /**
       * Id of the heap snapshot object corresponding to the passed remote object id.
       */
      heapSnapshotObjectId: HeapProfiler_HeapSnapshotObjectId;
    }> => {
      return await this.#sendReq("HeapProfiler.getHeapObjectId", opts);
    },

    getObjectByHeapObjectId: async (
      opts: {
        objectId: HeapProfiler_HeapSnapshotObjectId;
        /**
         * Symbolic group name that can be used to release multiple objects.
         */
        objectGroup?: string;
      },
    ): Promise<{
      /**
       * Evaluation result.
       */
      result: Runtime_RemoteObject;
    }> => {
      return await this.#sendReq("HeapProfiler.getObjectByHeapObjectId", opts);
    },

    getSamplingProfile: async (): Promise<{
      /**
       * Return the sampling profile being collected.
       */
      profile: HeapProfiler_SamplingHeapProfile;
    }> => {
      return await this.#sendReq("HeapProfiler.getSamplingProfile");
    },

    startSampling: async (opts: {
      /**
       * Average sample interval in bytes. Poisson distribution is used for the intervals. The
       * default value is 32768 bytes.
       */
      samplingInterval?: number;
      /**
       * By default, the sampling heap profiler reports only objects which are
       * still alive when the profile is returned via getSamplingProfile or
       * stopSampling, which is useful for determining what functions contribute
       * the most to steady-state memory usage. This flag instructs the sampling
       * heap profiler to also include information about objects discarded by
       * major GC, which will show which functions cause large temporary memory
       * usage or long GC pauses.
       */
      includeObjectsCollectedByMajorGC?: boolean;
      /**
       * By default, the sampling heap profiler reports only objects which are
       * still alive when the profile is returned via getSamplingProfile or
       * stopSampling, which is useful for determining what functions contribute
       * the most to steady-state memory usage. This flag instructs the sampling
       * heap profiler to also include information about objects discarded by
       * minor GC, which is useful when tuning a latency-sensitive application
       * for minimal GC activity.
       */
      includeObjectsCollectedByMinorGC?: boolean;
    }): Promise<void> => {
      return await this.#sendReq("HeapProfiler.startSampling", opts);
    },

    startTrackingHeapObjects: async (
      opts: { trackAllocations?: boolean },
    ): Promise<void> => {
      return await this.#sendReq("HeapProfiler.startTrackingHeapObjects", opts);
    },

    stopSampling: async (): Promise<{
      /**
       * Recorded sampling heap profile.
       */
      profile: HeapProfiler_SamplingHeapProfile;
    }> => {
      return await this.#sendReq("HeapProfiler.stopSampling");
    },

    stopTrackingHeapObjects: async (opts: {
      /**
       * If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken
       * when the tracking is stopped.
       */
      reportProgress?: boolean;
      /**
       * @deprecated
       * Deprecated in favor of `exposeInternals`.
       */
      treatGlobalObjectsAsRoots?: boolean;
      /**
       * If true, numerical values are included in the snapshot
       */
      captureNumericValue?: boolean;
      /**
       * @experimental
       * If true, exposes internals of the snapshot.
       */
      exposeInternals?: boolean;
    }): Promise<void> => {
      return await this.#sendReq("HeapProfiler.stopTrackingHeapObjects", opts);
    },

    takeHeapSnapshot: async (opts: {
      /**
       * If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken.
       */
      reportProgress?: boolean;
      /**
       * @deprecated
       * If true, a raw snapshot without artificial roots will be generated.
       * Deprecated in favor of `exposeInternals`.
       */
      treatGlobalObjectsAsRoots?: boolean;
      /**
       * If true, numerical values are included in the snapshot
       */
      captureNumericValue?: boolean;
      /**
       * @experimental
       * If true, exposes internals of the snapshot.
       */
      exposeInternals?: boolean;
    }): Promise<void> => {
      return await this.#sendReq("HeapProfiler.takeHeapSnapshot", opts);
    },
  };

  Profiler = {
    disable: async (): Promise<void> => {
      return await this.#sendReq("Profiler.disable");
    },

    enable: async (): Promise<void> => {
      return await this.#sendReq("Profiler.enable");
    },

    /**
     * Collect coverage data for the current isolate. The coverage data may be incomplete due to
     * garbage collection.
     */

    getBestEffortCoverage: async (): Promise<{
      /**
       * Coverage data for the current isolate.
       */
      result: Profiler_ScriptCoverage[];
    }> => {
      return await this.#sendReq("Profiler.getBestEffortCoverage");
    },

    /**
     * Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
     */

    setSamplingInterval: async (opts: {
      /**
       * New sampling interval in microseconds.
       */
      interval: number;
    }): Promise<void> => {
      return await this.#sendReq("Profiler.setSamplingInterval", opts);
    },

    start: async (): Promise<void> => {
      return await this.#sendReq("Profiler.start");
    },

    /**
     * Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code
     * coverage may be incomplete. Enabling prevents running optimized code and resets execution
     * counters.
     */

    startPreciseCoverage: async (opts: {
      /**
       * Collect accurate call counts beyond simple 'covered' or 'not covered'.
       */
      callCount?: boolean;
      /**
       * Collect block-based coverage.
       */
      detailed?: boolean;
      /**
       * Allow the backend to send updates on its own initiative
       */
      allowTriggeredUpdates?: boolean;
    }): Promise<{
      /**
       * Monotonically increasing time (in seconds) when the coverage update was taken in the backend.
       */
      timestamp: number;
    }> => {
      return await this.#sendReq("Profiler.startPreciseCoverage", opts);
    },

    stop: async (): Promise<{
      /**
       * Recorded profile.
       */
      profile: Profiler_Profile;
    }> => {
      return await this.#sendReq("Profiler.stop");
    },

    /**
     * Disable precise code coverage. Disabling releases unnecessary execution count records and allows
     * executing optimized code.
     */

    stopPreciseCoverage: async (): Promise<void> => {
      return await this.#sendReq("Profiler.stopPreciseCoverage");
    },

    /**
     * Collect coverage data for the current isolate, and resets execution counters. Precise code
     * coverage needs to have started.
     */

    takePreciseCoverage: async (): Promise<{
      /**
       * Coverage data for the current isolate.
       */
      result: Profiler_ScriptCoverage[];
      /**
       * Monotonically increasing time (in seconds) when the coverage update was taken in the backend.
       */
      timestamp: number;
    }> => {
      return await this.#sendReq("Profiler.takePreciseCoverage");
    },
  };

  /**
   * Runtime domain exposes JavaScript runtime by means of remote evaluation and mirror objects.
   * Evaluation results are returned as mirror object that expose object type, string representation
   * and unique identifier that can be used for further object reference. Original objects are
   * maintained in memory unless they are either explicitly released or are released along with the
   * other objects in their object group.
   */
  Runtime = {
    /**
     * Add handler to promise with given promise object id.
     */

    awaitPromise: async (opts: {
      /**
       * Identifier of the promise.
       */
      promiseObjectId: Runtime_RemoteObjectId;
      /**
       * Whether the result is expected to be a JSON object that should be sent by value.
       */
      returnByValue?: boolean;
      /**
       * Whether preview should be generated for the result.
       */
      generatePreview?: boolean;
    }): Promise<{
      /**
       * Promise result. Will contain rejected value if promise was rejected.
       */
      result: Runtime_RemoteObject;
      /**
       * Exception details if stack strace is available.
       */
      exceptionDetails?: Runtime_ExceptionDetails;
    }> => {
      return await this.#sendReq("Runtime.awaitPromise", opts);
    },

    /**
     * Calls function with given declaration on the given object. Object group of the result is
     * inherited from the target object.
     */

    callFunctionOn: async (opts: {
      /**
       * Declaration of the function to call.
       */
      functionDeclaration: string;
      /**
       * Identifier of the object to call function on. Either objectId or executionContextId should
       * be specified.
       */
      objectId?: Runtime_RemoteObjectId;
      /**
       * Call arguments. All call arguments must belong to the same JavaScript world as the target
       * object.
       */
      arguments?: Runtime_CallArgument[];
      /**
       * In silent mode exceptions thrown during evaluation are not reported and do not pause
       * execution. Overrides `setPauseOnException` state.
       */
      silent?: boolean;
      /**
       * Whether the result is expected to be a JSON object which should be sent by value.
       * Can be overriden by `serializationOptions`.
       */
      returnByValue?: boolean;
      /**
       * @experimental
       * Whether preview should be generated for the result.
       */
      generatePreview?: boolean;
      /**
       * Whether execution should be treated as initiated by user in the UI.
       */
      userGesture?: boolean;
      /**
       * Whether execution should `await` for resulting value and return once awaited promise is
       * resolved.
       */
      awaitPromise?: boolean;
      /**
       * Specifies execution context which global object will be used to call function on. Either
       * executionContextId or objectId should be specified.
       */
      executionContextId?: Runtime_ExecutionContextId;
      /**
       * Symbolic group name that can be used to release multiple objects. If objectGroup is not
       * specified and objectId is, objectGroup will be inherited from object.
       */
      objectGroup?: string;
      /**
       * @experimental
       * Whether to throw an exception if side effect cannot be ruled out during evaluation.
       */
      throwOnSideEffect?: boolean;
      /**
       * @experimental
       * An alternative way to specify the execution context to call function on.
       * Compared to contextId that may be reused across processes, this is guaranteed to be
       * system-unique, so it can be used to prevent accidental function call
       * in context different than intended (e.g. as a result of navigation across process
       * boundaries).
       * This is mutually exclusive with `executionContextId`.
       */
      uniqueContextId?: string;
      /**
       * @experimental
       * Specifies the result serialization. If provided, overrides
       * `generatePreview` and `returnByValue`.
       */
      serializationOptions?: Runtime_SerializationOptions;
    }): Promise<{
      /**
       * Call result.
       */
      result: Runtime_RemoteObject;
      /**
       * Exception details.
       */
      exceptionDetails?: Runtime_ExceptionDetails;
    }> => {
      return await this.#sendReq("Runtime.callFunctionOn", opts);
    },

    /**
     * Compiles expression.
     */

    compileScript: async (opts: {
      /**
       * Expression to compile.
       */
      expression: string;
      /**
       * Source url to be set for the script.
       */
      sourceURL: string;
      /**
       * Specifies whether the compiled script should be persisted.
       */
      persistScript: boolean;
      /**
       * Specifies in which execution context to perform script run. If the parameter is omitted the
       * evaluation will be performed in the context of the inspected page.
       */
      executionContextId?: Runtime_ExecutionContextId;
    }): Promise<{
      /**
       * Id of the script.
       */
      scriptId?: Runtime_ScriptId;
      /**
       * Exception details.
       */
      exceptionDetails?: Runtime_ExceptionDetails;
    }> => {
      return await this.#sendReq("Runtime.compileScript", opts);
    },

    /**
     * Disables reporting of execution contexts creation.
     */

    disable: async (): Promise<void> => {
      return await this.#sendReq("Runtime.disable");
    },

    /**
     * Discards collected exceptions and console API calls.
     */

    discardConsoleEntries: async (): Promise<void> => {
      return await this.#sendReq("Runtime.discardConsoleEntries");
    },

    /**
     * Enables reporting of execution contexts creation by means of `executionContextCreated` event.
     * When the reporting gets enabled the event will be sent immediately for each existing execution
     * context.
     */

    enable: async (): Promise<void> => {
      return await this.#sendReq("Runtime.enable");
    },

    /**
     * Evaluates expression on global object.
     */

    evaluate: async (opts: {
      /**
       * Expression to evaluate.
       */
      expression: string;
      /**
       * Symbolic group name that can be used to release multiple objects.
       */
      objectGroup?: string;
      /**
       * Determines whether Command Line API should be available during the evaluation.
       */
      includeCommandLineAPI?: boolean;
      /**
       * In silent mode exceptions thrown during evaluation are not reported and do not pause
       * execution. Overrides `setPauseOnException` state.
       */
      silent?: boolean;
      /**
       * Specifies in which execution context to perform evaluation. If the parameter is omitted the
       * evaluation will be performed in the context of the inspected page.
       * This is mutually exclusive with `uniqueContextId`, which offers an
       * alternative way to identify the execution context that is more reliable
       * in a multi-process environment.
       */
      contextId?: Runtime_ExecutionContextId;
      /**
       * Whether the result is expected to be a JSON object that should be sent by value.
       */
      returnByValue?: boolean;
      /**
       * @experimental
       * Whether preview should be generated for the result.
       */
      generatePreview?: boolean;
      /**
       * Whether execution should be treated as initiated by user in the UI.
       */
      userGesture?: boolean;
      /**
       * Whether execution should `await` for resulting value and return once awaited promise is
       * resolved.
       */
      awaitPromise?: boolean;
      /**
       * @experimental
       * Whether to throw an exception if side effect cannot be ruled out during evaluation.
       * This implies `disableBreaks` below.
       */
      throwOnSideEffect?: boolean;
      /**
       * @experimental
       * Terminate execution after timing out (number of milliseconds).
       */
      timeout?: Runtime_TimeDelta;
      /**
       * @experimental
       * Disable breakpoints during execution.
       */
      disableBreaks?: boolean;
      /**
       * @experimental
       * Setting this flag to true enables `let` re-declaration and top-level `await`.
       * Note that `let` variables can only be re-declared if they originate from
       * `replMode` themselves.
       */
      replMode?: boolean;
      /**
       * @experimental
       * The Content Security Policy (CSP) for the target might block 'unsafe-eval'
       * which includes eval(), Function(), setTimeout() and setInterval()
       * when called with non-callable arguments. This flag bypasses CSP for this
       * evaluation and allows unsafe-eval. Defaults to true.
       */
      allowUnsafeEvalBlockedByCSP?: boolean;
      /**
       * @experimental
       * An alternative way to specify the execution context to evaluate in.
       * Compared to contextId that may be reused across processes, this is guaranteed to be
       * system-unique, so it can be used to prevent accidental evaluation of the expression
       * in context different than intended (e.g. as a result of navigation across process
       * boundaries).
       * This is mutually exclusive with `contextId`.
       */
      uniqueContextId?: string;
      /**
       * @experimental
       * Specifies the result serialization. If provided, overrides
       * `generatePreview` and `returnByValue`.
       */
      serializationOptions?: Runtime_SerializationOptions;
    }): Promise<{
      /**
       * Evaluation result.
       */
      result: Runtime_RemoteObject;
      /**
       * Exception details.
       */
      exceptionDetails?: Runtime_ExceptionDetails;
    }> => {
      return await this.#sendReq("Runtime.evaluate", opts);
    },

    /**
     * @experimental
     * Returns the isolate id.
     */

    getIsolateId: async (): Promise<{
      /**
       * The isolate id.
       */
      id: string;
    }> => {
      return await this.#sendReq("Runtime.getIsolateId");
    },

    /**
     * @experimental
     * Returns the JavaScript heap usage.
     * It is the total usage of the corresponding isolate not scoped to a particular Runtime.
     */

    getHeapUsage: async (): Promise<{
      /**
       * Used heap size in bytes.
       */
      usedSize: number;
      /**
       * Allocated heap size in bytes.
       */
      totalSize: number;
    }> => {
      return await this.#sendReq("Runtime.getHeapUsage");
    },

    /**
     * Returns properties of a given object. Object group of the result is inherited from the target
     * object.
     */

    getProperties: async (opts: {
      /**
       * Identifier of the object to return properties for.
       */
      objectId: Runtime_RemoteObjectId;
      /**
       * If true, returns properties belonging only to the element itself, not to its prototype
       * chain.
       */
      ownProperties?: boolean;
      /**
       * @experimental
       * If true, returns accessor properties (with getter/setter) only; internal properties are not
       * returned either.
       */
      accessorPropertiesOnly?: boolean;
      /**
       * @experimental
       * Whether preview should be generated for the results.
       */
      generatePreview?: boolean;
      /**
       * @experimental
       * If true, returns non-indexed properties only.
       */
      nonIndexedPropertiesOnly?: boolean;
    }): Promise<{
      /**
       * Object properties.
       */
      result: Runtime_PropertyDescriptor[];
      /**
       * Internal object properties (only of the element itself).
       */
      internalProperties?: Runtime_InternalPropertyDescriptor[];
      /**
       * @experimental
       * Object private properties.
       */
      privateProperties?: Runtime_PrivatePropertyDescriptor[];
      /**
       * Exception details.
       */
      exceptionDetails?: Runtime_ExceptionDetails;
    }> => {
      return await this.#sendReq("Runtime.getProperties", opts);
    },

    /**
     * Returns all let, const and class variables from global scope.
     */

    globalLexicalScopeNames: async (opts: {
      /**
       * Specifies in which execution context to lookup global scope variables.
       */
      executionContextId?: Runtime_ExecutionContextId;
    }): Promise<{ names: string[] }> => {
      return await this.#sendReq("Runtime.globalLexicalScopeNames", opts);
    },

    queryObjects: async (opts: {
      /**
       * Identifier of the prototype to return objects for.
       */
      prototypeObjectId: Runtime_RemoteObjectId;
      /**
       * Symbolic group name that can be used to release the results.
       */
      objectGroup?: string;
    }): Promise<{
      /**
       * Array with objects.
       */
      objects: Runtime_RemoteObject;
    }> => {
      return await this.#sendReq("Runtime.queryObjects", opts);
    },

    /**
     * Releases remote object with given id.
     */

    releaseObject: async (opts: {
      /**
       * Identifier of the object to release.
       */
      objectId: Runtime_RemoteObjectId;
    }): Promise<void> => {
      return await this.#sendReq("Runtime.releaseObject", opts);
    },

    /**
     * Releases all remote objects that belong to a given group.
     */

    releaseObjectGroup: async (opts: {
      /**
       * Symbolic object group name.
       */
      objectGroup: string;
    }): Promise<void> => {
      return await this.#sendReq("Runtime.releaseObjectGroup", opts);
    },

    /**
     * Tells inspected instance to run if it was waiting for debugger to attach.
     */

    runIfWaitingForDebugger: async (): Promise<void> => {
      return await this.#sendReq("Runtime.runIfWaitingForDebugger");
    },

    /**
     * Runs script with given id in a given context.
     */

    runScript: async (opts: {
      /**
       * Id of the script to run.
       */
      scriptId: Runtime_ScriptId;
      /**
       * Specifies in which execution context to perform script run. If the parameter is omitted the
       * evaluation will be performed in the context of the inspected page.
       */
      executionContextId?: Runtime_ExecutionContextId;
      /**
       * Symbolic group name that can be used to release multiple objects.
       */
      objectGroup?: string;
      /**
       * In silent mode exceptions thrown during evaluation are not reported and do not pause
       * execution. Overrides `setPauseOnException` state.
       */
      silent?: boolean;
      /**
       * Determines whether Command Line API should be available during the evaluation.
       */
      includeCommandLineAPI?: boolean;
      /**
       * Whether the result is expected to be a JSON object which should be sent by value.
       */
      returnByValue?: boolean;
      /**
       * Whether preview should be generated for the result.
       */
      generatePreview?: boolean;
      /**
       * Whether execution should `await` for resulting value and return once awaited promise is
       * resolved.
       */
      awaitPromise?: boolean;
    }): Promise<{
      /**
       * Run result.
       */
      result: Runtime_RemoteObject;
      /**
       * Exception details.
       */
      exceptionDetails?: Runtime_ExceptionDetails;
    }> => {
      return await this.#sendReq("Runtime.runScript", opts);
    },

    /**
     * Enables or disables async call stacks tracking.
     */

    setAsyncCallStackDepth: async (opts: {
      /**
       * Maximum depth of async call stacks. Setting to `0` will effectively disable collecting async
       * call stacks (default).
       */
      maxDepth: number;
    }): Promise<void> => {
      return await this.#sendReq("Runtime.setAsyncCallStackDepth", opts);
    },

    /**
     * @experimental
     */

    setCustomObjectFormatterEnabled: async (
      opts: { enabled: boolean },
    ): Promise<void> => {
      return await this.#sendReq(
        "Runtime.setCustomObjectFormatterEnabled",
        opts,
      );
    },

    /**
     * @experimental
     */

    setMaxCallStackSizeToCapture: async (
      opts: { size: number },
    ): Promise<void> => {
      return await this.#sendReq("Runtime.setMaxCallStackSizeToCapture", opts);
    },

    /**
     * @experimental
     * Terminate current or next JavaScript execution.
     * Will cancel the termination when the outer-most script execution ends.
     */

    terminateExecution: async (): Promise<void> => {
      return await this.#sendReq("Runtime.terminateExecution");
    },

    /**
     * If executionContextId is empty, adds binding with the given name on the
     * global objects of all inspected contexts, including those created later,
     * bindings survive reloads.
     * Binding function takes exactly one argument, this argument should be string,
     * in case of any other input, function throws an exception.
     * Each binding function call produces Runtime.bindingCalled notification.
     */

    addBinding: async (opts: {
      name: string;
      /**
       * @experimental
       * @deprecated
       * If specified, the binding would only be exposed to the specified
       * execution context. If omitted and `executionContextName` is not set,
       * the binding is exposed to all execution contexts of the target.
       * This parameter is mutually exclusive with `executionContextName`.
       * Deprecated in favor of `executionContextName` due to an unclear use case
       * and bugs in implementation (crbug.com/1169639). `executionContextId` will be
       * removed in the future.
       */
      executionContextId?: Runtime_ExecutionContextId;
      /**
       * If specified, the binding is exposed to the executionContext with
       * matching name, even for contexts created after the binding is added.
       * See also `ExecutionContext.name` and `worldName` parameter to
       * `Page.addScriptToEvaluateOnNewDocument`.
       * This parameter is mutually exclusive with `executionContextId`.
       */
      executionContextName?: string;
    }): Promise<void> => {
      return await this.#sendReq("Runtime.addBinding", opts);
    },

    /**
     * This method does not remove binding function from global object but
     * unsubscribes current runtime agent from Runtime.bindingCalled notifications.
     */

    removeBinding: async (opts: { name: string }): Promise<void> => {
      return await this.#sendReq("Runtime.removeBinding", opts);
    },

    /**
     * @experimental
     * This method tries to lookup and populate exception details for a
     * JavaScript Error object.
     * Note that the stackTrace portion of the resulting exceptionDetails will
     * only be populated if the Runtime domain was enabled at the time when the
     * Error was thrown.
     */

    getExceptionDetails: async (opts: {
      /**
       * The error object for which to resolve the exception details.
       */
      errorObjectId: Runtime_RemoteObjectId;
    }): Promise<{ exceptionDetails?: Runtime_ExceptionDetails }> => {
      return await this.#sendReq("Runtime.getExceptionDetails", opts);
    },
  };

  /**
   * @deprecated
   * This domain is deprecated.
   */
  Schema = {
    /**
     * Returns supported domains.
     */

    getDomains: async (): Promise<{
      /**
       * List of supported domains.
       */
      domains: Schema_Domain[];
    }> => {
      return await this.#sendReq("Schema.getDomains");
    },
  };
}
